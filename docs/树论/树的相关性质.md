# 树的相关性质



## 树的直径



给定一棵 $n$ 个结点的树，树没有边权。请求出树的直径是多少，即树上的最长路径长度是多少。

数据保证，$1 \leq n \leq 10^5$。

---

定理：在一棵树上，从任意节点 $y$ 开始进行一次DFS，到达的距离其最远的节点$z$必为直径的一端。

于是我们只需要两次dfs即可解决问题。

该做法不适合有负权边的树。

```C++

vector<int > e[N];

void add(itn a,itn b){
    e[a].pb(b);
    e[b].pb(a);
}
itn d[N];

itn ansl=0;
int ansr=0;

void dfs(int x,int f){
    d[x]=d[f]+1;
    if(d[x]>d[ansl])ansl=x;
    for(auto v:e[x]){
        if(v==f)continue;
        dfs(v,x);
    }
}


void dfs2(int x,int f){
    d[x]=d[f]+1;
    if(d[x]>d[ansr])ansr=x;
    for(auto v:e[x]){
        if(v==f)continue;
        dfs2(v,x);
    }
}

void solve(){
    itn n=rd;
    for(itn i=1;i<n;i++){
        add(rd,rd);
    }
    dfs(1,0);
    memset(d,0,sizeof d);
    dfs2(ansl,0);

    cout<<d[ansr]-1<<endl;
}
```

## 树的重心

如果在树中选择某个节点并删除，这棵树将分为若干棵子树，统计子树节点数并记录最大值。取遍树上所有节点，使此最大值取到最小的节点被称为整个树的重心。

求法：

根据定义，我们一次dfs，逐个点判断是否当选为重心即可。考虑$sz_v$和 $n-sz_x$。



## 树的遍历

树的遍历（Tree Traversal）是树的一种基本操作，它按照某种顺序访问树中的所有节点，每个节点都被访问一次。对于二叉树而言，常见的遍历方式有三种：

1. **先序遍历（Pre-order Traversal）**：

    - 访问根节点。

    - 先序遍历左子树。

    - 先序遍历右子树。

        在先序遍历中，根节点首先被访问，然后递归地遍历左子树，最后递归地遍历右子树。

1. **中序遍历（In-order Traversal）**：

    - 中序遍历左子树。

    - 访问根节点。

    - 中序遍历右子树。

        在中序遍历中，左子树首先被遍历，然后访问根节点，最后遍历右子树。

1. **后序遍历（Post-order Traversal）**：

    - 后序遍历左子树。

    - 后序遍历右子树。

    - 访问根节点。

        在后序遍历中，左右子树首先按照后序遍历的方式被访问，最后访问根节点。

        下面以一个具体的二叉树为例，来展示这三种遍历的结果：

```C++
    A
   / \
  B   C
 / \
D   E
```

- **先序遍历**的结果是：A B D E C

- **中序遍历**的结果是：D B E A C

- **后序遍历**的结果是：D E B C A
每种遍历方式都有其特定的应用场景。例如，先序遍历常用于创建树的副本或者在显示树的结构时使用；中序遍历常用于排序操作，因为中序遍历二叉搜索树的结果是按照节点键值的升序排列的；后序遍历常用于删除树的操作，因为在删除节点之前，需要先删除其子节点。



---

### 树、森林与其对应的二叉树的遍历方法的对应关系

> 版权声明：本文为CSDN博主「Zoey_Yeah」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Zoey_Yeah/article/details/80199554

输入一棵二叉树的先序和中序遍历序列，输出其后序遍历序列。

给定一棵树，可以找到唯一一棵二叉树与之对应，同样，森林也与一棵树存在一一对应关系。树与二叉树，森林与二叉树的转化如下图所示，（a）（b）（c）为三棵树，并构成一个森林，（d）（e）（f）分别为（a）（b）（c）对应的二叉树，（g）为森林对应的二叉树。这里不再详细介绍转化方法。

下面首先说一说树的遍历方法，及与其对应二叉树的遍历方法的关系。
树结构有两种次序遍历树的方法：
1.先根遍历：先访问树的根节点，再依次先根遍历子树；

2.后根遍历：先依次后根遍历子树，再访问树的根节点。
不曾看到过树的‘中根遍历’的概念，因为树并不一定是二叉树，‘中’的概念不好定义，比如对于一个拥有3个子树的根节点来说，根节点除了先根和后根两种遍历方式之外还有另外两种次序，如一种次序是先遍历根节点的第一棵子树，再访问根节点，之后再依次遍历剩余子树，另一种次序是，先遍历根节点的前两棵子树，再访问根节点，最后访问第三棵子树。对于拥有更多子树的根节点来说，依次遍历的方法更多。

树的先根遍历和后根遍历可分别借用对应二叉树的先序遍历和中序遍历实现。以上图（a）中的树和其对应的（d）中的二叉树为例：

对树进行先根遍历：A B C D
对树进行后根遍历：B C D A

对二叉树进行先序遍历：A B C D（与树的先根遍历一致）

对二叉树进行中序遍历：B C D A（同树的后根遍历）

接下来说一说森林的遍历方法，及与其对应的二叉树的遍历方法的关系。
森林的两种遍历方法：
1.先序遍历森林：

（1）访问森林中第一棵树的根节点；

（2）先序遍历第一棵树中根节点的子树森林；
（3）先序遍历除去第一棵树之后剩余的树构成的森林。

2.中序遍历森林

（1）中序遍历森林中第一棵树的根节点的子树森林；

（2）访问第一棵树的根节点；

（3）中序遍历除去第一棵树之后剩余的树构成的森林。

在森林的中序遍历方法中需要注意，森林的中序遍历与二叉树的中序遍历方法的定义不同，二叉树的中序遍历是按照LDR的顺序进行遍历，而森林的中序遍历是要先中序遍历第一棵树的所有子树，再访问这棵树的根节点，对于这棵树来说，根节点的访问次序其实是整棵树遍历的最后（类似于二叉树的后序），这里经常与二叉树的中序遍历混淆，傻傻分不清楚~

下面，看看森林遍历方法和其对应的二叉树遍历方法的对应关系。当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，则森林的先序和中序遍历即对应二叉树的先序和中序遍历。以上图中（a）（b）（c）构成的森林和对应的二叉树（g）为例：

对森林进行先序遍历：A B C D E F G H I J

对森林进行中序遍历：B C D A F E H J I G

对二叉树进行先序遍历：A B C D E F G H I J（与森林先序遍历一致）
对二叉树进行中序遍历：B C D A F E H J I G(同森林中序遍历)


