# 树的相关性质



## 树的直径



给定一棵 $n$ 个结点的树，树没有边权。请求出树的直径是多少，即树上的最长路径长度是多少。

数据保证，$1 \leq n \leq 10^5$。

---

定理：在一棵树上，从任意节点 $y$ 开始进行一次DFS，到达的距离其最远的节点$z$必为直径的一端。

于是我们只需要两次dfs即可解决问题。

该做法不适合有负权边的树。

```C++

vector<int > e[N];

void add(itn a,itn b){
    e[a].pb(b);
    e[b].pb(a);
}
itn d[N];

itn ansl=0;
int ansr=0;

void dfs(int x,int f){
    d[x]=d[f]+1;
    if(d[x]>d[ansl])ansl=x;
    for(auto v:e[x]){
        if(v==f)continue;
        dfs(v,x);
    }
}


void dfs2(int x,int f){
    d[x]=d[f]+1;
    if(d[x]>d[ansr])ansr=x;
    for(auto v:e[x]){
        if(v==f)continue;
        dfs2(v,x);
    }
}

void solve(){
    itn n=rd;
    for(itn i=1;i<n;i++){
        add(rd,rd);
    }
    dfs(1,0);
    memset(d,0,sizeof d);
    dfs2(ansl,0);

    cout<<d[ansr]-1<<endl;
}
```

## 树的重心

如果在树中选择某个节点并删除，这棵树将分为若干棵子树，统计子树节点数并记录最大值。取遍树上所有节点，使此最大值取到最小的节点被称为整个树的重心。

求法：

根据定义，我们一次dfs，逐个点判断是否当选为重心即可。考虑$sz_v$和 $n-sz_x$。

