- 组合计数

- 康托展开

# 组合数

介绍组合数的4种不同的方法。

[董晓算法的个人空间-董晓算法个人主页-哔哩哔哩视频](https://space.bilibili.com/517494241/search/video?keyword=组合)

## 组合数的求法

### 递推法求组合数

![image.png](组合计数/image.png)

递推初始值

![image.png](组合计数/image 1.png)

当$j=0$时$c(i,j)=1$.

每个数由其上方和左上方的数相加得来（**杨辉三角**）

```C++

void init(){
	c[0][0]=1;//从0开始！
	for(int i=1;i<=n;i++){
		c[i][0]=1;
		for(int j=1;j<=n;j++){
			c[i][j]=c[i-1][j]+c[i-1][j-1]%MOD;
		}
	}
//	for(int i=0;i<=10;i++){
//		for(int j=0;j<=i;j++){
//			cerr<<c[i][j]<<' ';
//		}
//		cerr<<endl;
//	}
}
```

### 快速幂求组合数

![image.png](组合计数/image 2.png)

考察题目要求

![image.png](组合计数/image 3.png)

复习**乘法逆元**相关知识，理解$g[x]$的含义

![image.png](组合计数/image 4.png)

复习**费马小定理**，得：

在$p$为质数时，$a^{p-2}$即$a$在模$p$下的逆元

因此我们使用快速幂求$a^{p-2}$（也就是求$(x!)^{-1}$，当然，$x!$需要递推求出，因此我们可以把$1!\sim n!$的逆元全部预处理出来）

![image.png](组合计数/image 5.png)

### Lucas定理求组合数

![image.png](组合计数/image 6.png)

方法：

递推+快速幂（即下方标识的“可以直接求解”）

![image.png](组合计数/image 7.png)

**证明**

![image.png](组合计数/image 8.png)

$inv(x)$就是$x$的乘法逆元

易证。

![image.png](组合计数/image 9.png)

由引理2得，当$i=1\sim p-1$时，都满足引理1，求和时全部约掉，只剩下$i=0$和$i=p$两种特殊情况，分别代入，得到两个单项式为$1$和$x^p$

易证。

**补充**

请学习**二项式定理！**

![image.png](组合计数/image 10.png)

在(2)中使用了**引理2**

使用的方法为**比较系数法**

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define int long long
#define db double
#define rtn return
using namespace std;

const int N=2e5+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

int n,m,p,q,T,fac[N],ans;

int ksm(int c,int k,int p) {
//	p=p;
	if(!c)return 0;
	int res=1;
	while(k){
		if(k&1)res=(res*c)%p;
		c=(c*c)%p;k>>=1;
	}
	return res;
}

void comb_init(){
	fac[0]=1;
	for (int i=1;i<=p;++i) fac[i]=fac[i-1]*i%p;
}

int inv(int x){
	
    return ksm(x,p-2,p);//请保证p为质数
} 

int C(int n,int m){
	if(n-m<0)return 0;
	//n==m时不能rt 0 
    return fac[n]*inv(fac[m])%p*inv(fac[n-m])%p;
}


int lucas(int n,int m){
	if(n==p)return 0;
	if(m==0)return 1;
	return lucas(n/p,m/p)*C(n%p,m%p)%p;
}

signed main(){
	
	cin>>T;
	while(T--){
		cin>>n>>m>>p;comb_init();
		cout<<lucas(n+m,n)<<endl;
	}
	return 0;
}


```

### 高精度&线性筛求组合数

背景

![image.png](组合计数/image 11.png)

小技巧

![image.png](组合计数/image 12.png)

原理

![image.png](组合计数/image 13.png)

我们将$C_n^m$分解质因数，然后逐步累乘进$C_n^m$

乍一看**第2步**可能看不到，这里就介绍一下：

$c[i]$的初始值为$1$，后面将$C_n^m$的质因数逐步求出来（从小到大），即遍历质数表从小到大，求出质数$p_i$的个数$n$，然后指向$n$次将$c[i]*=p_i$

代码

```C++
/*////////ACACACACACACAC///////////
       . Code by Ntsc .
       . Love by  .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define ll long long
#define db double
#define rtn return
using namespace std;

const int N=1e4;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

int n,m,ans,cnt,p,l;
int prim[N],notp[N],b[N];
int get(int n,int p){//计算n!中质数p的个数,根据公式 
	int s=0;
	while(n)s+=n/p,n/=p;//point1 
	return s;
}
int getc(int n,int m,int p){//计算c_n^m中质数p的个数 
	return get(n,p)-get(m,p)-get(n-m,p);//分子中p的个数-分母中p的个数 
}
void mul(int c[],int p,int &l){//高精度×单精度 
	int t=0;
	for(int i=0;i<l;i++){
		t+=c[i]*p;
		c[i]=t%10;
		t/=10;
	}
	while(t){
		l++;
		c[l]=t%10;
		t/=10;
	}
}
void init(){//初始化筛质数表 
	for(int i=2;i<=N;i++){
		if(!notp[i])prim[++cnt]=i;
		for(int j=i;j<N;j+=i)notp[j]=1;
	}
}
signed main(){
	init();
	
	cin>>n>>m; 
	int c[N],l=1;c[0]=1;
	for(int i=1;i<=cnt;i++){//遍历每一个质数 
		int p=prim[i];
		int s=getc(n,m,p);//求出c_n^m中质数p的个数
		while(s--)mul(c,p,l) ;//将c乘上p,乘n次 
	} cout<<"OK"<<endl;
	for(int i=l;i;i--)cout<<c[i];
	return 0;
}

```

```C++
/*////////ACACACACACACAC///////////
       . Code by Ntsc .
       . Love by  .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define ll long long
#define db double
#define rtn return
using namespace std;

const int N=1e4+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

int n,m,ans,cnt,p,l;
int prim[M],notp[M],c[M];
int get(int n,int p){//计算n!中质数p的个数,根据公式 
	int s=0;
	while(n)s+=n/p,n/=p;//point1 
	return s;
}
int getc(int n,int m,int p){//计算c_n^m中质数p的个数 
	return get(n,p)-get(m,p)-get(n-m,p);//分子中p的个数-分母中p的个数 
}
void mul(int c[],int p){//高精度×单精度 
	int t=0;
	for(int i=0;i<l;i++){
		t+=c[i]*p;
		c[i]=t%10;
		t/=10;
	}
	while(t){
		l++;
		c[l]=t%10;
		t/=10;
	}
}
void init(){//初始化筛质数表 
	for(int i=2;i<=N;i++){
		if(!notp[i])prim[++cnt]=i;
		for(int j=i;j<=N;j+=i)notp[j]=1;
	}
}
signed main(){
	init();
	
	cin>>n>>m; 
	l=1;c[0]=1;
	for(int i=1;i<=cnt;i++){//遍历每一个质数 
		int p=prim[i];
		int s=getc(n,m,p);//求出c_n^m中质数p的个数
		while(s--)mul(c,p) ;//将c乘上p,乘n次 
	} 
//	cout<<"OK"<<endl;
	for(int i=l-1;i+1;i--)cout<<c[i];
	cout<<endl<<"cnt="<<cnt<<" l="<<l<<endl;
	for(int i=1;i<=cnt;i++)cout<<prim[i]<<' '; 
	return 0;
}

```

point1：

我们要懂得将

$\frac{n}{p^i}$

转化为

$\frac{\frac{n}{p^{i-1}}}{p}$

从而递推，不需要计算$p^i$

## 标准函数

```C++

int C(int u, int v) { return fac[u] * inv[v] % P * inv[u - v] % P; }

signed main() {
    fac[0] = 1;
    for (int i = 1; i <= N - 2; i++) fac[i] = (fac[i - 1] * i) % P;

    inv[1] = 1, inv[0] = 1;  // att!当n=m时特判，组合为1
    for (int i = 2; i <= N - 2; i++) inv[i] = ((P - P / i) * inv[P % i]) % P;
    for (int i = 1; i <= N - 2; i++) inv[i] = (inv[i] * inv[i - 1]) % P;
  //...
}
```

## 组合数学常用模型

### 错排列

错排列，又称作德利克雷排列，是指一个排列中没有任何一个元素在原来位置上的排列方式。例如，对于3个元素的错排列有2种：[2, 3, 1]和[3, 1, 2]。

### 圆排列

圆排列是指在一个圆周上进行的排列，由于圆的旋转对称性，不同的旋转被视为相同的排列。例如，圆周上3个点的圆排列只有2种，因为每种排列可以通过旋转得到另外两种。

### 鸽巢原理

鸽巢原理，又称狄利克雷抽屉原理，简单来说就是如果有n个鸽子和m个鸽巢，且n > m，那么至少有一个鸽巢里有多于一个鸽子。例如，如果有10个苹果放入9个盒子里，至少有一个盒子里有不止一个苹果。

### 容斥原理

容斥原理是一个计数原理，用于计算多个集合的并集的大小。其基本思想是：先加上每个集合的大小，然后减去每对交集的大小，再加上三个集合交集的大小，以此类推。例如，计算三个集合A、B、C的并集大小，公式为：|A∪B∪C| = |A| + |B| + |C| - |A∩B| - |A∩C| - |B∩C| + |A∩B∩C|。

### 卡特兰数

[卡特兰数 - OI Wiki](https://oi-wiki.org/math/combinatorics/catalan/)


![image.png](组合计数/image 14.png)

卡特兰数的一般形式为：

$C_n = \frac{1}{n+1} \binom{2n}{n} = \frac{(2n)!}{(n+1)!n!} $

对于第 ( n ) 个卡特兰数 ( C_n )，其前几个数值如下：

- ( C_0 = 1 )

- ( C_1 = 1 )

- ( C_2 = 2 )

- ( C_3 = 5 )

- ( C_4 = 14 )

- ( C_5 = 42 )

- ( C_6 = 132 )

- ( C_7 = 429 )

- ...

    卡特兰数在许多组合问题中自然出现，以下是一些著名的例子：

1. **括号匹配问题**：( C_n ) 表示用 ( n ) 对括号能够形成的不同括号序列的数量。

2. **二叉树问题**：有 ( n ) 个内部节点（即非叶节点）的二叉树的不同形态数量是 ( C_{n-1} )。

3. **多边形划分问题**：将一个凸多边形用 ( n-3 ) 条对角线划分成 ( n ) 个三角形的方法数是 ( C_{n-2} )。

4. **栈操作问题**：给定 ( n ) 个“进栈”操作和 ( n ) 个“出栈”操作的所有合法序列的数量是 ( C_n )。
卡特兰数在算法、计算机科学、数学证明等多个领域都有着重要的应用。它们通常通过递推关系式来计算：
$ C_{n+1} = \sum_{i=0}^{n} C_i C_{n-i} $
或者通过直接使用上面的公式计算。

```C++
	c[1]=c[0]=1;
	for(int i=1;i<=n;i++)c[i]=c[i-1]*(4*i-2)/(i+1);
```

[www.luogu.com.cn](https://www.luogu.com.cn/problem/P1044)


![image.png](组合计数/image 15.png)

#### 例题

[www.luogu.com.cn](https://www.luogu.com.cn/problem/P2532)




