# 质数筛法

### 定义

![OIP-C.Vm205xkbzhUHc5d9cW-T6QHaHC](筛法/OIP-C.Vm205xkbzhUHc5d9cW-T6QHaHC)

### 筛法

**一、朴素筛法**

对于每个数，筛掉他的所有倍数

复杂度：2要筛n / 2 次，3要筛n / 3次，所以一共要筛n / 2 + n / 3 + …n / n，也就是 n * (1 / 2 + 1 / 3 + … + 1 / n)次，后面求和是调和级数，当 n 足够大时，等于lnn + c，c是常数,所以复杂度为 logn * n.

**二、埃氏筛法**

![v2-06e72db7050d7492b1f5c253675618fa_r.jpg](筛法/v2-06e72db7050d7492b1f5c253675618fa_r.jpg)

复杂度：质数定理：1 - n 中质数的数量是 n / lnn 个，所以埃氏筛法的复杂度为 n * loglog n，很接近线性了。

**代码实现**

```C++
#include<bits/stdc++.h>
using namespace std;
int n,cnt,prime[100001],notprime[100001];

void erat(int n){
	for(int i=2;i<=n;i++)
	if(!notprime[i]){
		prime[++cnt]=i;
		for(int j=2;j<=n/i;j++){
			notprime[j*i]=1;
		}
	}
}
signed main(){
	cin>>n;
	erat(n);
	for(int i=1;i<=cnt;i++)cout<<prime[i]<<' ';
}
```

**三、线性筛**

![R-C.2dd03097fb6e338bd01f91c7243e1fc6](筛法/R-C.2dd03097fb6e338bd01f91c7243e1fc6)

例如 在埃氏筛中 6 会被 2 和 3 都筛一遍，增加了复杂度

代码中两种情况的解释：

当 i % pj == 0 时，$p_j $一定是 $i $ 的最小质因子，因此 $p_j$ 一定是 $p_j$ * i 的最小质因子。
当 i % pj != 0 时，$p_j$ 一定小于 $ i$ 的最小质因子，因此 $p_j$一定是 $p_j$ * i 的最小质因子。
————————————————

原文链接：[https://blog.csdn.net/magnte/article/details/119805672](https://blog.csdn.net/magnte/article/details/119805672)

**代码实现**

```C++
#include<bits/stdc++.h>
using namespace std;
int n,cnt,prime[100001],notprime[100001];

void oula(int n){
	for(int i=2;i<=n;i++){
	
		if(!notprime[i]){
			prime[++cnt]=i;
			notprime[i]=i;
		}
		for(int j=1;j<=cnt;j++){
			if(prime[j]>notprime[i]||prime[j]>n/i)break;
			notprime[i*prime[j]]=prime[j];
		} 
	}
}
signed main(){
	cin>>n;
	oula(n);
	for(int i=1;i<=cnt;i++)cout<<prime[i]<<' ';
}
```

当`notprime[i] = i`时,说明`i`是质数,反之存`i`的最小质因子.

i从 $2 \to n$ 递增, 每次到达一个 $i$ ,  筛去数 $i \times p$ (即将`notprime[i*p]`赋值为`p`), 其中 $p≤notprime[i]$ 且为质数

![image.png](筛法/image.png)

**优化算法**

例题

[【模板】线性筛素数 - 洛谷](https://www.luogu.com.cn/problem/P3383)

算法

[【算法/数论】欧拉筛法详解：过程详述、正确性证明、复杂度证明_seh_sjlj的博客-CSDN博客](https://blog.csdn.net/qaqwqaqwq/article/details/123587336)

```C++
#include<bits/stdc++.h>
using namespace std;
const int N=1e8+5;
int notprime[N],q;
bool isprime[N]; // isprime[i]表示i是不是素数
int prime[N]; // 现在已经筛出的素数列表
int n; // 上限，即筛出<=n的素数
int cnt; // 已经筛出的素数个数

void euler()
{
    memset(isprime, true, sizeof(isprime)); // 先全部标记为素数
    isprime[1] = false; // 1不是素数
    for(int i = 2; i <= n; +/ i从2循环到n（外层循环）
    {
        if(isprime[i]) prime[++cnt] = i;
        // 如果i没有被前面的数筛掉，则i是素数
        for(int j = 1; j <= cnt && i * prime[j] <= n; ++j)
        // 筛掉i的素数倍，即i的prime[j]倍
        // j循环枚举现在已经筛出的素数（内层循环）
        {
            isprime[i * prime[j]] = false;
            // 倍数标记为合数，也就是i用prime[j]把i * prime[j]筛掉了
            if(i % prime[j] == 0) break;
            // 最神奇的一句话，如果i整除prime[j]，退出循环
            // 这样可以保证线性的时间复杂度
        }
    }
}

signed main(){
	cin>>n>>q;
	euler();
	while(q--){
		int k;
		cin>>k;
		cout<<prime[k]<<endl;
	}
}
```

![image.png](筛法/image 1.png)

