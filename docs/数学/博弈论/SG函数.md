# SG函数



[b23.tv](https://b23.tv/1EhMtYO)

### 适用范围


**有向图游戏**
给定一个有向无环图，图中只有一个起点，在起点上放一个棋子，两个玩家轮流沿着有向边推动棋子，每次走一步，不能走的玩家失败。


### 运算定义


mex运算（minimum exlusion）
$mex(S)$为不属于集合$S$中的最小非负整数， $mex(S)=min\{x|x\in N,x\notin S\}$ 例如，$mex(\{0,1,2\})=3，mex(\{1,2\})=0$


### 函数定义


SG函数
设状态（节点）x有k个后继状态（子节点）$y_1,y_2,...,y_k,\\$
$SG(x)=mex(\{SG(y_1),SG(y_2),...,SG(y_k)\})$

对于某个节点,若其SG为0,则该点的玩家必败.反正必胜

### 练习

我们来进行以下对SG函数的求解练习

![image.png](SG函数/image.png)

图中绿色数字即该点的SG值，请注意，图2的根节点1的SG值为0.请结合定义思考。

### 状态

SG定理：
由n个有向图游戏组成的组合游戏，设起点分别为$s_{1}$，$s_{2}$，…… ，$s_{n}$。
当$SG(s_{1})\oplus SG(s_{2})\oplus … \oplus SG(s_{n})\neq 0$时，先手必胜；反之，先手必败。



让我们结合图2进行具体分析：

先手为A，对方为B

当A将棋子从1→2/7/6时，SG(1)=0,说明其为必败.到达2/6/7后,我们会发现其因为对1的所有出点进行mex操作后得到SG(1)=0,说明1的所有出点中没有0,即A留给B的都是必胜态.

因为A,B均会采取最优走法,所以在先手确定时,胜负就已经定了,每次A→B或者B→A都是一次必胜态和必败态之间的转化.

根据SG函数性质,可以发现一个必胜态后一定有一个必败态,这样必胜态的玩家就可以选择走让对手必败的那条路径.必胜态的玩家必胜.反之,一个必败态后面均是必胜态,那么必败态的玩家无法让对手必败.必败态的玩家必败

因此在起点,就可以知道先手的胜败



对于多个有向图组成的组合游戏,如图,根据定理得先手必胜.因为先手一定可以找到一个走法,让场上3颗棋子的所在位置的SG异或和=0,给对手一个必败态.接下来无论对手怎么走,都会留下一个必胜态给先手

![image.png](SG函数/image 1.png)

### 整理总结

1. 必胜态的后继状态至少存在一个必败态

2. 必败态的后继状态均为必胜态

3. 终态$0\oplus0...\oplus0=0$



### 实现方法 STL_Set

定义的代码如下：

```C++
set<int> a; // 定义一个int类型的集合a
// set<int> a(10); // error，未定义这种构造函数
// set<int> a(10, 1); // error，未定义这种构造函数
set<int> b(a); // 定义并用集合a初始化集合b
set<int> b(a.begin(), a.end()); // 将集合a中的所有元素作为集合b的初始值
```



除此之外，还可以直接使用数组来初始化向量：

```C++
int n[] = { 1, 2, 3, 4, 5 };
list<int> a(n, n + 5); // 将数组n的前5个元素作为集合a的初值
```

- 容器大小：`st.size();`

- 容器最大容量：`st.max_size();`

- 容器判空：`st.empty();`

- 查找键 key 的元素个数：`st.count(key);`

[[C++ STL] set使用详解 - fengMisaka - 博客园](https://www.cnblogs.com/linuxAndMcu/p/10261014.html)

### 例题 #1

![image.png](SG函数/image 2.png)

例题简单,直接快照

![image.png](SG函数/image 3.png)

注:每个节点的子节点都是这个节点取了 $a_i$ 个石子后剩下的石子数量

![image.png](SG函数/image 4.png)

回顾下普通Nim游戏

![image.png](SG函数/image 5.png)

### 例题 #2

![image.png](SG函数/image 6.png)

算法

![image.png](SG函数/image 7.png)

$mex$的第一个部分即按行剪的结果,第2部分即按列剪的结果

因为$SG$定理要求最终(叶子节点)是必败态,因此要注意边界

因为最终的叶子节点的剩余纸片长宽 $≥2$ ,因此$mex$中 $2≤i$ 

![image.png](SG函数/image 8.png)

有2个$2,4$?

因为每个节点存的是当前剩余纸片的长宽,因此当在第$2,3$行之间裁开和在第$3,4$行之间裁开都会各有一个$2,4$,同理也各有一个$3,4$

每进行一次操作,都会分裂出2个子节点(小纸片),对于一个纸片,可以有0个或n个操作方法

