专题 | 数学3（NOI级）

# 目录

- 原根

- 拉格朗日插值

- 莫比乌斯反演

# 原根

### 用途



# 拉格朗日插值

通项公式

$f(x)=\sum\limits_{i=1}^n[a_i\times (\prod\limits_{j=1,j≠i}^n \frac{(x-x_j)}{(x_i-x_j)})]$

这个公式由n个函数拟合（即相加）得到，这n个函数分别是$f_i(x)=a_i\times (\prod\limits_{j=1,j≠i}^n \frac{(x-x_j)}{(x_i-x_j)})$，这n个函数均满足：次数$<n$，在$x=x_i$时$y=y_i$，其余$x=x_j(j≠i)$时$y=0$

## 题目描述

~~由小学知识可知~~ $n$ 个点 $(x_i,y_i)$ 可以唯一地确定一个多项式 $y = f(x)$。

现在，给定这 $n$ 个点，请你确定这个多项式，并求出 $f(k) \bmod 998244353$ 的值。

[【拉格朗日插值】：思想、计算与误差_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1fL4y1T7fL/?spm_id_from=333.788.recommend_more_video.1)


# 莫比乌斯反演

## [POI2007] ZAP-Queries

密码学家正在尝试破解一种叫 BSA 的密码。

他发现，在破解一条消息的同时，他还需要回答这样一种问题：

给出 $a,b,d$，求满足 $1 \leq x \leq a$，$1 \leq y \leq b$，且 $\gcd(x,y)=d$ 的二元组 $(x,y)$ 的数量。

因为要解决的问题实在太多了，他便过来寻求你的帮助。

输入格式

输入第一行一个整数 $n$，代表要回答的问题个数。

接下来 $n$ 行，每行三个整数 $a,b,d$。

输出格式

对于每组询问，输出一个整数代表答案。

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 5 \times 10^4$，$1 \leq d \leq a,b \leq 5 \times 10^4$。

## 其它练习

[学习笔记 | 莫比乌斯反演](https://flowus.cn/5d0d6514-d352-47dd-b781-0071fecf5502)

# 群论

## 置换群

置换：给定一个序列a，将a重新排列后一一映射即为置换

循环置换：将序列a整体向右平移1位后一一映射。

任意一个置换都可以拆分成若干个循环置换的乘积（乘积：设两个置换映射为f(x),g(x)，这其乘积为g(f(x))）

其实是废话，因为循环置换太特殊啦！

置换群：对于一个长度为n的序列a，其所有置换有n!种，选择其中若干种即为一个置换群。

### Polya定理

Burnside引理：每个置换的**不动点**个数的平均值就是不同方案数。

Polya定理：假设有一个置换可以拆成k个循环，每个循环有c种选法，那么这个置换的不动点的个数就是c^k

**std**

```C++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
#define ps second
#define pf first
 
 
#define rd read()
inline int read()
{
	int xx=0,ff=1;
	char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') ff=-1;c=getchar();}
	while(c>='0'&&c<='9') xx=xx*10+(c-'0'),c=getchar();
	return xx*ff;
}
inline void write(int out)
{
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}
 
 
const int N=2e5+5;
const int M=5e5+5;
const int INF=1e9+5;
const int MOD=1e9+7;
bool f1;
int m,k,n,qzh;
 
int q;
int T,mn=INF,ans;

int ksm(int a,int b){ 
    int res=1;
    while(b){
        if(b&1)res=(res*a)%MOD;
        a=(a*a)%MOD;
        b>>= 1;
    }
    return res;
}

int euler(int n) { //欧拉函数
	int res=1;
	for(int i=2; i*i<=n; i++)
		if(n%i==0) {
			n/=i,res=res*(i-1);
			while(n%i==0) n/=i,res=res*i;
		}
	if(n>1) res=res*(n-1);
	return res;
}

int polya(int m,int n) {
	int tot=0;
	for(int i=1; i*i<=n; i++) {
		if(n%i) continue;
		tot+=euler(i)*ksm(m,n/i-1);
		if(i*i!=n) tot+=euler(n/i)*ksm(m,i-1);
	}
	return tot%MOD;
}

signed main(){
	int t=rd;
	while(t--){
		int n=rd;
		cout<<polya(n,n)<<endl;
	}
}
```

