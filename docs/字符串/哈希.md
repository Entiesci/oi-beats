# 哈希

## 字符串哈希

应用于字符串匹配的哈希算法。



## 双哈希防卡

[专题 | 南外20230712-链表、哈希、并查集、分块](https://flowus.cn/6f0fba60-f356-44a6-b89a-8012f66cb0a9) E题

## 树哈希

[专题 | 南外20230712-链表、哈希、并查集、分块](https://flowus.cn/6f0fba60-f356-44a6-b89a-8012f66cb0a9) F题

### [NOIP2018 普及组] 对称二叉树

一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树：

1. 二叉树；

2. 将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。

下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。

![https://cdn.luogu.com.cn/upload/image_hosting/nkln7z1l.png](https://cdn.luogu.com.cn/upload/image_hosting/nkln7z1l.png)

现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数最多。请输出这棵子树的节点数。

注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。

第一行一个正整数 $n$，表示给定的树的节点的数目，规定节点编号 $1 \sim n$，其中节点 $1$ 是树根。

第二行 $n$ 个正整数，用一个空格分隔，第 $i$ 个正整数 $v_i$ 代表节点 $i$ 的权值。

接下来 $n$ 行，每行两个正整数 $l_i, r_i$，分别表示节点 $i$ 的左右孩子的编号。如果不存在左 / 右孩子，则以 $-1$ 表示。两个数之间用一个空格隔开。

$v_i ≤ 1000$，$n ≤ 10^6$。

本题约定：

层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。

树的深度：树中节点的最大层次称为树的深度。

满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。

![https://cdn.luogu.com.cn/upload/image_hosting/8tof1fxx.png](https://cdn.luogu.com.cn/upload/image_hosting/8tof1fxx.png)

完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。

![https://cdn.luogu.com.cn/upload/image_hosting/ibo7js1f.png](https://cdn.luogu.com.cn/upload/image_hosting/ibo7js1f.png)

---

分别维护当前子树作为左子树和右子树的哈希值即可。为了防止卡哈希，我们要以不同的方式双哈希has1,has2

```C++
/*
CB Ntsc
*/

#include <bits/stdc++.h>
using namespace std;
#define int long long
#define mp make_pair

#define rd read()
inline int read() {
    int xx = 0, ff = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            ff = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}
inline void write(int out) {
    if (out < 0)
        putchar('-'), out = -out;
    if (out > 9)
        write(out / 10);
    putchar(out % 10 + '0');
}



const int N = 1e6 + 5;
const int M = 40;
const int INF = 1e9 + 5;
const int MOD = 9982353998244357;
const int MODD = 9982353998244357;
const int v1 = 998294353;
const int v2 = 998254357;
const int v3 = 988234357;


int v[N],has1l[N],has2l[N],has1r[N],has2r[N];
int sum[N],l[N],r[N];

int n,m,ans;

void pushup(int x){
	has1l[x]=(has1l[l[x]]*v1+v[x]*v2+has1l[r[x]]*v3)%MOD;
	has2l[x]=(has2l[l[x]]*v1+v[x]*v2+has2l[r[x]]*v3)%MODD;

	has1r[x]=(has1r[r[x]]*v1+v[x]*v2+has1r[l[x]]*v3)%MOD;
	has2r[x]=(has2r[r[x]]*v1+v[x]*v2+has2r[l[x]]*v3)%MODD;

}


void dfs(int x){
	if(l[x])dfs(l[x]);
	if(r[x])dfs(r[x]);
	sum[x]=sum[l[x]]+sum[r[x]]+1;
	if(sum[l[x]]==sum[r[x]]&&has1l[l[x]]==has1r[r[x]]&&has2l[l[x]]==has2r[r[x]])ans=max(ans,sum[x]);

	pushup(x);
}

signed main(){
	
	n=rd;
	for(int i=1;i<=n;i++){
		v[i]=rd;

	}
	for(int i=1;i<=n;i++){
		l[i]=rd;r[i]=rd;
		if(l[i]==-1)l[i]=0;
		if(r[i]==-1)r[i]=0;
	}
	dfs(1);

	cout<<ans<<endl;
	return 0;
}
/*
1
2 5 1 
0 0 1 
0 0 4 

*/
```

