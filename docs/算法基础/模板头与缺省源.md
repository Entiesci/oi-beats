Head | 模板头 缺省源

# 快捷模板

## ModInt

```C++

template<class T>
constexpr T ksm(T a, int b) {
    T res = 1;
    for (; b; b >>= 1, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
 
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(int x) : x{norm(x % P)} {}
    
    constexpr int norm(int x) const {
        if (x < 0) {
            x += P;
        }
        if (x >= P) {
            x -= P;
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(P - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return ksm(*this, P - 2);
    }
    constexpr MInt &operator*=(MInt rhs) {
        x = 1LL * x * rhs.x % P;
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        int v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
constexpr int MOD = 1e9 + 7;
using mint=MInt<MOD>;
```

## 组合数

```C++

int ksm(int c,int k,int p) {
//	p=MOD;
	if(!c)return 0;
	int res=1;
	while(k){
		if(k&1)res=(res*c)%p;
		c=(c*c)%p;k>>=1;
	}
	return res;
}

void comb_init(){
	fac[0]=1;
	for (int i=1;i<=n;++i) fac[i]=fac[i-1]*i%MOD;
	inv[n]=ksm(fac[n],MOD-2,MOD);
    for(int i=n;i>=1;i--)inv[i-1]=inv[i]*i%MOD;//i!的inv 
}

int inv(int x){
    return ksm(x,MOD-2,MOD);//请保证MOD为质数
} 

int C(int n,int m){
  if(n<0||m<0)return 0;
    if(n<m)return 0;
    return fac[n]*inv[m]%MOD*inv[n-m]%MOD;
}

int A(int n,int m){
    return fac[n]*inv[fac[n-m]]%MOD;
}

//求组合数请开longlong不然会越界！
```

```C++
using Z = int;
 
namespace comb {
    int n = 0;
    std::vector<Z> _fac = {1};
    std::vector<Z> _invfac = {1};
    std::vector<Z> _inv = {0};
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int m, int k) {
        if (m < k || k < 0) return 0;
        return fac(m) * invfac(k) * invfac(m - k);
    }
} // namespace comb
 
```

## 缺省源

usual template

```C++
/*
Edit by Ntsc.
*/

#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define pf first
#define ps second

#define rd read()
#define ot write
#define nl putchar('\n')
inline int rd{
	int xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') xx=xx*10+(ch-'0'),ch=getchar();
	return xx*ff;
}
inline void write(int out){
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int N=1e3+5;
const int M=5e4+5;
const int INF=2e9+5;
const int MOD=1e9+7;
const int BASE=17737;
bool f1;


bool f2;

signed main(){
    // freopen("P5431_1.in", "r", stdin);
    // freopen("chfran.out", "w", stdout);
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    
    return 0;
}
/*


*/
```

whole template

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . FancyKnowledge .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//
#include<bits/stdc++.h>

//
#define int long long
#define ull unsigned long long
#define db double
#define endl '\n'
#define enlen printf("\n")
#define err(fmt, ...) fprintf(stderr, "[%d] : " fmt "\n", __LINE__, ##__VA_ARGS__)
#define File(_) freopen(#_ ".in", "r", stdin), freopen(#_ ".out", "w", stdout)
///*

//*/

//
using namespace std;
//
const int N=1e3+5;
const int M=1e3;
const int MOD=1e9+7;
const int MMOD=903250223;
const int INF=1e9;
const int IINF=1e18;
const db eps=1e-9;
//
int n,m,a[N],b,q,s[N],op,idx,len[N],ans,res,tmp,cnt[N],id[N];
int dp[N][N];
int tot,du[N];
int L;
vector<int> e[N];

/*
//I think you won't use these...

int rd() {}
int ksm(int c,int k,int p) {}
//*/



void init(){
	//nothing to init?
	return ;
}

void solve(){
	//nothing in your main function??!
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		
	}
	printf("%lld\n",ans);
	return ;
}

signed main(){

//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
//	freopen(".txt","w",stderr);
  
//  std::ios::sync_with_stdio(false);
//  cin.tie(0); 
//  cout.tie(0);
	
	int T;
	scanf("%lld",&T);
	while(T--){
		init();
		solve();
	}
	return 0;
}

//check your long long and the size of memery!!!

```

## 代码加速

```C++
int maxx(int a,int b) {
	return a>b?a:b;
}

void swapp(int &a,int &b) {
	a^=b^=a^=b;
}

int lowbit(int n) {
	return n&(-n);
}

int Del_bit_1(int n) {
	return n&(n-1);
}

int abss(int a) {
	return a>0?a:-a;
}

double fabss(double a) {
	return a>0?a:-a;
}

int minn(int a,int b) {
	return a<b?a:b;
}

```

## 奇怪的缺省源



V_UPR_SHORT

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define ALIGNAS alignas
#define ALIGNOF alignof
#define AND and
#define AND_EQ and_eq
#define ASM asm
#define ATOMIC_CANCEL atomic_cancel
#define ATOMIC_COMMIT atomic_commit
#define ATOMIC_NOEXCEPT atomic_noexcept
#define AO auto
#define BITAND bitand
#define BITOR bitor
#define BL bool
#define BK break
#define CASE case
#define CATCH catch
#define CR char
#define CHAR8_T char8_t
#define CHAR16_T char16_t
#define CHAR32_T char32_t
#define CS class
#define COMPL compl
#define CONCEPT concept
#define CT const
#define CONSTEVAL consteval
#define CONSTEXPR constexpr
#define CONSTINIT constinit
#define CONST_CAST const_cast
#define CE continue
#define CO_AWAIT co_await
#define CO_RETURN co_return
#define CO_YIELD co_yield
#define DECLTYPE decltype
#define DEFAULT default
#define DELETE delete
#define DO do
#define DE double
#define DYNAMIC_CAST dynamic_cast
#define EE else
#define ENUM enum
#define EXPLICIT explicit
#define EXPORT export
#define EXTERN extern
#define FE false
#define FT float
#define FR for
#define FRIEND friend
#define GOTO goto
#define IF if
#define IE inline
#define IT int
#define LG long
#define LL long long
#define MUTABLE mutable
#define NE namespace
#define NEW new
#define NOEXCEPT noexcept
#define NOT not
#define NOT_EQ not_eq
#define NULLPTR nullptr
#define OPERATOR operator
#define OR or
#define OR_EQ or_eq
#define PRIVATE private
#define PROTECTED protected
#define PUBLIC public
#define REFLEXPR reflexpr
#define REGISTER register
#define REINTERPRET_CAST reinterpret_cast
#define REQUIRES requires
#define RN return
#define SHORT short
#define SD signed
#define SF sizeof
#define STATIC static
#define STATIC_ASSERT static_assert
#define STATIC_CAST static_cast
#define ST struct
#define SH switch
#define SYNCHRONIZED synchronized
#define TEMPLATE template
#define THIS this
#define THREAD_LOCAL thread_local
#define THROW throw
#define TE true
#define TRY try
#define TYPEDEF typedef
#define TYPEID typeid
#define TYPENAME typename
#define UNION union
#define UD unsigned
#define UG using
#define VIRTUAL virtual
#define VD void
#define VOLATILE volatile
#define WCHAR_T wchar_t
#define WE while
#define XOR xor
#define XOR_EQ xor_eq

#define IN(a) cin>>a
#define OT(b) cout<<b
#define EL '\n'
#define STD std
#define MN main

#define FOR(a,b,c) for(int I=a;I<=b;I+=c)

UG NE STD

SD MN(){
	
	RN 0;
}
```

V_UPR1

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define ALIGNAS alignas
#define ALIGNOF alignof
#define AND and
#define AND_EQ and_eq
#define ASM asm
#define ATOMIC_CANCEL atomic_cancel
#define ATOMIC_COMMIT atomic_commit
#define ATOMIC_NOEXCEPT atomic_noexcept
#define AUTO auto
#define BITAND bitand
#define BITOR bitor
#define BOOL bool
#define BREAK break
#define CASE case
#define CATCH catch
#define CHAR char
#define CHAR8_T char8_t
#define CHAR16_T char16_t
#define CHAR32_T char32_t
#define CLASS class
#define COMPL compl
#define CONCEPT concept
#define CONST const
#define CONSTEVAL consteval
#define CONSTEXPR constexpr
#define CONSTINIT constinit
#define CONST_CAST const_cast
#define CONTINUE continue
#define CO_AWAIT co_await
#define CO_RETURN co_return
#define CO_YIELD co_yield
#define DECLTYPE decltype
#define DEFAULT default
#define DELETE delete
#define DO do
#define DOUBLE double
#define DYNAMIC_CAST dynamic_cast
#define ELSE else
#define ENUM enum
#define EXPLICIT explicit
#define EXPORT export
#define EXTERN extern
#define FALSE false
#define FLOAT float
#define FOR for
#define FRIEND friend
#define GOTO goto
#define IF if
#define INLINE inline
#define INT int
#define LONG long
#define LL long long
#define MUTABLE mutable
#define NAMESPACE namespace
#define NEW new
#define NOEXCEPT noexcept
#define NOT not
#define NOT_EQ not_eq
#define NULLPTR nullptr
#define OPERATOR operator
#define OR or
#define OR_EQ or_eq
#define PRIVATE private
#define PROTECTED protected
#define PUBLIC public
#define REFLEXPR reflexpr
#define REGISTER register
#define REINTERPRET_CAST reinterpret_cast
#define REQUIRES requires
#define RETURN return
#define SHORT short
#define SIGNED signed
#define SIZEOF sizeof
#define STATIC static
#define STATIC_ASSERT static_assert
#define STATIC_CAST static_cast
#define STRUCT struct
#define SWITCH switch
#define SYNCHRONIZED synchronized
#define TEMPLATE template
#define THIS this
#define THREAD_LOCAL thread_local
#define THROW throw
#define TRUE true
#define TRY try
#define TYPEDEF typedef
#define TYPEID typeid
#define TYPENAME typename
#define UNION union
#define UNSIGNED unsigned
#define USING using
#define VIRTUAL virtual
#define VOID void
#define VOLATILE volatile
#define WCHAR_T wchar_t
#define WHILE while
#define XOR xor
#define XOR_EQ xor_eq

#define IN(a) cin>>a
#define OUT(b) cout<<b
#define ENDL '\n'
#define STD std
#define MAIN main

#define FOR(a,b,c) for(int I=a;I<=b;I+=c)

USING NAMESPACE STD;
SIGNED MAIN(){
	
	RETURN 0;
}
```

v4.0ClearVer.

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//头文件
#include<bits/stdc++.h>

//数据类型
#define ll long long
#define ull unsigned long long
#define db double
#define endl '\n'
//命名空间
using namespace std;
//常量
const int N=2e5+5;
const int M=1e3;
const int MOD=903250223;
const int INF=1e9;
//变量
int n,a,b,c,x[N],y[N],ans,res,tmp,cnt,web[M][M];
//int ia,ib,ic,id,ix,iy,in,im,iid,icnt,itmp,ires,ians,ians1,ians2,imx,imn,imxx,imnn;
//int ra[N],rb[N],rc[N],rcnt[N],rton[N],rant[N];
//int qzh[N],cf[N];
//int rra[M][M];
//char cop,cc,cs1[N],cs2[N],crr[M][M];

signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		//...
	}
	printf("%d\n",ans);
	return 0;
}

```

v4.0 LargeVer.

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

/*////////ACACACACACACAC///////////
题目第一眼像什么?在这里写下你的灵感.



后续有什么想法?HERE!



/*////////ACACACACACACAC///////////

/*火车头由 TLEWA 在网上搜集，整合*/

#pragma GCC target("avx")               // AVX指令集(不懂的去问度娘)
#pragma GCC optimize(1)                 // o1优化
#pragma GCC optimize(2)                 // o2优化
#pragma GCC optimize(3)                 // o3优化
#pragma GCC optimize("Ofast")           // ofast优化(优化到破坏标准合规性的点)，
#pragma GCC optimize("inline")          // inline中和
#pragma GCC optimize("-fgcse")          // fgcse优化
#pragma GCC optimize("-fgcse-lm")       //-fgcse-lm
#pragma GCC optimize("-fipa-sra")       //除换
#pragma GCC optimize("-ftree-pre")      //快速tree
#pragma GCC optimize("-ftree-vrp")      //去重tree
#pragma GCC optimize("-fpeephole2")     // flatco2优化
#pragma GCC optimize("-ffast-math")     //数论优化
#pragma GCC optimize("-fsched-spec")    //富硒优化
#pragma GCC optimize("unroll-loops")    //图论plus优化
#pragma GCC optimize("-falign-jumps")   //极优化
#pragma GCC optimize("-falign-loops")   //图论重+排除
#pragma GCC optimize("-falign-labels")  // lamb优化
#pragma GCC optimize("-fdevirtualize")  // fugechar优化
#pragma GCC optimize("-fcaller-saves")  //负优化排除
#pragma GCC optimize("-fcrossjumping")  //极优化p+
#pragma GCC optimize("-fthread-jumps")  //多重极优化
#pragma GCC optimize( \
    "-funroll-loops")  //消除分支可以减少预测的可能性能：比如小的循环可以展开比如循环次数小于64次（可以使用GCC选项
                       //-funroll-loops)
#pragma GCC optimize("-fwhole-program")    //弗洛伊德优化
#pragma GCC optimize("-freorder-blocks")   //半刻优化
#pragma GCC optimize("-fschedule-insns")   // fschedule-insns优化
#pragma GCC optimize("inline-functions")   // inline-functions优化
#pragma GCC optimize("-ftree-tail-merge")  //-ftree-tail-merge优化
#pragma GCC optimize("-fschedule-insns2")  //-fschedule-insns2优化
#pragma GCC optimize("-fstrict-aliasing")  //-fstrict-aliasing优化
#pragma GCC optimize("-fstrict-overflow")  //不知道
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
#pragma G++ target("avx")
#pragma G++ optimize(1)
#pragma G++ optimize(2)
#pragma G++ optimize(3)
#pragma G++ optimize("Ofast")
#pragma G++ optimize("inline")
#pragma G++ optimize("-fgcse")
#pragma G++ optimize("-fgcse-lm")
#pragma G++ optimize("-fipa-sra")
#pragma G++ optimize("-ftree-pre")
#pragma G++ optimize("-ftree-vrp")
#pragma G++ optimize("-fpeephole2")
#pragma G++ optimize("-ffast-math")
#pragma G++ optimize("-fsched-spec")
#pragma G++ optimize("unroll-loops")
#pragma G++ optimize("-falign-jumps")
#pragma G++ optimize("-falign-loops")
#pragma G++ optimize("-falign-labels")
#pragma G++ optimize("-fdevirtualize")
#pragma G++ optimize("-fcaller-saves")
#pragma G++ optimize("-fcrossjumping")
#pragma G++ optimize("-fthread-jumps")
#pragma G++ optimize("-funroll-loops")
#pragma G++ optimize("-fwhole-program")
#pragma G++ optimize("-freorder-blocks")
#pragma G++ optimize("-fschedule-insns")
#pragma G++ optimize("inline-functions")
#pragma G++ optimize("-ftree-tail-merge")
#pragma G++ optimize("-fschedule-insns2")
#pragma G++ optimize("-fstrict-aliasing")
#pragma G++ optimize("-fstrict-overflow")
#pragma G++ optimize("-falign-functions")
#pragma G++ optimize("-fcse-skip-blocks")
#pragma G++ optimize("-fcse-follow-jumps")
#pragma G++ optimize("-fsched-interblock")
#pragma G++ optimize("-fpartial-inlining")
#pragma G++ optimize("no-stack-protector")
#pragma G++ optimize("-freorder-functions")
#pragma G++ optimize("-findirect-inlining")
#pragma G++ optimize("-frerun-cse-after-loop")
#pragma G++ optimize("inline-small-functions")
#pragma G++ optimize("-finline-small-functions")
#pragma G++ optimize("-ftree-switch-conversion")
#pragma G++ optimize("-foptimize-sibling-calls")
#pragma G++ optimize("-fexpensive-optimizations")
#pragma G++ optimize("-funsafe-loop-optimizations")
#pragma G++ optimize("inline-functions-called-once")
#pragma G++ optimize("-fdelete-null-pointer-checks")
#pragma G++ optimize("-fstrict-overflow")  //不知道
#pragma G++ optimize("-falign-functions")
#pragma G++ optimize("-fcse-skip-blocks")
#pragma G++ optimize("-fcse-follow-jumps")
#pragma G++ optimize("-fsched-interblock")
#pragma G++ optimize("-fpartial-inlining")
#pragma G++ optimize("no-stack-protector")
#pragma G++ optimize("-freorder-functions")
#pragma G++ optimize("-findirect-inlining")
#pragma G++ optimize("-fhoist-adjacent-loads")
#pragma G++ optimize("-frerun-cse-after-loop")
#pragma G++ optimize("inline-small-functions")
#pragma G++ optimize("-finline-small-functions")
#pragma G++ optimize("-ftree-switch-conversion")
#pragma G++ optimize("-foptimize-sibling-calls")
#pragma G++ optimize("-fexpensive-optimizations")
#pragma G++ optimize("-funsafe-loop-optimizations")
#pragma G++ optimize("inline-functions-called-once")
#pragma G++ optimize("-fdelete-null-pointer-checks")


//头文件
//#include<bits/stdc++.h>
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cassert>
#include <vector>
#include <bitset>
#include <queue>
#include <cmath>
#include <set>
#include <map>



//FromXzc
// g++.exe -std=c++20 -O2 -lm -Wall -Wl,--stack=8888888888 -DLOCAL -DLWAVE
// The moon shines, thank the moon!
//#pragma GCC optimize("Ofast", "inline")
//#define keyword_type
//#define algo_type
//#define fast_io
//#define memory_watch
#include <bits/stdc++.h>
#define Rep(i, n) for (int i = 0, i##__END__ = (int)(n); i < i##__END__; i++)
#define Rpp(i, n) for (int i = 1, i##__END__ = (int)(n); i <= i##__END__; i++)
#define Dpp(i, n) for (int i = (int)(n); i; i--)
#define Frr(i, s, e) for (int i = (int)(s), i##__END__ = (int)(e); i <= i##__END__; i++)
#define Eps 1e-9
#define Pinf 0x3f3f3f3f3f3f3f3fll
#define Ninf (long long)0xcfcfcfcfcfcfcfcfll
#define Mem0(Cont) memset(Cont, 0, sizeof(Cont))
#define MemP(Cont) memset(Cont, 0x3f, sizeof(Cont))
#define MemN(Cont) memset(Cont, 0xcf, sizeof(Cont))
#define MemU(Cont) memset(Cont, 0xff, sizeof(Cont))
#define endl '\n'
#define int long long

// STL macros
#define pjj pair<int, int>
#define ff first
#define ss second
#define pb push_back
#define vj vector<int>
#define vpj vector<pjj>
#define gtj greater<int>
#define ltj less<int>
#define pqjmx priority_queue<int>
#define pqjmn priority_queue<int, vector<int>, greater<int>>

// STL container macros
#define all(a) a.begin(), a.end()
#define all0(a, n) a, a + (n)
#define all1(a, n) a + 1, a + (n) + 1
#define sz(a) ((int)a.size())

// Debug macros
#ifdef LOCAL
#define edebug() cout << "Error message sent at line #" << __LINE__ << ".\n", exit(19);
#define pdebug() cout << "PDebug at line " << __LINE__ << " in function " << __FUNCTION__ << endl << flush
#define vdebug(x) \
    cout << "VDebug at line " << __LINE__ << ", the value is [" << #x << "] = " << (x) << endl << flush
#define mdebug(args...)                                                                                \
    cout << "MDebug at line " << __LINE__ << ", the values are [" << #args << "] = ", con_print(args), \
        cout << flush
#define ldebug(msg, args...)                                                                                 \
    cout << "LDebug at line " << __LINE__ << ", with message [" << msg << "], and the values are [" << #args \
         << "] = ",                                                                                          \
        con_print(args), cout << flush
#else
#define edebug(...) 42
#define pdebug(...) 42
#define vdebug(...) 42
#define mdebug(...) 42
#define ldebug(...) 42
#endif

// More convenient keywords (USED ONLY WHEN ALLOWED)
#ifdef keyword_type
#define re return
#define con continue
#define brk break
#define cst const
#define cstex constexpr
#define au auto
#define il inline
#endif

// More convenient algos (USED ONLY WHEN ALLOWED)
#ifdef algo_type
#define mx1 max_element
#define mn1 min_element
#define nth nth_element
#define sumv accumulate
#define lwb lower_bound
#define upb upper_bound
#define uni unique
#define nxtprm next_permutation
#define prvprm prev_permutation
#define rev reverse
#endif

//End##FromXzc

//数据类型
#define ll long long
#define ull unsigned long long
#define uint unsigned int
#define db double
#define str string
//函数
#define rtn return
#define i1n int i=1;i<=n;i++
#define in1 int i=n;i>=1;i--
#define endl '\n'
//命名空间
using namespace std;
//常量
const int N=2e5+5;
const int M=1e3;
const int MOD=903250223;
const int INF=1e12;
//空间复杂度
bool memBeg;
//STL
vector<int> v;
stack <int> s;
queue<int> q;
priority_queue<int> pq;
map<int,int> mp;
set<int> st;
//结构体
struct node{int v,id;}e[N];
bool cmp(node a,node b){return a.v<b.v;}
//变量
int n,m,_a[N],_b[N],ans,res,tmp,l,r,x,y,x_[N],y_[N],a__[M][M],b__[M][M];
char c,str[N];
bool flg;
db db_a,db_b;

//空间复杂度计算
bool memEn;
//快读
int readint() {char c = getchar();int neg = 1, ret = 0;for (; c < '0' || c > '9'; c = getchar())if (c == '-')neg = -1;for (; '0' <= c && c <= '9'; c = getchar()) ret = (ret << 3) + (ret << 1) + (c & 15);return neg * ret;}
ll readll() {char c = getchar();ll neg = 1, ret = 0;for (; c < '0' || c > '9'; c = getchar())if (c == '-')neg = -1;for (; '0' <= c && c <= '9'; c = getchar()) ret = (ret << 3) + (ret << 1) + (c & 15);return neg * ret;}
void writeint(int x) {if (x == 0) {putchar('0');return;}if (x < 0) {putchar('-');x = -x;}char stk[15];int top = 0;while (x) {int nxt = x / 10;stk[++top] = x - nxt * 10 + '0';x = nxt;}for (int i = top; i >= 1; i--) putchar(stk[i]);}
void writell(ll x) {if (x == 0) {putchar('0');return;}if (x < 0) {putchar('-');x = -x;}char stk[25];int top = 0;while (x) {ll nxt = x / 10;stk[++top] = x - nxt * 10 + '0';x = nxt;}for (int i = top; i >= 1; i--) putchar(stk[i]);}
void Writeint(int x, char c) {writeint(x);putchar(c);}
void Writell(ll x, char c) {writell(x);putchar(c);}

signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		//...
	}
	printf("%d\n",ans);
	return 0;
}


/*
 *	things to check
 *	1.  int overflow or long long memory need
 *	2.  recursion/array/binary search/dp/loop bounds
 *	3.  precision
 *	4.  special cases(n=1,bounds)
 *	5.  delete debug statements
 *	6.  initialize(especially multi-tests)
 *	7.  = or == , n or m ,++ or -- , i or j , > or >= , < or <=
 *	8.  keep it simple and stupid
 *	9.  do not delete, use // instead
 *	10. operator priority
 *	11. is there anything extra to output?
 *	12. THINK TWICE CODE ONCE, THINK ONCE DEBUG FOREVER
 *	13. submit ONCE, AC once. submit twice, WA forever
 *	14. calm down and you'll get good rank
 *	15. even a bit wrong scores zero
 *	16. ...
 **/

/*
 *	something to think about
 *	1. greedy? dp? searching? dp with matrix/ segment tree? binary search? ...?
 *	2. If it is difficult, why not the opposite?
 **/
```

感谢xzc提供以下（仅包括接下来的1个代码块）

```C++
// g++.exe -std=c++20 -O2 -lm -Wall -Wl,--stack=8888888888 -DLOCAL -DLWAVE
// The moon shines, thank the moon!
//#pragma GCC optimize("Ofast", "inline")
//#define keyword_type
//#define algo_type
//#define fast_io
//#define memory_watch
#include <bits/stdc++.h>
#define Rep(i, n) for (int i = 0, i##__END__ = (int)(n); i < i##__END__; i++)
#define Rpp(i, n) for (int i = 1, i##__END__ = (int)(n); i <= i##__END__; i++)
#define Dpp(i, n) for (int i = (int)(n); i; i--)
#define Frr(i, s, e) for (int i = (int)(s), i##__END__ = (int)(e); i <= i##__END__; i++)
#define Eps 1e-9
#define Pinf 0x3f3f3f3f3f3f3f3fll
#define Ninf (long long)0xcfcfcfcfcfcfcfcfll
#define Mem0(Cont) memset(Cont, 0, sizeof(Cont))
#define MemP(Cont) memset(Cont, 0x3f, sizeof(Cont))
#define MemN(Cont) memset(Cont, 0xcf, sizeof(Cont))
#define MemU(Cont) memset(Cont, 0xff, sizeof(Cont))
#define endl '\n'
#define int long long

// STL macros
#define pjj pair<int, int>
#define ff first
#define ss second
#define pb push_back
#define vj vector<int>
#define vpj vector<pjj>
#define gtj greater<int>
#define ltj less<int>
#define pqjmx priority_queue<int>
#define pqjmn priority_queue<int, vector<int>, greater<int>>

// STL container macros
#define all(a) a.begin(), a.end()
#define all0(a, n) a, a + (n)
#define all1(a, n) a + 1, a + (n) + 1
#define sz(a) ((int)a.size())

// Debug macros
#ifdef LOCAL
#define edebug() cout << "Error message sent at line #" << __LINE__ << ".\n", exit(19);
#define pdebug() cout << "PDebug at line " << __LINE__ << " in function " << __FUNCTION__ << endl << flush
#define vdebug(x) \
    cout << "VDebug at line " << __LINE__ << ", the value is [" << #x << "] = " << (x) << endl << flush
#define mdebug(args...)                                                                                \
    cout << "MDebug at line " << __LINE__ << ", the values are [" << #args << "] = ", con_print(args), \
        cout << flush
#define ldebug(msg, args...)                                                                                 \
    cout << "LDebug at line " << __LINE__ << ", with message [" << msg << "], and the values are [" << #args \
         << "] = ",                                                                                          \
        con_print(args), cout << flush
#else
#define edebug(...) 42
#define pdebug(...) 42
#define vdebug(...) 42
#define mdebug(...) 42
#define ldebug(...) 42
#endif

// More convenient keywords (USED ONLY WHEN ALLOWED)
#ifdef keyword_type
#define re return
#define con continue
#define brk break
#define cst const
#define cstex constexpr
#define au auto
#define il inline
#endif

// More convenient algos (USED ONLY WHEN ALLOWED)
#ifdef algo_type
#define mx1 max_element
#define mn1 min_element
#define nth nth_element
#define sumv accumulate
#define lwb lower_bound
#define upb upper_bound
#define uni unique
#define nxtprm next_permutation
#define prvprm prev_permutation
#define rev reverse
#endif
using namespace std;

// Super fast io (USED ONLY WHEN ALLOWED)
#ifdef fast_io
namespace Fast {
constexpr int B = 1 << 24;
int len = 0;
char ibuf[B + 5], *iS, *iT, out[B + 5];
#define gh() \
    (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
inline int read() {
    char ch = gh();
    int x = 0;
    char t = 0;
    while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
    while (ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch = gh();
    return t ? -x : x;
}
inline void reflush() {
    fwrite(out, 1, len, stdout);
    len = 0;
}
inline void putc(char ch) {
    out[len++] = ch;
    if (len > B)
        reflush();
}
template <class T>
inline void write(T x) {
    if (x < 0)
        putc('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putc((x % 10) ^ '0');
}
template <class T>
inline void writeln(T x) {
    write(x);
    putc('\n');
}

}  // namespace Fast
#endif

// Main code
namespace Solution {

struct STATUS {
    const string s, t;
    STATUS(string a, string b) : s(a), t(b) {}
    inline void check(bool p) const { cout << (p ? s : t) << endl; }
};
const STATUS nYesNo("Yes", "No");
const STATUS nYESNO("YES", "NO");
const STATUS nyesno("yes", "no");
const STATUS nAliceBob("Alice", "Bob");
const STATUS nTAKNIE("TAK", "NIE");
const STATUS nOKNG("OK", "NG");
const STATUS nokng("ok", "ng");

constexpr int dX[] = { 1, -1, 0, 0 }, dY[] = { 0, 0, 1, -1 };

template <typename T>
inline void die(T x, int cd = 0) {
    cout << x << endl;
    exit(cd);
}
template <typename T>
inline bool check_max(T& x, T y) {
    return (x < y) ? ((x = y), 1) : 0;
}
template <typename T>
inline bool check_min(T& x, T y) {
    return (y < x) ? ((x = y), 1) : 0;
}
template <typename T>
inline bool swap_max(T& x, T y) {
    return (x < y) ? ((swap(x, y)), 1) : 0;
}
template <typename T>
inline bool swap_min(T& x, T y) {
    return (y < x) ? ((swap(x, y)), 1) : 0;
}
inline void con_read() {}
template <typename T, typename... U>
void con_read(T& x, U&... y) {
    cin >> x;
    con_read(y...);
}
inline void con_print() { cout << endl; }
template <typename T, typename... U>
void con_print(const T& x, const U&... y) {
    cout << x << ' ';
    con_print(y...);
}
template <typename T>
inline void acc_print(const T& x, int pr) {
    cout << fixed << setprecision(pr) << x << endl;
}
template <typename IT, typename T>
void discrete(IT bg, IT ed, IT nw, T dt) {
    IT u = nw;
    for (IT k = bg; k != ed; k++, u++) *u = *k;
    sort(nw, u);
    u = unique(nw, u);
    for (IT k = bg; k != ed; k++) {
        *k = lower_bound(nw, u, *k) - nw + dt;
    }
}
inline int qpow(int x, int y, int z) {
    int res = 1 % z;
    for (; y; y >>= 1, (x *= x) %= z)
        if (y & 1)
            (res *= x) %= z;
    return res;
}
inline int upow(int x) { return (x & 1) ? -1 : 1; }
inline int lowbit(int x) { return x & -x; }
inline int next_set(int x) { return x & (x - 1); }
inline int mid(int L, int R) { return (L + R) >> 1; }
inline void file_in(string fname) { freopen((fname + ".in").c_str(), "r", stdin); }
inline void file_out(string fname) { freopen((fname + ".out").c_str(), "w", stdout); }
inline void file(string fname) {
    file_in(fname);
    file_out(fname);
}

#ifdef fast_io
using Fast::putc;
using Fast::read;
using Fast::reflush;
using Fast::write;
using Fast::writeln;
#endif

bool st;

// Variables here.

bool ed;

void Initialize() {
    // You can initialize your variables/sturctures here. It is put before cases.
}

void Main(int TEST_NUM) {
    // Don't forget to clear when multi test cases.
    
}

}  // namespace Solution

signed main() {
    // Solution::file("");
#ifndef fast_io
    ios_base ::sync_with_stdio(0), cin.tie(0), cout.tie(0);
#endif
#ifdef LOCAL
// Memory monitor (USED ONLY WHEN ALLOWED)
#ifdef memory_watch
    cerr << "MEMORY USED = " << fixed << setprecision(2)
         << (&Solution::st - &Solution::ed) / 1048576.0
#ifdef fast_io
                + 32  // Fast io
#endif
         << " MiB.\n"
         << flush;
#endif
#endif
    Solution::Initialize();
    int test_cases = 1;
    // cin >> test_cases;
    for (int iv = 1; iv <= test_cases; iv++) Solution::Main(iv);

#ifdef fast_io
    Fast::reflush();
#endif

    return 0;
}

/*
 *	things to check
 *	1.  int overflow or long long memory need
 *	2.  recursion/array/binary search/dp/loop bounds
 *	3.  precision
 *	4.  special cases(n=1,bounds)
 *	5.  delete debug statements
 *	6.  initialize(especially multi-tests)
 *	7.  = or == , n or m ,++ or -- , i or j , > or >= , < or <=
 *	8.  keep it simple and stupid
 *	9.  do not delete, use // instead
 *	10. operator priority
 *	11. is there anything extra to output?
 *	12. THINK TWICE CODE ONCE, THINK ONCE DEBUG FOREVER
 *	13. submit ONCE, AC once. submit twice, WA forever
 *	14. calm down and you'll get good rank
 *	15. even a bit wrong scores zero
 *	16. ...
 **/

/*
 *	something to think about
 *	1. greedy? dp? searching? dp with matrix/ segment tree? binary search? ...?
 *	2. If it is difficult, why not the opposite?
 **/
```

v3.1

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//头文件
//#include<bits/stdc++.h>
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cassert>
#include <vector>
#include <bitset>
#include <queue>
#include <cmath>
#include <set>
#include <map>
//数据类型
#define ll long long
#define ull unsigned long long
#definr uint unsigned int
#define db double
#define str string
//函数
#define rtn return
#define i1n int i=1;i<=n;i++
#define in1 int i=n;i>=1;i--
#define endl '\n'
//命名空间
using namespace std;
//常量
const int N=2e5+5;
const int M=1e5;
const int MOD=903250223;
const int INF=1e12;
//空间复杂度
bool memBeg;
//STL
vector<int> v;
stack <int> s;
queue<int> q;
priority_queue<int> pq;
map<int,int> mp;
set<int> st;
//结构体
struct node{int v,id;}e[N];
bool cmp(node a,node b){return a.v<b.v;}
//变量
int n,m,_a[N],_b[N],ans,res,tmp,l,r,x,y,x_[N],y_[N],a__[N][N],b__[N][N];
char c,s[N];
bool flg;
db db_a,db_b;

//空间复杂度计算
bool memEn;
//快读
int readint() {char c = getchar();int neg = 1, ret = 0;for (; c < '0' || c > '9'; c = getchar())if (c == '-')neg = -1;for (; '0' <= c && c <= '9'; c = getchar()) ret = (ret << 3) + (ret << 1) + (c & 15);return neg * ret;}
ll readll() {char c = getchar();ll neg = 1, ret = 0;for (; c < '0' || c > '9'; c = getchar())if (c == '-')neg = -1;for (; '0' <= c && c <= '9'; c = getchar()) ret = (ret << 3) + (ret << 1) + (c & 15);return neg * ret;}
void writeint(int x) {if (x == 0) {putchar('0');return;}if (x < 0) {putchar('-');x = -x;}char stk[15];int top = 0;while (x) {int nxt = x / 10;stk[++top] = x - nxt * 10 + '0';x = nxt;}for (int i = top; i >= 1; i--) putchar(stk[i]);}
void writell(ll x) {if (x == 0) {putchar('0');return;}if (x < 0) {putchar('-');x = -x;}char stk[25];int top = 0;while (x) {ll nxt = x / 10;stk[++top] = x - nxt * 10 + '0';x = nxt;}for (int i = top; i >= 1; i--) putchar(stk[i]);}
void Writeint(int x, char c) {writeint(x);putchar(c);}
void Writell(ll x, char c) {writell(x);putchar(c);}

signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		//...
	}
	printf("%d\n",ans);
	return 0;
}

```

v3.0

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//头文件
//#include<bits/stdc++.h>
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cassert>
#include <vector>
#include <bitset>
#include <queue>
#include <cmath>
#include <set>
#include <map>
//数据类型
#define ll long long
#define ull unsigned long long
#definr uint unsigned int
#define db double
#define str string
//函数
#define rtn return
#define i1n int i=1;i<=n;i++
#define in1 int i=n;i>=1;i--
#define endl '\n'
//命名空间
using namespace std;
//常量
const int N=2e5+5;
const int M=1e5;
const int MOD=903250223;
const int INF=1e12;
//空间复杂度
bool memBeg;
//STL
vector<int> v;
stack <int> s;
queue<int> q;
priority_queue<int> pq;
map<int,int> mp;
set<int> st;
//结构体
struct node{
	int v,id;
}e[N];

bool cmp(node a,node b){
    return a.v<b.v; 
}
//变量
int n,m,_a[N],_b[N],ans,res,tmp,l,r,x,y,x_[N],y_[N],a__[N][N],b__[N][N];
char c,s[N];
bool flg;
db db_a,db_b;

//空间复杂度计算
bool memEn;
//快读
int readint() {
    char c = getchar();
    int neg = 1, ret = 0;
    for (; c < '0' || c > '9'; c = getchar())
        if (c == '-')
            neg = -1;
    for (; '0' <= c && c <= '9'; c = getchar()) ret = (ret << 3) + (ret << 1) + (c & 15);
    return neg * ret;
}
ll readll() {
    char c = getchar();
    ll neg = 1, ret = 0;
    for (; c < '0' || c > '9'; c = getchar())
        if (c == '-')
            neg = -1;
    for (; '0' <= c && c <= '9'; c = getchar()) ret = (ret << 3) + (ret << 1) + (c & 15);
    return neg * ret;
}
void writeint(int x) {
    if (x == 0) {
        putchar('0');
        return;
    }
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    char stk[15];
    int top = 0;
    while (x) {
        int nxt = x / 10;
        stk[++top] = x - nxt * 10 + '0';
        x = nxt;
    }
    for (int i = top; i >= 1; i--) putchar(stk[i]);
}
void writell(ll x) {
    if (x == 0) {
        putchar('0');
        return;
    }
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    char stk[25];
    int top = 0;
    while (x) {
        ll nxt = x / 10;
        stk[++top] = x - nxt * 10 + '0';
        x = nxt;
    }
    for (int i = top; i >= 1; i--) putchar(stk[i]);
}
void Writeint(int x, char c) {
    writeint(x);
    putchar(c);
}
void Writell(ll x, char c) {
    writell(x);
    putchar(c);
}

signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		//...
	}
	cout<<ans<<endl;
	return 0;
}

```

v2.2

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//头文件
#include<bits/stdc++.h>
//数据类型
#define ll long long
#define ull unsigned long long
#definr uint unsigned int
#define db double
#define str string
//函数
#define rtn return
#define i1n int i=1;i<=n;i++
#define in1 int i=n;i>=1;i--
#define endl '\n'
//命名空间
using namespace std;
//常量
const int N=2e5+5;
const int M=1e5;
const int MOD=903250223;
const int INF=1e12;
//STL
vector<int> v;
stack <int> s;
queue<int> q;
priority_queue<int> pq;
map<int,int> mp;
set<int> st;
//结构体
struct node{
	int v,id;
}e[N];

bool cmp(node a,node b){
    return a.v<b.v; 
}
//变量
int n,m,_a[N],_b[N],ans,res,tmp,l,r,x,y,x_[N],y_[N],a__[N][N],b__[N][N];
char c,s[N];
bool flg;
db db_a,db_b;

signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		//...
	}
	cout<<ans<<endl;
	return 0;
}

```

v2.1

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define ll long long
#define db double
#define rtn return
#define i1n int i=1;i<=n;i++
#define in1 int i=n;i>=1;i--
using namespace std;

const int N=2e5+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

signed main(){
	
	return 0;
}
```

v2.0

```C++
/*////////ACACACACACACAC///////////
       . Code by Ntsc .
       . Love by Liye .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define ll long long
#define db double
#define rtn return
#define i1n int i=1;i<=n;i++
#define in1 int i=n;i>=1;i--
using namespace std;

const int N=2e5+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

```

v1.0

```C++
/*////////ACACACACACACAC///////////
Code By Ntsc
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h> 
using namespace std;
#define ll long long
const int N=1e5;


ll n,m,ver[N],ans,low[N],dfn[N];
void add(int x,int y){
	to[++cnt]=y,nxt[cnt]=h[x],h[a]=cnt;
}
signed main(){
	
	return 0;
}
```



