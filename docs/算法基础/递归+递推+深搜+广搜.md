专题 | 递归&递推&深搜&广搜

# 目录

- 递归

- 递推

- 深搜

- 广搜

# 汉诺塔问题

1205

## 【题目描述】

约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到中间的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。

这是一个著名的问题，几乎所有的教材上都有这个问题。由于条件是一次只能移动一个盘，且不允许大盘放在小盘上面，所以64个盘的移动次数是：18,446,744,073,709,551,615

这是一个天文数字，若每一微秒可能计算(并不输出)一次移动，那么也需要几乎一百万年。我们仅能找出问题的解决方法并解决较小N值时的汉诺塔，但很难用计算机解决64层的汉诺塔。

假定圆盘从小到大编号为1, 2, ...

## 【输入】

输入为一个整数(小于20）后面跟三个单字符字符串。

整数为盘子的数目，后三个字符表示三个杆子的编号。

## 【输出】

输出每一步移动盘子的记录。一次移动一行。

每次移动的记录为例如 a->3->b 的形式，即把编号为3的盘子从a杆移至b杆。

## 【输入样例】

```Plain Text
2 a b c
```

## 【输出样例】

```Plain Text
a->1->c
a->2->b
c->1->b
```

## 代码

```C++

```

# 深搜&八皇后

## 题目描述

一个如下的 $6 \times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。

![60.png](递归+递推+深搜+广搜+4958e8bb-4813-40b2-b3b1-5eae36f3a6b9/60.png)

上面的布局可以用序列 $2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：

行号 $1\ 2\ 3\ 4\ 5\ 6$

列号 $2\ 4\ 6\ 1\ 3\ 5$

这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。
并把它们以上面的序列方法输出，解按字典顺序排列。
请输出前 $3$ 个解。最后一行是解的总个数。

## 输入格式

一行一个正整数 $n$，表示棋盘是 $n \times n$ 大小的。

## 输出格式

前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。

## 样例 #1

### 样例输入 #1

```Plain Text
6
```

### 样例输出 #1

```Plain Text
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
```

## 提示

【数据范围】
对于 $100\%$ 的数据，$6 \le n \le 13$。

题目翻译来自NOCOW。

USACO Training Section 1.5

## 思路

**深搜递归**

对于一条从右上到左下的对角线，其上的棋子坐标应满足`x+y`为一**定值**；

对于一条从左上到右下的对角线，其上的棋子坐标应满足`x-y`为一**定值**，为了避免**负数**的产生，代码中用`x-y+n`来储存数字，具体效果读者可以自行研究。

因此,我们就可以做到使用数组快速存储与判定`对角线/行/列`是否存在别的皇后
因为我们是**逐行搜索递归**的,不需要存储该行是否有别的皇后

`chk[0]`储存了棋子的列数，每一次进行`ans[l]=i`，使`chk[0][i]`标记为已使用；

`chk[1]`和`chk[2]`储存对角线上的棋子分布情况：

## 代码

```C++
#include<bits/stdc++.h>

using namespace std;
int ans[14],chk[3][28],cnt,n;
void go(int l){
	if(l>n){	//找到了一种满足条件的八皇后排列!
		cnt++;
		if(cnt<=3){	//特判是第几个,输出
			for(int i=1;i<=n;i++)cout<<ans[i]<<' ';
			cout<<endl;
		}
		return;
	}
	for(int i=1;i<=n;i++){
		if(!(chk[0][i])&&!(chk[1][l+i])&&!(chk[2][l-i+n])){	//在该行找到了一个可以放置皇后的地方,向下递归
			chk[0][i]=1;chk[1][l+i]=1;chk[2][l-i+n]=1;
			ans[l]=i;
			go(l+1);
			chk[0][i]=chk[1][l+i]=chk[2][l-i+n]=0;
		}
		//如果该行没有找到任何一个可以放到地方,则无功而返!
	}
	
}
int main() {
	cin>>n;
	go(1);
	cout<<cnt;
	return 0;
}
```

摆脱传统思想!接受递归思想!

# 递推&矩形

## 题目描述

给出一个 $n \times n$ 的矩阵，矩阵中，有些格子被染成白色，有些格子被染成黑色，现要求矩阵中白色**矩形**的数量。

## 输入格式

第一行，一个整数 $n$，表示矩形的大小。

接下来 $n$ 行，每行 $n$ 个字符，这些字符为 $\verb!W!$ 或 $\verb!B!$。其中 $\verb!W!$ 表示白格，$\verb!B!$ 表示黑格。

## 输出格式

一个正整数，为白色矩形数量。

## 样例 #1

### 样例输入 #1

```Plain Text
4
WWBW
BBWB
WBWW
WBWB
```

### 样例输出 #1

```Plain Text
15
```

## 提示

对于$30\%$的数据，$n ≤ 50$；

对于$100\%$的数据，$n ≤ 150$；

# 广搜&走迷宫

注意，P1238 是dfs而不是bfs哦，不要看到走迷宫就以为是bfs

【题目描述】

当你站在一个迷宫里的时候，往往会被错综复杂的道路弄得失去方向感，如果你能得到迷宫地图，事情就会变得非常简单。

假设你已经得到了一个n×m的迷宫的图纸，请你找出从起点到出口的最短路。

【输入】

第一行是两个整数n和m(1≤n,m≤100)，表示迷宫的行数和列数。

接下来n行，每行一个长为m的字符串，表示整个迷宫的布局。字符`.`表示空地，`#`表示墙，`S`表示起点，`T`表示出口。

【输出】

输出从起点到出口最少需要走的步数。

【输入样例】

```C++
3 3
S#T
.#.
...
```

**代码**

```C++

#include<bits/stdc++.h>
using namespace std;
const int N=105;

struct node{
	int x,y;
};
queue<node>q;

int a[N][N], n, m, ans, d[N][N],vis[N][N];
int fromx, fromy, ansx, ansy;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};


void bfs() {
	d[fromx][fromy] = 0;
	vis[fromx][fromy] = 1;
	q.push((node){fromx, fromy});
	while (q.size()) {
		node u = q.front();
		q.pop();
		
		if(u.x==ansx&&u.y==ansy){
			cout << d[ansx][ansy] << endl;
			return ;
		}

		for (int k = 0; k < 4; k++) {
			int xx = u.x + dx[k], yy = u.y + dy[k];
          
			if (xx < 1 || xx > n || yy < 1 || yy > m || vis[xx][yy])continue;
			if(!a[xx][yy])continue;
          
			q.push((node){xx,yy});
			d[xx][yy] = d[u.x][u.y] + 1;
			vis[xx][yy]=1;
		}
	}

}

int main() {
	cin >> n >> m;

	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			char c;
			cin >> c;
			if (c == 'S')fromx = i, fromy = j;
			if (c == 'T')ansx = i, ansy = j;
			if (c == '.' || c == 'S' || c == 'T')a[i][j] = 1;
		}
	bfs();
	return 0;
}
```

## 部分区域限制通过的bfs

[www.luogu.com.cn](https://www.luogu.com.cn/problem/P5195)


## 通过时间不同的bfs（差时bfs）

[练习 | 车万（东方）的题](https://flowus.cn/1b45e393-14ef-49bf-b25d-c1d9b03314a0)



# 搜索优化

## 迭代加深

[226 迭代加深 Addition Chains_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1UW4y1S7Te/?spm_id_from=333.999.0.0&vd_source=f45ea4e1e4b3b73d5f07c57b46c43aba)

![image.png](递归+递推+深搜+广搜+4958e8bb-4813-40b2-b3b1-5eae36f3a6b9/image.png)

核心代码

```C++
    int dep=1;
	while(!dfs(1))d++;//一直d++找到找到答案 
	...
```

例题

Addition Chains

**题目描述**

一个与 $n$ 有关的整数加成序列 $<a_0,a_1,a_2,...,a_m>$ 满足以下四个条件：
$1.a_0=1
$$2.a_m=n
$$3.a_0<a_1<a_2<...<a_{m-1}<a_m
$$4.$ 对于每一个 $k(1≤k≤m)$ 都存在有两个整数 $i$ 和 $j(0≤i,j≤k-1,i$ 和 $j$ 可以相等 $)$ ，使得 $a_k=a_i+a_j
$你的任务是：给定一个整数 $n$ ,找出符合上述四个条件的长度最小的整数加成序列。如果有多个满足要求的答案，只需要输出任意一个解即可。
举个例子，序列 $<1,2,3,5>$ 和 $<1,2,4,5>$ 均为 $n=5$ 时的解。

**输入格式**

输入包含多组数据。每组数据仅一行包含一个整数 $n(1≤n≤10000)$ 。在最后一组数据之后是一个 $0$ 。

**输出格式**

对于每组数据，输出一行所求的整数加成序列，每个整数之间以空格隔开。

感谢@Iowa_BattleShip 提供的翻译

**样例 #1**

### 样例输入 #1

```C++
5
7
12
15
77
0
```

### 样例输出 #1

```C++
1 2 4 5
1 2 4 6 7
1 2 4 8 12
1 2 4 5 10 15
1 2 4 8 9 17 34 68 77
```

![image.png](递归+递推+深搜+广搜+4958e8bb-4813-40b2-b3b1-5eae36f3a6b9/image 1.png)

**代码**

```C++

```

## 剪枝

想必不需要多说了，懂的都懂

#include<bits/stdc++.h>
using namespace std;
const int N=105;

struct node{
int x,y;
};
queue<node>q;

int a[N][N], n, m, ans, d[N][N],vis[N][N];
int fromx, fromy, ansx, ansy;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void bfs() {
d[fromx][fromy] = 0;
vis[fromx][fromy] = 1;
q.push((node){fromx, fromy});
while (q.size()) {
node u = q.front();
q.pop();

```C++
	if(u.x==ansx&&u.y==ansy){
		cout << d[ansx][ansy] << endl;
		return ;
	}

	for (int i = 0; i < 4; i++) {
		int xx = u.x + dx[i], yy = u.y + dy[i];
		if (xx < 1 || xx > n || yy < 1 || yy > m || vis[xx][yy])continue;
		if(!a[xx][yy])continue;
		q.push((node){xx,yy});
		d[xx][yy] = d[u.x][u.y] + 1;
		vis[xx][yy]=1;
	}
}
```

}

int main() {

```C++
cin >> n >> m;

for (int i = 1; i <= n; i++)
	for (int j = 1; j <= m; j++) {
		char c;
		cin >> c;
		if (c == 'S')
			fromx = i, fromy = j;
		if (c == 'T')
			ansx = i, ansy = j;
		if (c == '.' || c == 'S' || c == 'T')
			a[i][j] = 1;
	}
bfs();
return 0;
```

}

## 折半搜索

折半搜索可以让我们用$O(2n^{\frac{k}{2}})$完成O(n^k)的搜索。

具体实现看图

![https://i.loli.net/2018/10/21/5bcc80e9bf36f.png](https://i.loli.net/2018/10/21/5bcc80e9bf36f.png)

[CEOI2015 Day2] 世界冰球锦标赛

题目描述

**译自 [CEOI2015](https://ceoi2015.fi.muni.cz/tasks.php) Day2 T1「[Ice Hockey World Championship](https://ceoi2015.fi.muni.cz/day2/eng/day2task1-eng.pdf)」**

> 今年的世界冰球锦标赛在捷克举行。Bobek 已经抵达布拉格，他不是任何团队的粉丝，也没有时间观念。他只是单纯的想去看几场比赛。如果他有足够的钱，他会去看所有的比赛。不幸的是，他的财产十分有限，他决定把所有财产都用来买门票。

给出 Bobek 的预算和每场比赛的票价，试求：如果总票价不超过预算，他有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。

输入格式

第一行，两个正整数 $N$ 和 $M(1 \leq N \leq 40,1 \leq M \leq 10^{18})$，表示比赛的个数和 Bobek 那家徒四壁的财产。

第二行，$N$ 个以空格分隔的正整数，均不超过 $10^{16}$，代表每场比赛门票的价格。

输出格式

输出一行，表示方案的个数。由于 $N$ 十分大，注意：答案 $\le 2^{40}$。

我们发现如果这里使用普通搜索的话时间复杂度是O(2^n)的，过不去。但是如果使用折半搜索，那么就可以变成$O(2\times 2^{n/2})$，可以过去了。



