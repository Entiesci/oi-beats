```C++
/*
CB Ntsc111
*/

#include<bits/stdc++.h>
using namespace std;
// #define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define pf first
#define ps second

#define err cerr<<"Error"
#define rd read()
// #define nl putc('\n')
#define ot write
#define nl putchar('\n')
inline int rd
{
	int xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') xx=xx*10+(ch-'0'),ch=getchar();
	return xx*ff;
}
inline void write(int out)
{
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int INF = 1e9;
const int N = 3e3+5;
const int M = 1e6+5;
const int S=1e6+5;
const int maxlog = 10;

int v,p,pos[N],dp[N][N],w[N][N],d[N][N];

void init() {
	for(int l=1;l<=v;l++) {
		w[l][l]=0;
		for(int r=l+1;r<=v;r++) {
			w[l][r]=w[l][r-1]+pos[r]-pos[l+r>>1];
		}
	}
}

int main() {
  v=rd,p=rd;
	for(int i=1;i<=v;i++) pos[i]=rd;
	
	init();
	sort(pos+1,pos+v+1);
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	for(int j=1;j<=p;j++) {
		d[v+1][j]=v;
		for(int i=v;i>=1;i--) {
			int minn=INF,minid;
			for(int k=d[i][j-1];k<=d[i+1][j];k++) {
				if(dp[k][j-1]+w[k+1][i]<minn) {
					minn=dp[k][j-1]+w[k+1][i];
					minid=k;
				}
			}
			dp[i][j]=minn;
			d[i][j]=minid;
		}
	}

	cout<<dp[v][p]<<endl;
	
	return 0;
}

/*
4
()()
1 -1 5 11

4
()()
1 6 5 11
*/
```

---

于是状态转移dp[i][j]时，从[d[i][j−1],d[i+1][j]]中找最优决策。

然后因为dp满足四边形不等式，所以对于dp[i][j]的最优决策d[i][j]，d[i][j−1]≤d[i][j]≤d[i+1][j]

提前预处理出w，w是可以O(V2)递推出来的，根据放置一个邮局，邮局位置总是在中位数处，便可推得。

### 思路

对于 $100\%$ 的数据，$1 \leq P \leq 300$，$P \leq V  \leq 3000$，$1 \leq $ 村庄位置 $\leq 10000$。

对于 $40\%$ 的数据，$V \leq 300$。

第一行包含一个整数$S$，它是每个村庄与其最近的邮局之间的所有距离的总和。

输出格式

第二行包含 $V$ 个整数。这些整数是村庄的位置。

第一行包含两个整数：第一个是村庄 $V$ 的数量，第二个是邮局的数量 $P$。

输入格式

你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。

邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。

高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。

题目描述

## [IOI2000] 邮局

```C++
#include <bits/stdc++.h>
#define rep(l, r, i) for (int i = l, END##i = r; i <= END##i; ++i)
#define per(r, l, i) for (int i = r, END##i = l; i >= END##i; --i)
using namespace std;
#define int long long
#define pii pair<int, int>

#define lc(x) (x << 1)
#define rc(x) (x << 1 | 1)

#define X(j) S[j]
#define Y(j) (dp[j]+(S[j]+L)*(S[j]+L))

#define rd read()
int read() {
  int xx = 0, ff = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-')
      ff = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9')
    xx = xx * 10 + (ch - '0'), ch = getchar();
  return xx * ff;
}
void write(int out) {
  if (out < 0)
    putchar('-'), out = -out;
  if (out > 9)
    write(out / 10);
  putchar(out % 10 + '0');
}

const int N = 2e5 + 15;
const int INF = 1e9 + 5;
const int MOD = 1 << 30;

int i,j,n,L,h=1,t=0,Q[N],S[N],dp[N];

inline int min(int a,int b){return a<b?a:b;}
inline long double slope(int i,int j){return (long double)(Y(j)-Y(i))/(X(j)-X(i));}
signed main(){
    scanf("%lld%lld",&n,&L);++L; 
    for(i=1;i<=n;S[i]+=S[i-1]+1,++i)scanf("%lld",&S[i]);
    Q[++t]=0;
    for(i=1;i<=n;++i){
        while(h<t&&slope(Q[h],Q[h+1])<=2*S[i])++h;
        dp[i]=dp[j=Q[h]]+(S[i]-S[j]-L)*(S[i]-S[j]-L);
        while(h<t&&slope(Q[t-1],Q[t])>=slope(Q[t-1],i))--t;
        Q[++t]=i;
    }
    printf("%lld",dp[n]);
}
```

std

---

对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$。

输出一行一个整数，代表所有容器的总费用最小是多少。

输出格式

第 $2$ 到 第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 件玩具的长度 $C_i$。

第一行有两个整数，用一个空格隔开，分别代表 $n$ 和 $L$。

输入格式

制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。

- 同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum\limits_{k=i}^{j}C_k$。

- 在一个一维容器中的玩具编号是连续的。

为了方便整理，P教授要求：

P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。

P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。

题目描述

## [HNOI2008] 玩具装箱

所有句子的长度不超过 $30$ 。

|测试点|$T$|$N$|$L$|$P$|
|-|-|-|-|-|
|$1$|$\le 10$|$\le18$|$\le 100$|$\le5$|
|$2$|$\le 10$|$\le 2\times 10^3$|$\le 6\times 10^4$|$\le10$|
|$3$|$\le 10$|$\le 2\times 10^3$|$\le 6\times 10^4$|$\le10$|
|$4$|$\le 5$|$\le 10^5$|$\le 200$|$\le10$|
|$5$|$\le 5$|$\le 10^5$|$\le 200$|$\le10$|
|$6$|$\le 5$|$\le 10^5$|$\le 3\times 10^6$|$2$|
|$7$|$\le 5$|$\le 10^5$|$\le 3\times 10^6$|$2$|
|$8$|$\le 5$|$\le 10^5$|$\le 3\times 10^6$|$\le10$|
|$9$|$\le 5$|$\le 10^5$|$\le 3\times 10^6$|$\le10$|
|$10$|$\le 5$|$\le 10^5$|$\le 3\times 10^6$|$\le10$|

数据规模与约定

---

```C++
#include <bits/stdc++.h>
#define rep(l, r, i) for (int i = l, END##i = r; i <= END##i; ++i)
#define per(r, l, i) for (int i = r, END##i = l; i >= END##i; --i)
using namespace std;
#define int long long
#define pii pair<int, int>

#define lc(x) (x << 1)
#define rc(x) (x << 1 | 1)
#define ld long double

#define rd read()
int read() {
  int xx = 0, ff = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-')
      ff = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9')
    xx = xx * 10 + (ch - '0'), ch = getchar();
  return xx * ff;
}
void write(int out) {
  if (out < 0)
    putchar('-'), out = -out;
  if (out > 9)
    write(out / 10);
  putchar(out % 10 + '0');
}

const int N = 2e5 + 15;
const int INF = 1e9 + 5;
const int MOD = 998244353;

int n,L,P,s[N],q[N],k[N],pr[N];
ld f[N];
char str[N][33];

ld ksm(ld b){
    ld a=1;
    for(int k=P;k;k>>=1,b*=b)
        if(k&1)a*=b;
    return a;
}
ld Calc(int i,int j){return f[j]+ksm(abs(s[i]-s[j]-L));}
int bound(int x,int y){
    int l=x,r=n+1,m;
    while(l<r){
        m=(l+r)>>1;
        Calc(m,x)>=Calc(m,y)?r=m:l=m+1;
    }
    return l;
}
signed main(){
    int T=rd,i,h,t;
    while(T--){
        n=rd;L=rd+1;P=rd;
        for(i=1;i<=n;++i){
            if(scanf("%s",str[i]));
            s[i]=s[i-1]+strlen(str[i])+1;
        }
        for(q[i=h=t=1]=0;i<=n;++i){
            while(h<t&&k[h]<=i)++h;
            f[i]=Calc(i,q[h]);pr[i]=q[h];
            while(h<t&&k[t-1]>=bound(q[t],i))--t;
            k[t]=bound(q[t],i);q[++t]=i;
        }
        if(f[n]>1e18)puts("Too hard to arrange");
        else{
            printf("%.0Lf\n",f[n]);
            for(q[t=0]=i=n;i;q[++t]=i=pr[i]);
            for(;t;--t){
                for(i=q[t]+1;i<q[t-1];++i)
                    printf("%s ",str[i]);
                puts(str[i]);
            }
        }
        puts("--------------------");
    }
    return 0;
}

```

---

$\Leftrightarrow\ G_j(i+1)+G_{j+1}(i)\geq G_{j}(i)+G_{j+1}(i+1)$

我们只需证明函数$G_j(i)=|\text{sum}_i+i-(\text{sum}_j+j)-(1+L)|^P$满足四边形不等式。

以下是节选

[www.luogu.com.cn](https://www.luogu.com.cn/blog/wohaocaia/solution-p1912)


证明如下

对于(i,j)(k,m)，设i<j,k<m，且i<k。那么我们之前做出的决策是用i的信息更新j，后面我们做出的决策是用k的信息更新m。若有k>i，则满足决策单调性。

我们可以发现|\text{sum}_i-\text{sum}_j+i-j-1-L|^P是存在决策单调性的。下面考虑证明：

其中$\text{sum}_x=\sum_{i=1}^xa_i$，即这里使用前缀和优化。a_i为第i个句子的长度。那么怎么优化呢？因为有一个P次方，数据结构优化是没办法了。

$f_i=\min(f_j+|\text{sum}_i-\text{sum}_j+i-j-1-L|^P)$

很显然的 dp 方程：

### 思路

前两组输入数据中每行的实际长度均为 $6$，后两组输入数据每行的实际长度均为 $4$。一个排版方案中每行相邻两个句子之间的空格也算在这行的长度中（可参见样例中第二组数据）。每行末尾没有空格。

如果有多个可行解，它们的不协调度都是最小值，则输出任意一个解均可。若最小的不协调度超过 $10^{18}$，则输出 `Too hard to arrange`。每组测试数据结束后输出 `--------------------`，共 20 个 `-`，`-` 的 ASCII 码为 45，请勿输出多余的空行或者空格。

于每组测试数据，若最小的不协调度不超过 $10^{18}$，则第一行为一个数，表示不协调度。接下来若干行，表示你排版之后的诗。注意：在同一行的相邻两个句子之间需要用一个空格分开。

输出格式

从第二行开始，每行为一个句子，句子由英文字母、数字、标点符号等符号组成（ASCII 码 $33 \sim 127$，但不包含 `-`）。

接下来为 $T$ 首诗，这里一首诗即为一组测试数据。每组测试数据中的第一行为三个由空格分隔的正整数 $N,L,P$，其中：$N$ 表示这首诗句子的数目，$L$ 表示这首诗的行标准长度，$P$ 的含义见问题描述。

输入文件中的第一行为一个整数 $T$，表示诗的数量。

输入格式

小 G 最近又作了几首诗，现在请你对这首诗进行排版，使得排版后的诗尽量协调（即不协调度尽量小），并把排版的结果告诉他。

一首诗包含了若干个句子，对于一些连续的短句，可以将它们用空格隔开并放在一行中，注意一行中可以放的句子数目是没有限制的。小 G 给每首诗定义了一个行标准长度（行的长度为一行中符号的总个数），他希望排版后每行的长度都和行标准长度相差不远。显然排版时，不应改变原有的句子顺序，并且小 G 不允许把一个句子分在两行或者更多的行内。在满足上面两个条件的情况下，小 G 对于排版中的每行定义了一个不协调度, 为这行的实际长度与行标准长度差值绝对值的 $P$ 次方，而一个排版的不协调度为所有行不协调度的总和。

小 G 是一个出色的诗人，经常作诗自娱自乐。但是，他一直被一件事情所困扰，那就是诗的排版问题。

题目描述

## [NOI2009] 诗人小G

因为每一个 $i$ 都会至多添加一个三元组，对一个三元组进行二分，又因为一个三元组至多被删除一次，所以复杂度为 $O(n\log n)$。

至此算法结束。

二分出分界点 $x$ 后，队尾三元组的 $r$ 应改为 $x-1$（之后的决策都要变）。队尾再新加入一个三元组 $(i,x,n)$，表示 $x$ 到 $n$ 的决策都可以改为更优的 $i$。

到最后用 $i$ 来更新队尾的 $l$ 没有队尾的 $p$ 更新队尾的 $l$ 优。那么我们就要找出决策变为 $i$ 的分界点。由于决策具有单调性，我们可以二分。二分边界就是队尾三元组的 $l$ 和 $n$（为什么不是 $r$？因为可能这整个三元组都满足原来的决策，此时二分却会把最后一个元素拆走）。

接下来从队尾开始扫，如果用 $i$ 来更新队尾的 $l$ 比队尾的 $p$ 更新队尾的 $l$ 更优，说明队尾的决策应该比 $p$ 更大（因为我们从小到大枚举 $i$），那么根据决策单调性，整个三元组中的决策都比 $p$ 大。于是便可以弹出队尾。

每次计算 $dp_i$ 时，就先把队列中无用的三元组弹出（$r<i$），并把新的队首的 $l$ 设为 $i$。此时 $i$ 在队首，所以 $i$ 的决策就是队首的 $p$。用 $dp_p$ 更新 $dp_i$。

队列维护决策三元组 $(p,l,r)$ 表示目前看来 $t_l,t_{l+1}\dots t_r$ 都是 $p$。一般来说一开始队列里只有三元组 $(0,1,n)$。

**决策队列具体是这样做的：**

决策单调性的优化方法大致有决策栈，决策队列和分治。下面说明决策队列优化。

（其实如果反之，在交点前都是 $j_2$ 更优而交点后都是 $j_1$ 更优，是一种不同的决策单调性问题，因与本题无关此处略去。）

因为交点之前的 $i$ 的决策都是 $j_1$，交点后的决策都是 $j_2$。正好满足决策单调性。

若对于任意 $j_1<j_2$，$f_{j_1}(i)$ 和 $f_{j_2}(i)$ 的函数图像至多有一个交点，在这个交点之前是 $f_{j_1}(i)$ 更小，在这个交点后是 $f_{j_2}(i)$ 更小，那么这个问题就满足决策单调性。

令 $f_j(i)$ 为用 $j$ 转移时 $dp_i$ 的值（即 $dp_j+f(j,i)$）。

**具体如何判断？**

形如 $dp_i=\min/\max(dp_j+f(j,i))$ 这类的式子，令 $t_i$ 为使得 $dp_i$ 取到 $\min/\max$ 的 $j$，（其实 $t_i$ 就叫最优决策）若 $t_i$ 具有单调性，则这个 dp 式子就满足决策单调性。

**什么是决策单调性优化 dp？**

---

下面是一些摘录

[www.luogu.com.cn](https://www.luogu.com.cn/blog/1000suns/solution-p1912)


关于决策单调性优化 dp，下面的博客讲的很清楚

四边形不等式优化和斜率优化本质上都是利用了**单调性**，所以有一些时候可以通用。

通常是用来证明dp的一些特殊性质，会和其它dp优化方法结合，如斜率优化。

# 决策单调性之 四边形不等式优化（决策单调性优化 dp）

DP优化

# 数据结构优化

## [NOI2020] 命运

题目描述

**提示**：我们在题目描述的最后一段提供了一份简要的、形式化描述的题面。

在遥远的未来，物理学家终于发现了时间和因果的自然规律。即使在一个人出生前，我们也可以通过理论分析知晓他或她人生的一些信息，换言之，物理学允许我们从一定程度上“预言”一个人的“命运”。

简单来说，一个人的命运是一棵由时间点构成的有根树 $T$：树的根结点代表着出生，而叶结点代表着死亡。每个非叶结点 $u$ 都有一个或多个孩子 $v_1, v_2,\dots , v_{c_u}$，表示这个人在 $u$ 所代表的时间点做出的 $c_u$ 个不同的选择可以导向的不同的可能性。形式化的，一个选择就是树上的一条边 $(u, v_i)$，其中 $u$ 是 $v_i$ 的父结点。

一个人的一生是从出生（即根结点）到死亡（即某一个叶子结点）的一条不经过重复结点的路径，这条路径上任何一个包含至少一条边的子路径都是这个人的一段**人生经历**，而他或她以所有可能的方式度过一生，从而拥有的所有人生经历，都被称为**潜在的人生经历**。换言之，所有潜在的人生经历就是所有 $u$ 到 $v$ 的路径，满足 $u, v \in T$，$u \neq v$，并且 $u$ 是 $v$ 的祖先。在数学上，这样一个潜在的人生经历被记作有序对 $(u, v)$，树 $T$ 所有潜在的人生经历的集合记作 $\mathcal P_T$。

物理理论不仅允许我们观测代表命运的树，还能让我们分析一些潜在的人生经历是否是“重要”的。一个人所作出的每一个选择——即树上的每一条边——都可能是**重要**或**不重要**的。一段潜在的人生经历被称为重要的，当且仅当其对应的路径上存在一条边是重要的。我们可以观测到一些潜在的人生经历是重要的：换言之，我们可以观测得到一个集合 $\mathcal Q \subseteq \mathcal P_T$，满足其中的所有潜在的人生经历 $(u, v) \in \mathcal Q$ 都是重要的。

树 $T$ 的形态早已被计算确定，集合 $\mathcal Q$ 也早已被观测得到，一个人命运的不确定性已经大大降低了。但不确定性仍然是巨大的——来计算一下吧，对于给定的树 $T$ 和集合 $\mathcal Q$，存在多少种不同的方案确定每条边是否是重要的，使之满足所观测到的 $\mathcal Q$ 所对应的限制：即对于任意 $(u, v) \in \mathcal Q$，都存在一条 $u$ 到 $v$ 路径上的边被确定为重要的。

**形式化的**：给定一棵树 $T = (V, E)$ 和点对集合 $\mathcal Q \subseteq V \times V$ ，满足对于所有 $(u, v) \in \mathcal Q$，都有 $u \neq v$，并且 $u$ 是 $v$ 在树 $T$ 上的祖先。其中 $V$ 和 $E$ 分别代表树 $T$ 的结点集和边集。求有多少个不同的函数 $f$ : $E \to \{0, 1\}$（将每条边 $e \in E$ 的 $f(e)$ 值置为 $0$ 或 $1$），满足对于任何 $(u, v) \in \mathcal Q$，都存在 $u$ 到 $v$ 路径上的一条边 $e$ 使得 $f(e) = 1$。由于答案可能非常大，你只需要输出结果对 $998,244,353$（一个素数）取模的结果。

输入格式

从文件 destiny.in 中读入数据。

第一行包含一个正整数 $n$，表示树 $T$ 的大小，树上结点从 $1$ 到 $n$ 编号，$1$ 号结点为根结点；

接下来 $n - 1$ 行每行包含空格隔开的两个数 $x_i, y_i$，满足 $1 \leq x_i, y_i \leq n$，表示树上的结点 $x_i$ 和 $y_i$ 之间存在一条边，但并不保证这条边的方向；

接下来一行包含一个非负整数 $m$，表示所观测得到信息的条数。

接下来 $m$ 行每行包含空格隔开的两个数 $u_i, v_i$，表示 $(u_i, v_i) \in \mathcal Q$。**请注意**：输入数据可能包含重复的信息，换言之可能存在 $i \neq j$，满足 $u_i = u_j$ 且 $v_i = v_j$。

输入数据规模和限制参见本题末尾的表格。

输出格式

输出到文件 destiny.out 中。

输出仅一行一个整数，表示方案数对 $998, 244, 353$ 取模的结果。

#### 样例 1 解释

共有 $16$ 种方案，其中不满足题意的方案有以下 $6$ 种：

- $(1, 2),(2, 3),(3, 5)$ 确定为不重要，$(3, 4)$ 确定为重要：集合 $\mathcal Q$ 中没有限制被满足。

- $(1, 2),(2, 3),(3, 4),(3, 5)$ 确定为不重要：集合 $\mathcal Q$ 中没有限制被满足。

- $(1, 2),(2, 3)$ 确定为不重要，$(3, 4),(3, 5)$ 确定为重要：集合 $\mathcal Q$ 中 $(1, 3)$ 没被满足。

- $(1, 2),(2, 3),(3, 4)$ 确定为不重要，$(3, 5)$ 确定为重要：集合 $\mathcal Q$ 中 $(1, 3)$ 没被满足。

- $(2, 3),(3, 5)$ 确定为不重要，$(1, 2),(3, 4)$ 确定为重要：集合 $\mathcal Q$ 中 $(2, 5)$ 没被满足。

- $(2, 3),(3, 4),(3, 5)$ 确定为不重要，$(1, 2)$ 确定为重要：集合 $\mathcal Q$ 中 $(2, 5)$ 没被满足。

- 其他方案下，集合 $\mathcal Q$ 中的限制都被满足了。

#### 样例 3

见选手目录下的 destiny/destiny3.in 与 destiny/destiny3.ans。

#### 样例 4

见选手目录下的 destiny/destiny4.in 与 destiny/destiny4.ans。

|测试点编号|$n$|$m$|$T$ 为完全二叉树|
|-|-|-|-|
|$1\sim 4$|$\le 10$|$\le 10$|否|
|$5$|$\le 500$|$\le 15$|否|
|$6$|$\le 10^4$|$\le 10$|否|
|$7$|$\le 10^5$|$\le 16$|否|
|$8$|$\le 5\times 10^5$|$\le 16$|否|
|$9$|$\le 10^5$|$\le 22$|否|
|$10$|$\le 5\times 10^5$|$\le 22$|否|
|$11$|$\le 600$|$\le 600$|否|
|$12$|$\le 10^3$|$\le 10^3$|否|
|$13\sim 14$|$\le 2\times 10^3$|$\le 5\times 10^5$|否|
|$15\sim 16$|$\le 5\times 10^5$|$\le 2\times 10^3$|否|
|$17\sim 18$|$\le 10^5$|$\le 10^5$|是|
|$19$|$\le 5\times 10^4$|$\le 10^5$|否|
|$20$|$\le 8\times 10^4$|$\le 10^5$|否|
|$21\sim 22$|$\le 10^5$|$\le 5\times 10^5$|否|
|$23\sim 25$|$\le 5\times 10^5$|$\le 5\times 10^5$|否|

---

### 测试点约束

**全部数据满足**：$n \leq 5 \times 10^5$，$m \leq 5 \times 10^5$。输入构成一棵树，并且对于 $1 \leq i \leq m$，$u_i$ 始终为 $v_i$ 的祖先结点。

**完全二叉树**：在本题中，每个非叶结点都有左右子结点，且所有叶子结点深度相同的树称为满二叉树；将满二叉树中的结点按照从上到下、从左向右的顺序编号，编号最小的若干个结点形成的树称为完全二叉树。

## ??|[NOI1998] 免费的馅饼

题目描述

SERKOI 最新推出了一种叫做“免费馅饼”的游戏：游戏在一个舞台上进行。舞台的宽度为 $w$ 格（从左到右依次用 $1$ 到 $w$ 编号），游戏者占一格。开始时游戏者可以站在舞台的任意位置，手里拿着一个托盘。下图为天幕的高度为 $4$ 格时某一个时刻游戏者接馅饼的情景。

![https://cdn.luogu.com.cn/upload/image_hosting/1gcg9awi.png](数据结构优化+bb4d534b-c218-4ef3-bf0e-cd1133654a4a/1gcg9awi.png)

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。

当馅饼在某一时刻恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。当馅饼落在一个游戏者不在的格子里时该馅饼就消失。

写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

输入格式

第一行是用空格隔开的两个正整数，分别给出了舞台的宽度 $w$ 和馅饼的个数 $n$。

接下来 $n$ 行，每一行给出了一块馅饼的信息。

由三个正整数组成，分别表示了每个馅饼落到舞台上的时刻 $t_i$，掉到舞台上的格子的编号 $p_i$，以及分值 $v_i$。

游戏开始时刻为 $0$。

输入文件中同一行相邻两项之间用一个空格隔开。

输入数据中可能存在两个馅饼的 $t_i$ 和 $p_i$ 都一样。

输出格式

一个数，表示游戏者获得的最大总得分。

对于 $100\%$ 的数据，$1 \leq w \leq 10^8$，$1 \leq n \leq 10^5$，$1\leq t_i \leq 10^8$，$1\leq p_i \leq w$，$1\leq v_i \leq 1000$。

### 思路

好经典的玩法

咳咳，我们来看题目。简化题意，你有一个指针，每一秒可以向左向右移动一个单位。给定n个条件，当在t_i时刻指针处于p_i，就可以得1分。求最高得分。

那么我们设定f_i为表示拿到了第i个得分条件时最大得分。

那么考虑转移。很显然，我们可以从特点的某些f_j处转移。形式化地，有$f_i=\max(f_i,v_i+f_j),|p_i-p_j|≤2t_i-2t_j$

那么我们就需要一个可以维护最小值的数据结构来维护符合条件的最小值。我们可以想到的是线段树，但是显然我们需要对条件进行一些变形。很显然我们需要把上面的不等式按下标移项，那么我们就需要讨论那烦人的绝对值了。

- 若p_i>p_j，则变形为p_i-p_j≤2t_i-2t_j，即$2t_j-p_j≤2t_i-p_i$

- 若p_i<p_j，则变形为-p_i+p_j≤2t_i-2t_j，即$p_j+2t_j≤2t_i+p_i$

那这咋办呢？二维线段树是不可敲的。

我们需要查询p_j满足$p_i-t_i+t_j≤p_j≤p_i+t_i-t_j$。我们发现，当t_i-t_j>0大前提成立时，若p_i-p_j≤2t_i-2t_j成立，则必有p_i>p_j。另外一个同理。因此，我们只需要满足下面即可

$2t_j-p_j≤2t_i-p_i$且$p_j+2t_j≤2t_i+p_i$。因此是一个二维偏序问题。

为什么是“且”？

---

```C++
#include<bits/stdc++.h>
#define rep(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define per(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
#define int long long
#define pii pair<int,int>

#define lc(x) (x<<1)
#define rc(x) (x<<1|1)

#define rd read()
int read(){
	int xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') xx=xx*10+(ch-'0'),ch=getchar();
	return xx*ff;
}
void write(int out){
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int N=2e5+15;
const int INF=1e9+5;
const int MOD=998244353;


int b[N],w,n,k,c[N];

struct node{
	int t,p,v,l,r;
}a[N];
bool cmpl(node x,node y){
	return x.l>y.l;
}
bool cmpr(node x,node y){
	return x.r<y.r;
}

void update(int x,int val){
	while(x<=k){
		c[x]=max(c[x],val);
		x+=x&-x;
	}
}

int query(int x){
	int res=0;
	while(x){
		res=max(res,c[x]);
		x-=x&-x;
	}
	return res;
}

signed main(){
	w=rd,n=rd;
	for(int i=1;i<=n;i++){
		a[i].t=rd,a[i].p=rd,a[i].v=rd;
		a[i].l=a[i].p-2*a[i].t;
		a[i].r=b[i]=a[i].p+2*a[i].t;
	}
                                  
	sort(a+1,a+n+1,cmpr);
	sort(b+1,b+n+1);
	k=unique(b+1,b+n+1)-b;
	for(int i=1;i<=n;i++)
		a[i].r=lower_bound(b+1,b+n+1,a[i].r)-b;
  
	sort(a+1,a+n+1,cmpl);
	for(int i=1;i<=n;i++){
		int tmp=query(a[i].r);
		update(a[i].r,tmp+a[i].v);//对于刚转移得到的dp值tmp，加入到树状数组里
	}
	cout<<query(k);
	return 0;
}


```





