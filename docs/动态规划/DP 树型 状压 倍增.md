DP | 树型，状压，倍增

# 目录

- 树形DP

- 状态压缩DP

- 倍增DP

- 其他

# 树形DP | 没有上司的舞会

## 题目描述

某大学有 $n$ 个职员，编号为 $1\ldots n$。

他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。

现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。

所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

## 输入格式

输入的第一行是一个整数 $n$。

第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。

第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。

## 输出格式

输出一行一个整数代表最大的快乐指数。

## 样例 #1

### 样例输入 #1

```C++
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

### 样例输出 #1

```C++
5
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。

## 代码

```C++
#include <bits/stdc++.h>
const int N=1e4+5;
using namespace std;
vector <int> son[N];
int f[N][2],n,hap[N],l,k,hasfa[N];
void dp(int x){
	f[x][0]=0;
	f[x][1]=hap[x];
	for(int i=0;i<son[x].size();i++){
		int y=son[x][i];
		dp(y);
		f[x][0]+=max(f[y][1],f[y][0]);
		f[x][1]+=f[y][0];
	}
}
int main(){
	//ios::sync_which_stdio(false);
	cin>>n;
	
	for(int i=1;i<=n;i++){
		cin>>hap[i];
	} 
	for(int i=1;i<=n-1;i++){
		cin>>l>>k;
		hasfa[l]=1;
		son[k].push_back(l);
	}
	int rt=0;
	while(hasfa[++rt]);
	dp(rt);
//	cout<<"rt="<<rt<<endl;
	cout<<max(f[rt][1],f[rt][0])<<endl;
	return 0;
}

```

# 状态压缩DP | [USACO06NOV]Corn Fields G

## 题目描述

农场主 $\rm John$ 新买了一块长方形的新牧场，这块牧场被划分成 $M$ 行 $N$ 列 $(1 \le M \le 12; 1 \le  N \le 12)$，每一格都是一块正方形的土地。 $\rm John$ 打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。

遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是 $\rm John$ 不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。

$\rm John$ 想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）

## 输入格式

第一行：两个整数 $M$ 和 $N$，用空格隔开。

第 $2$ 到第 $M+1$ 行：每行包含 $N$ 个用空格隔开的整数，描述了每块土地的状态。第 $i+1$ 行描述了第 $i$ 行的土地，所有整数均为 $0$ 或 $1$ ，是 $1$ 的话，表示这块土地足够肥沃，$0$ 则表示这块土地不适合种草。

## 输出格式

一个整数，即牧场分配总方案数除以 $100,000,000$ 的余数。

## 样例 #1

### 样例输入 #1

```C++
2 3
1 1 1
0 1 0
```

### 样例输出 #1

```C++
9
```

