[b23.tv](https://b23.tv/v4GAHA0)
费用流

专题 | 二分图/二部图问题

[b23.tv](https://b23.tv/wEJ5Ozv)
匈牙利算法

# 二分图的最大匹配

![image.png](二分图/image.png)

二分图（二部图）的最大匹配：

设 $G$ 为二分图 ， 若在 $G $ 的子图 $M $ 中 ， 任意两条边都没有公共节点 ， 那么称 $M $ 为二分图 $G $ 的一组匹配 。 在二分图中 ，包含边数最多的一组匹配称为二分图的最大匹配。

如在下图中，1-4，5-3就是一组匹配。1-4，5-3，2-7就是下图的最大匹配

![image.png](二分图/image 1.png)



![image.png](二分图/image 2.png)



![image.png](二分图/image 3.png)

## 二分图染色

### 例题 #1 [NOIP2008 提高组] 双栈排序

题目描述

Tom 最近在研究一个有趣的排序问题。如图所示，通过 $2$ 个栈 $S_1$ 和 $S_2$，Tom 希望借助以下 $4$ 种操作实现将输入序列升序排序。

![https://cdn.luogu.com.cn/upload/image_hosting/gwxu91ud.png](二分图/gwxu91ud.png)

- 操作 $\verb!a!$：将第一个元素压入栈 $S_1$。

- 操作 $\verb!b!$：将 $S_1$ 栈顶元素弹出至输出序列。

- 操作 $\verb!c!$：将第一个元素压入栈 $S_2$。

- 操作 $\verb!d!$：将 $S_2$ 栈顶元素弹出至输出序列。

如果一个 $1\sim n$ 的排列 $P$ 可以通过一系列合法操作使得输出序列为 $(1,2,\cdots,n-1,n)$，Tom 就称 $P$ 是一个“可双栈排序排列”。例如 $(1,3,2,4)$ 就是一个“可双栈排序序列”，而 $(2,3,4,1)$ 不是。下图描述了一个将 $(1,3,2,4)$ 排序的操作序列：$\texttt {a,c,c,b,a,d,d,b}$。

![https://cdn.luogu.com.cn/upload/image_hosting/jwdjwfee.png](二分图/jwdjwfee.png)

当然，这样的操作序列有可能有几个，对于上例 $(1,3,2,4)$，$\texttt{a,b,a,a,b,b,a,b}$ 是另外一个可行的操作序列。Tom 希望知道其中字典序最小的操作序列是什么。

输入格式

第一行是一个整数 $n$。

第二行有 $n$ 个用空格隔开的正整数，构成一个 $1\sim n$ 的排列。

输出格式

共一行，如果输入的排列不是“可双栈排序排列”，输出 `0`。

否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。

$100\%$ 的数据满足：$n\le1000$。

---

首先考虑只有一个栈的情况：

我们考虑两个数字a_i,a_j不允许存在的情况是什么。

存在k，使得i<j<k且a_k<a_i<a_j。

所以如果一个序列可以被双栈排序，那么它就应该可以划分为两个子序列，使得每个子序列中都不存在上述情况。

所以我们把构成上述情况的 (i,j)连边，然后跑二分图染色。如果染色成功，则说明可以划分。



判断完了是否能正确排序后，我们就可以思考如何取字典序最小的操作序列了。

首先考虑怎么使操作是正确的，即操作后能产生升序序列。 大体思路就是将序列中的每个数依次压入它属于的栈中（属于哪个栈在二分图染色时就可以标记好），在将这个数压入栈前，我们要先判断压入之后栈是否仍然单调，若不单调，则一直弹出栈顶元素，直到单调为止。 **注意**：在弹出栈顶元素时，栈顶的元素可能不是当前应当弹出的数（因为我们要使得输出序列的元素是递增的），所以我们需要一个变量 now，表示当前应当弹出的数，若该栈顶的数不等于 now，就弹出另外一个栈顶的数。

在考虑以上条件之后，我们就可以输出正确的操作序列了，那要怎么才能输出字典序最小的呢？ 同一个栈的压入和弹出的相对顺序似乎改变不了，那么我们就考虑两个栈的操作之间的顺序吧。 既然 S1​ 的操作的字典序更小，那么我们可以想一下什么时候能先进行 S1​ 的操作。由于压栈的顺序是一定的，那么我们就考虑弹出操作，在压入属于 S2​ 的数之前，我们可以先把 S1​ 中能弹出的数都弹出来，这样就可以使得字典序最小了。



```C++
/*                                                                                
                      Keyblinds Guide
     				###################
      @Ntsc 2024

      - Ctrl+Alt+G then P : Enter luogu problem details
      - Ctrl+Alt+B : Run all cases in CPH
      - ctrl+D : choose this and dump to the next
      - ctrl+Shift+L : choose all like this
      - ctrl+K then ctrl+W: close all
      - Alt+la/ra : move mouse to pre/nxt pos'
	  
*/
#include <bits/stdc++.h>
#include <queue>
using namespace std;

#define rep(i, l, r) for (int i = l, END##i = r; i <= END##i; ++i)
#define per(i, r, l) for (int i = r, END##i = l; i >= END##i; --i)
#define pb push_back
#define mp make_pair
#define int long long
#define pii pair<int, int>
#define ps second
#define pf first

// #define innt int
#define itn int
// #define inr intw
// #define mian main
// #define iont int

#define rd read()
int read(){
    int xx = 0, ff = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
		if (ch == '-')
			ff = -1;
		ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
      xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}
void write(int out) {
	if (out < 0)
		putchar('-'), out = -out;
	if (out > 9)
		write(out / 10);
	putchar(out % 10 + '0');
}

#define ell dbg('\n')
const char el='\n';
const bool enable_dbg = 1;
template <typename T,typename... Args>
void dbg(T s,Args... args) {
	if constexpr (enable_dbg){
    cerr << s;
    if(1)cerr<<' ';
		if constexpr (sizeof...(Args))
			dbg(args...);
	}
}

#define zerol = 1
#ifdef zerol
#define cdbg(x...) do { cerr << #x << " -> "; err(x); } while (0)
void err() { cerr << endl; }
template<template<typename...> class T, typename t, typename... A>
void err(T<t> a, A... x) { for (auto v: a) cerr << v << ' '; err(x...); }
template<typename T, typename... A>
void err(T a, A... x) { cerr << a << ' '; err(x...); }
#else
#define dbg(...)
#endif


const int N = 3e3 + 5;
const int INF = 1e18;
const int M = 1e7;
const int MOD = 1e9 + 7;

int n,val[N],minx[N],col[N];
vector<int> p[N];
stack<int> s[3];


int now;
bool judge(int id){
	if(s[id].empty()||s[id].top()!=now+1) return 0;
	return 1;
}


void del(int id){
	now++;
	s[id].pop();
	putchar(id==1 ?'b' :'d');
	putchar(' ');
}



void add(int v,int id){
	if(id==2) while(judge(1)) del(1);
	while(!s[id].empty()&&s[id].top()<v){
		if(!judge(id)) del(3-id);
		else del(id);
	}
	if(id==2) while(judge(1)) del(1);
	s[id].push(v);
	putchar(id==1 ?'a' :'c');
	putchar(' ');
}



void print(){
	for(int i=1;i<=n;i++){
		add(val[i],col[i]);
	}
	while(!s[1].empty()){
		if(!judge(1)) del(2);
		else del(1);
	}
	while(!s[2].empty()) del(2);
}


void solve(){
	n=rd;
	for(int i=1;i<=n;i++)
		val[i]=rd;	minx[n+1]=n+1;
	for(int i=n;i>=1;i--)
		minx[i]=min(minx[i+1],val[i]);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			if(val[i]<val[j]&&minx[j+1]<val[i]) {
                p[i].push_back(j);
                p[j].push_back(i);
            }

    for(int i=1;i<=n;i++)
		if(!col[i]){
			queue<int> q;
			col[i]=1;
			q.push(i);
			while(!q.empty()){
				int u=q.front();
				q.pop();
				for(int j=0;j<p[u].size();j++){
					int v=p[u][j];
					if(col[v]){
						if(col[v]==col[u]){
		                    printf("0");
							return;
						}
						continue;
					}
					col[v]=3-col[u];
					q.push(v);
				}
			}
		}


	print();
}

signed main() {
    // freopen(".in","r",stdin);
    // freopen(".in","w",stdout);

    int T=1;
    while(T--){
    	solve();
    }
    return 0;
}
```

## 匈牙利算法

匈牙利算法通过不停地找增广路来增加配边找不到增广路时 ， 达到最大匹配 。 可以用 DFS 或 BFS 来实现 。

算法简单，下面结合代码和例题.

### 例题 #1

给定一个二分图，其左部点的个数为 $n$，右部点的个数为 $m$，边数为 $e$，求其最大匹配的边数。

左部点从 $1$ 至 $n$ 编号，右部点从 $1$ 至 $m$ 编号。

输出一行一个整数，代表二分图最大匹配的边数。

对于全部的测试点，保证：

- $1 \leq n, m \leq 500$。

- $1 \leq e \leq 5 \times 10^4$。

- $1 \leq u \leq n$，$1 \leq v \leq m$。

**不保证给出的图没有重边**。

---

```C++
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int n,m,E,ans;
//int h[N],e[N];
vector <int> e[N];
int vis[N],match[N];
void add(int a,int b){
	e[a].push_back(b);
}
bool dfs(int u){
	for(int i=0;i<e[u].size();i++){//扫描所有可能成为配对的右点（即有连边的点）
		int v=e[u][i];
		if(vis[v])continue;//即（在上一层函数中）已经被访问过
		vis[v]=1;//不是上一层函数中想要的点，那么这一层就可能可以匹配成功
		if(!match[v]||dfs(match[v])){//如果 点v没有任何已有匹配，那么匹配它和u！ 或者它有匹配了(与match[v]),但match[v]可以找到另外一个右点和它匹配,那么就可以把点v让给u (这样可以保证已经有的匹配数不减少,可能会变更,但不减少)(贪心)
			match[v]=u;
			return 1;
		}
	}
	return 0;//扫描全部结束,没有一个匹配成功
}
signed main(){
	cin>>n>>m>>E;
	for(int i=1;i<=E;i++){
		int a,b;
		cin>>a>>b;
		add(a,b);//我们只通过左边找右边，因此只需要单向边
	}
	for(int i=1;i<=n;i++){//遍历每个左边的点给它找配对
		memset(vis,0,sizeof vis);
		if(dfs(i))ans++;//如果找到了配对
	}
	cout<<ans;
	return 0;
}
 
```

详细解释以下片段

```C++
if(vis[v])continue;//即（在上一层函数中）已经被访问过
		vis[v]=1;//不是上一层函数中想要的点，那么这一层就可能可以匹配成功
		if(!match[v]||dfs(match[v])){//如果 点v没有任何已有匹配，那么匹配它和u！ 或者它有匹配了(与match[v]),但match[v]可以找到另外一个右点和它匹配,那么就可以把点v让给u (这样可以保证已经有的匹配数不减少,可能会变更,但不减少)(贪心)
```

先忽略vis[]，当走到判定处，发现match[v]≠0，那么就要去dfs(match[v])，此时从dfs(u)的函数空间走到了dfs(match[v])的函数空间，这时才会出现vis[v]≠0的情况



如果vis[v]≠1了，就说明在dfs(u)函数空间内这个点已经被预定了，match[v]这个点只能另寻他人

**时间复杂度 理论上限O(nm)**

![image.png](二分图/image 4.png)

### 例题 #2

给定一个二分图，其点的个数为 $n$，边数为 $e$，求其最大匹配的边数。

输入 $e$ 条边，保证连成的图为二分图

输出一行一个整数，代表二分图最大匹配的边数。

---

(未验证的)

```C++
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int pleft[N];//0未发现,1为左点，2为右点 
int n,ln,E,ans;
//int h[N],e[N];
vector <int> e[N];
int vis[N],match[N];
void add(int a,int b){
	e[a].push_back(b);
}
bool dfs(int u){
	for(int i=0;i<e[u].size();i++){
		int v=e[u][i];
		if(vis[v])continue;
		vis[v]=1;
		if(!match[v]||dfs(match[v])){
			match[v]=u;
			return 1;
		}
	}
	return 0;
}
signed main(){
	cin>>n>>E;
	for(int i=1;i<=E;i++){
		int a,b;
		cin>>a>>b;
		
		if(&&!pletf[b])add(a,b),pletf[b]=2,pletf[a]=1,ln++;
		
		if(pletf[a]==1||pletf[b]==2)
		if(!pletf[a])ln++;
		add(a,b),pletf[a]=1,pletf[b]=2;
		
		if(pletf[a]==2||pletf[b]==1)
		if(!pletf[b])ln++;
		add(b,a),pletf[a]=2,pletf[b]=1;
		
	}
//	cout<<"OK"<<endl;
	for(int i=1;i<=ln;i++){
		memset(vis,0,sizeof vis);
		if(dfs(i))ans++;
	}
	cout<<ans;
	return 0;
}
 
```

