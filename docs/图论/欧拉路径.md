# 欧拉路径

求有向图字典序最小的欧拉路径。

欧拉路径（欧拉通路）：通过图中所有边的简单路。（换句话说，每条边都通过且仅通过一次）也叫”一笔画”问题。

**有向图欧拉路径**：

图中**恰好**存在 1 个点出度比入度多 1（这个点即为 **起点** S），1 个点入度比出度多 1（这个点即为 **终点** T），其余节点出度=入度。或者**图为一个环**，即所有点的入度=出度。

**寻找欧拉路径（默认存在）**：

- 首先根据题意以及判定先确定起点 S。

- 从起点 S 开始 dfs 。

`dfs(x)` 中我们从小到大（按出边指向的点的编号大小排序）枚举。枚举到一个还没有访问的边就标记为已经访问，然后 dfs 下去。 同时记录经过的点的编号。

注意我们要用**栈**来记录答案而不是数组！

我们也可以进行优化，记录$del_x$为点$x$的出边已经访问过了$del_x-1$条，下次应该从第$del_x$条开始访问。

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define int long long
#define db double
#define rtn return
using namespace std;

const int N=2e5+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

int n,m,p,q,T,ans[N];
vector<int> e[N],vis[N];
int ind[N],oud[N],del[N];
int s,t,cnt;


stack<int> st;

void add(int a,int b){
	e[a].push_back(b);
	ind[b]++;oud[a]++;
}

bool check(){
	s=1;
	int flg=1,cnta=0,cntb=0;
	for(int i=1;i<=n;i++){
		if(ind[i]==oud[i])continue;
		flg=0;
		if(ind[i]==oud[i]-1){
			s=i;cnta++;
		}else if(ind[i]==oud[i]+1){
			t=i;cntb++;
		}else return 0;
	}
	
	return (cnta==cntb&&cnta==1)||flg;
}

void dfs(int x){
//	ans[++cnt]=x;
	for(int i=del[x];i<e[x].size();i=del[x]){
		del[x]=i+1;
		dfs(e[x][i]);
	}
	st.push(x);
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int a,b;
		cin>>a>>b;
		add(a,b);
	}
	
	for(int i=1;i<=n;i++){
		sort(e[i].begin(),e[i].end());
	}
	if(!check()){
		cout<<"No"<<endl;
		return 0;
	}
	
	dfs(s);
	while(st.size())cout<<st.top()<<' ',st.pop();
	
	return 0;
}


```

