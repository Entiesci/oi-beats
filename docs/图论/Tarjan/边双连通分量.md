# 边双连通分量

## 题目描述

对于一个 $n$ 个节点 $m$ 条无向边的图，请输出其边双连通分量的个数，并且输出每个边双连通分量。

## 提示&代码

```C++
void tarjan(int u,int eid) {//当前节点,入边编号
	dfn[u]=low[u]=++indx;
	stk[++tp]=u;
	for(int i=head[u]; ~i; i=edge[i].nxt) {
		int v=edge[i].to;
		if(dfn[v]==0) {
			tarjan(v,i);
			low[u]=min(low[u],low[v]);
		}
		if(i!=(eid^1)) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]) {
		edcc++;
		int x;
		do {
			x=stk[tp--];
			belong[x]=edcc;
		} while(x!=u);
	}
}
```

完整代码

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define int long long
#define db double
#define rtn return
using namespace std;

const int N=5e5+5;
const int M=5e6;
const int Mod=1e5;
const int INF=1e5;

int n,m,p,T;



int dfn[N],low[N],indx;//时间戳，追溯值，给时间戳编号的计数器 
int stk[N],tp;//栈，指针 
bool instk[N]; //是否在栈中
int belong[N],siz[N],edcc; //记录每个点在那个边双连通分量里, 每个点所在的边双连通分量的大小,边双连通分量的数量 
vector<int> ans[N];

int vis[N];

struct edge{
	int to,nxt;
}e[M];
int h[N],idx=-1;
void add(int a,int b){
	e[++idx]={b,h[a]};
	h[a]=idx;
	e[++idx]={a,h[b]};
	h[b]=idx;
}

void tarjan(int u,int eid) {//当前节点,入边编号
	vis[u]=1;
	dfn[u]=low[u]=++indx;
	stk[++tp]=u;
	for(int i=h[u]; ~i; i=e[i].nxt) {
		int v=e[i].to;
		if(dfn[v]==0) {
			tarjan(v,i);
			low[u]=min(low[u],low[v]);
		}
		if(i!=(eid^1)) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]) {
		edcc++;
		int x;
		do {
			x=stk[tp--];
			belong[x]=edcc;
		} while(x!=u);
	}
}
signed main(){
	int m,n;
	cin>>n>>m;
	
	for(int i=1;i<=N;i++)e[i].nxt=-1,h[i]=-1;
	for(int i=1;i<=m;i++){
		int a,b;
		cin>>a>>b;
		add(a,b);
	}
	for(int i=1;i<=n;i++)if(!vis[i])tarjan(i,0);//图可能不连通！切勿重复访问！
	for(int i=1;i<=n;i++)ans[belong[i]].push_back(i);
	
	cout<<edcc<<endl; 
	for(int i=1;i<=edcc;i++){
		cout<<ans[i].size()<<' ';
		for(auto v:ans[i])cout<<v<<' ';
		cout<<endl;
	
	return 0;
}

```

