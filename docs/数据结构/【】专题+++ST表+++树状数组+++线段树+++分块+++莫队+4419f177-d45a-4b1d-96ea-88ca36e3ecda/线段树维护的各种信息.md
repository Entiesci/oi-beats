# 上帝造题的七分钟 2 / 花神游历各国

## 输入格式

第一行一个整数 $n$，代表数列中数的个数。

第二行 $n$ 个正整数，表示初始状态下数列中的数。

第三行一个整数 $m$，表示有 $m$ 次操作。

接下来 $m$ 行每行三个整数 `k l r`。

- $k=0$ 表示给 $[l,r]$ 中的每个数开平方（下取整）。

- $k=1$ 表示询问 $[l,r]$ 中各个数的和。

**数据中有可能 $l>r$，所以遇到这种情况请交换 $l$ 和 $r$。**

对于 $30\%$ 的数据，$1\le n,m\le 10^3$，数列中的数不超过 $32767$。

对于 $100\%$ 的数据，$1\le n,m\le 10^5$，$1\le l,r\le n$，数列中的数大于 $0$，且不超过 $10^{12}$。

---

是否可以改成pushdown形？？→会有取整问题，**不行**

```C++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
#define ps second
#define pf first
 
 
#define rd read()
inline int read()
{
	int xx=0,ff=1;
	char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') ff=-1;c=getchar();}
	while(c>='0'&&c<='9') xx=xx*10+(c-'0'),c=getchar();
	return xx*ff;
}
inline void write(int out)
{
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int N = 2e6+6;
const int INF=1e9+5;
const int MOD=998244353;
int n,m;
int a[N];
int tag[N];

struct node{
	int sum,mx;
}tr[N];

void pushup(int x){
	tr[x].sum=tr[x<<1].sum+tr[x<<1|1].sum;
	tr[x].mx=max(tr[x<<1].mx,tr[x<<1|1].mx);
}

// void addtag(int x,int tg){
// 	tag[x]+=tg;
// 	int res=tg;
// 	while(res&&tr[x].mx>1){
// 		tr[x].sum=sqrt(tr[x].sum);
// 		tr[x].mx=sqrt(tr[x].mx);
// 		res--;
// 	}
// }

// void pushdown(int x){
// 	addtag(x<<1,tag[x]);
// 	addtag(x<<1|1,tag[x]);
// 	tag[x]=0;
// }

void change(int x,int l,int r,int pl,int pr){
	if(tr[x].mx<2)return ;
	if(l==r){
		// addtag(x,1);
		tr[x].sum=sqrt(tr[x].sum);
		tr[x].mx=sqrt(tr[x].mx);
		return ;
	}
	// pushdown(x);
	int mid=l+r>>1;
	if(pl<=mid)change(x<<1,l,mid,pl,pr);
	if(pr>mid)change(x<<1|1,mid+1,r,pl,pr);
	pushup(x);
}

int query(int x,int l,int r,int pl,int pr){
	if(l>=pl&&r<=pr){
		return tr[x].sum;
	}
	// pushdown(x);
	int mid=l+r>>1;
	int res=0;
	if(pl<=mid)res+=query(x<<1,l,mid,pl,pr);
	if(pr>mid)res+=query(x<<1|1,mid+1,r,pl,pr);
	return res;
}

void build(int x,int l,int r){
	if(l==r){
		tr[x]={a[l],a[l]};
		return ;
	}
	int mid=l+r>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	pushup(x);
}

signed main(){
	n=rd;
	for(int i=1;i<=n;i++){
		a[i]=rd;
	}	
	build(1,1,n);
	m=rd;
	while(m--){
		int k=rd,l=rd,r=rd;
		if(l>r)swap(l,r);
		if(k){
			cout<<query(1,1,n,l,r)<<endl;
		}else{
			change(1,1,n,l,r);
		}
	}
}
```

