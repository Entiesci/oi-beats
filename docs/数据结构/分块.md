# 分块

[TJOI2009] 开关

## 例题 #1

现有 $n$ 盏灯排成一排，从左到右依次编号为：$1$，$2$，……，$n$。然后依次执行 $m$ 项操作。

操作分为两种：

1. 指定一个区间 $[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）；

2. 指定一个区间 $[a,b]$，要求你输出这个区间内有多少盏灯是打开的。

**灯在初始时都是关着的。**

输入格式

第一行有两个整数 $n$ 和 $m$，分别表示灯的数目和操作的数目。

接下来有 $m$ 行，每行有三个整数，依次为：$c$、$a$、$b$。其中 $c$ 表示操作的种类。

- 当 $c$ 的值为 $0$ 时，表示是第一种操作。

- 当 $c$ 的值为 $1$ 时，表示是第二种操作。

$a$ 和 $b$ 则分别表示了操作区间的左右边界。

对于全部的测试点，保证 $2\le n\le 10^5$，$1\le m\le 10^5$，$1\le a,b\le n$，$c\in\{0,1\}$。

## 讲解

我们发现，这道题可以使用线段树完成！但是我们也发现，我们不想写线段树！因为它太长了！于是我们选线段树的替代品——分块！

### 分块！

[549 整除分块（数论分块）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1pP4y127tC/?spm_id_from=333.999.0.0)

注意，数论分块与此处的分块不一样！以上链接指向错误。

OI Wiki的分块是正确的

[分块思想 - OI Wiki](https://oi-wiki.org/ds/decompose/)

我们把一段序列$1\sim n$ 分成$ \lfloor\sqrt{n}\rfloor$份，可以真快修改的就一起修改，负责直接朴素修改。这样子在时间复杂度上会有所让步，但是它的代码简洁易懂，扩展性强。

### 代码

以下为错误代码

```C++
//j0, j1 , jn , y1 , y0 , yn不能用：这是个函数（非常的高级）
#include <bits/stdc++.h>
const int N=1e5+5;
int op[N],kuai[N],n,m,sn;
using namespace std;
void change(int a,int b){
	int p=b-b%sn;
	while((a)%sn){
		op[a]=1-op[a];
		if(op[a])kuai[a/sn]++;
		else kuai[a/sn]--;
		a++;
	}
	while(a<p){
		kuai[a/sn]=sn-kuai[a/sn];
		a+=sn;
	}
	while(a<=b){
		op[a]=1-op[a];
		if(op[a])kuai[a/sn]++;
		else kuai[a/sn]--;
		a++;
	}
	
}
void query(int a,int b){
	int ans=0;
	
	int p=b-b%sn;
	while((a)%sn){
		if(op[a])ans++;a++;
	}
	while(a<p){
		ans+=kuai[a/sn];
		a+=sn;
	}
	while(a<=b){
		if(op[a])ans++;
		a++;
	}
	cout<<ans<<endl;
}
int main(){
	//ios::sync_which_stdio(false);
	cin>>n>>m;
	sn=sqrt(n);
	for(int i=1;i<=m;i++){
		int a,b,c;
		cin>>c>>a>>b;
		if(c==0){
			change(a,b);
		}else{
			query(a,b);
		}
	} 
	return 0;
}

```

## 例题 #2

#### 题目描述

这次的任务是：在伴随着数字改变的情况下，试试统计某段的和。

#### 输入格式

第一行两个整数n和m，表示有一个长度为n个序列和m个操作

接下来m行，每行的内容属于以下一种：

Change x a：把第x个数改成a

Query x y：求出[x,y]这段区间的和。

### 使用分块实现

分块无论修改，还是查询，对于一些题目的答案可能存在的地方，都是由以下几个部分组成的：

- 左边残缺块（暴力枚举）

- 中间整块

- 右边残缺块（暴力枚举）

然后把这些部分的答案merge即可。

### 代码

```C++

const int N = 5e5 + 5;
const int INF = 1e18;
const int M = 1e7;
const int MOD = 1e9 + 7;

int n;
int B;

namespace BD{
    int v[N];
    int bv[N];

    void change(int x,int a){
        bv[x/B]+=a-v[x];
        v[x]=a;
    }  


    int query(int x,int y){
        int res=0;
        if(x/B==y/B){
            for(itn i=x;i<=y;i++){
                res+=v[i];
            }
            return res;
        }

        for(int i=x;i/B==x/B&&i<n;i++){
            res+=v[i];
        }
    
        for(int i=y;i/B==y/B&&i>=0;i--){
            res+=v[i];
        }

        for(itn i=x/B+1;i!=y/B;i++){
            res+=bv[i];
        }


        return res;
    }


    void build(){
        for(int i=0;i<n;i++){
            bv[i/B]+=v[i];
        }
    }
}using namespace BD;

void solve(){
    n=rd;
    int m=rd;
    B=sqrt(n)+1;
    for(itn i=0;i<n;i++){
        v[i]=rd;
    }
    build();
    while(m--){
        string s;
        cin>>s;
        int a=rd,b=rd;
        if(s[0]=='Q'){
            cout<<query(a-1,b-1)<<endl;
        }else{
            change(a-1,b);
        }
    }
}

signed main() {
    // freopen(".in","r",stdin);
    // freopen(".in","w",stdout);

    int T=1;
    while(T--){
    	solve();
    }
    return 0;
}
```

