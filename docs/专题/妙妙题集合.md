# 妙妙题集合

妙妙题指的是：

- 诈骗题

- 依赖“数字范围”的题（注意不是数据范围）已经转移到[基于数字范围的性质](https://flowus.cn/4d3892b3-7262-483b-be26-b859ad56db69)

- 不依赖具体算法（得出结论后暴力可过）

## #2 迎接仪式

目描述

LHX 教主要来 X 市指导 OI 学习工作了。为了迎接教主，在一条道路旁，一群“Orz 教主 er”穿着文化衫站在道路两旁迎接教主，每件文化衫上都印着大字。一旁的 Orzer 依次摆出“欢迎欢迎欢迎欢迎……”的大字，但是领队突然发现，另一旁穿着“教”和“主”字文化衫的 Orzer 却不太和谐。

为了简单描述这个不和谐的队列，我们用 `j` 替代“教”，`z` 替代“主”。而一个 `j` 与 `z` 组成的序列则可以描述当前的队列。为了让教主看得尽量舒服，你必须调整队列，使得 `jz` 子串尽量多。每次调整你可以交换任意位置上的两个人，也就是序列中任意位置上的两个字母。而因为教主马上就来了，时间仅够最多做 $K$ 次调整（当然可以调整不满 $K$ 次），所以这个问题交给了你。

输入格式

第一行，两个正整数 $N, K$，分别表示序列长度与最多交换次数。

第二行，一个长度为 $N$ 的字符串，字符串仅由字母 `j` 与字母 `z` 组成，描述了这个序列。

输出格式

一个非负整数，为调整最多 $K$ 次后最后最多能出现多少个 `jz` 子串。

对于 $10 \%$ 的数据，有 $N \le 10$；
对于 $30 \%$ 的数据，有 $K \le 10$；
对于 $40 \%$ 的数据，有 $N \le 50$；
对于 $100 \%$ 的数据，有 $1 \le N \le 500$，$1 \le K \le 100$。

---

发现“交换”这个操作很难表示，如果是翻转，那么久简单很多。

那么我们就把他当成翻转来做——考虑交换是什么：翻转的特殊例子，即j→z,z→j翻转次数相同。于是我们就可以定义f_{i,j,k,op}为考虑前i为，翻转了j次j，k次z，且翻转后最后一位为op时的最大价值。最后答案从f_{n,i,i,op}中取即可。

```C++
// Problem: P1136 迎接仪式
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1136
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// Challenger: Erica N
// ----
// 
#include<bits/stdc++.h>

using namespace std;
#define rd read()
#define ull unsigned long long
#define int long long 
#define pb push_back
#define itn int
#define ps second 
#define pf first


#define rd read()
int read(){
  int xx = 0, ff = 1;char ch = getchar();
  while (ch < '0' || ch > '9'){
    if (ch == '-')ff = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9')xx = xx * 10 + (ch - '0'), ch = getchar();
  return xx * ff;
}
#define zerol = 1
#ifdef zerol
#define cdbg(x...) do { cerr << #x << " -> "; err(x); } while (0)
void err() {cerr << endl;}
template<template<typename...> class T, typename t, typename... A>
void err(T<t> a, A... x) {
	for (auto v: a) cerr << v << ' ';err(x...);
}
template<typename T, typename... A>
void err(T a, A... x) {
	cerr << a << ' ';err(x...);
}
#else
#define dbg(...)
#endif
const int N=2e5+5;
const ull P=137;
const int INF=1e18+7;
/*

策略



jjj->jzj

zzz->zjz

*/	


int f[505][102][102][2];//（考虑前i个），jjj有j组，zzz有k组，用来k次交换时最多的jz数
string s;



signed main(){
	int n=rd,K=rd;
	cin>>s;
	s=' '+s;
	
	memset(f,-0x3f3f,sizeof f);
	f[0][0][0][1]=0;
	
	for(int i=1;i<=n;i++){
		for(int j=0;j<=K;j++){
			for(int k=0;k<=K;k++){
				if(s[i]=='z'){
					f[i][j][k][1]=max(f[i-1][j][k][0]+1,f[i-1][j][k][1]);
					if(k)f[i][j][k][0]=max(f[i-1][j][k-1][0],f[i-1][j][k-1][1]);
				}else{
					f[i][j][k][0]=max(f[i-1][j][k][1],f[i-1][j][k][0]);
					if(j)f[i][j][k][1]=max(f[i-1][j-1][k][0]+1,f[i-1][j-1][k][1]);
				}
			}
		}
	}
	
	int ans=0;
	for(int i=0;i<=K;i++){
		ans=max(ans,max(f[n][i][i][1],f[n][i][i][0]));
		
	}
	
	
	cout<<ans<<endl;
}


```

## #1 [BOI2007] Sequence 序列问题

对于一个给定的序列 $a _ 1, \cdots, a _ n$，我们对它进行一个操作 $\text{reduce}(i)$，该操作将数列中的元素 $a _ i$ 和 $a _ {i+1}$ 用一个元素 $\max(a _ i,a _ {i+1})$ 替代，这样得到一个比原来序列短的新序列。这一操作的代价是 $\max(a _ i,a _ {i+1})$。进行 $n-1$ 次该操作后，可以得到一个长度为 $1$ 的序列。

我们的任务是计算代价最小的 $\text{reduce}$ 操作步骤，将给定的序列变成长度为 $1$ 的序列。

输入格式

第一行为一个整数 $n$（$1 \leq n \leq 10 ^6$），表示给定序列的长度。

接下来的 $n$ 行，每行一个整数 $a _ i$（$0 \leq a _ i \leq 10 ^ 9$），为序列中的元素。

输出格式

只有一行，为一个整数，即将序列变成一个元素的最小代价。

---

考虑贪心，每次选择max最小的进行合并。

但是这样很难写。实际上，我们可以考虑类似分治的思路：每次找到最大值，然后将其左右两边先合并，最后在和自己合并。因此只需要对每个(i,i+1)取一个max求和即可！

## #3 刻录光盘

题目描述

在JSOI2005夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，又来不及去买了，怎么办呢？！

组委会把这个难题交给了LHC，LHC分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着U盘之类的东西去拷贝啊！

可是，LHC调查后发现，由于种种原因，有些营员并不是那么的合作，他们愿意某一些人到他那儿拷贝资料，当然也可能不愿意让另外一些人到他那儿拷贝资料，这与我们JSOI宣扬的团队合作精神格格不入！！！

现在假设总共有N个营员（2<=N<=200），每个营员的编号为1~N。LHC给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果A愿意把资料拷贝给B，而B又愿意把资料拷贝给C，则一旦A获得了资料，则B，C都会获得资料。

现在，请你编写一个程序，根据回收上来的调查表，帮助LHC计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？

输入格式

先是一个数N，接下来的N行，分别表示各个营员愿意把自己获得的资料拷贝给其他哪些营员。即输入数据的第i+1行表示第i个营员愿意把资料拷贝给那些营员的编号，以一个0结束。如果一个营员不愿意拷贝资料给任何人，则相应的行只有1个0，一行中的若干数之间用一个空格隔开。

输出格式

一个正整数，表示最少要刻录的光盘数。

---

不要考虑在分配时就记录答案，而是先分配完，最后统计答案！（pa_i=i时ans+1）

