## 单调栈简介

单调栈（Monotone Stack）：一种特殊的栈。在栈的「先进后出」规则基础上，要求「从 栈顶 到 栈底 的元素是单调递增（或者单调递减）」。其中满足从栈顶到栈底的元素是单调递增的栈，叫做「单调递增栈」。满足从栈顶到栈底的元素是单调递减的栈，叫做「单调递减栈」。

## 例题 #1

**大意**

给定序列$a$，求每个$a_i$它前面的第二个比他大的数的下标。

---

对于这种问题，我们应该想到使用单调栈来实现。

单调栈只能处理$a_i$前面第一个比他大的数字，那么我们就跑两边单调栈。第一遍记录$a_i$前面第一个比他大的数字，记其下标为$v_i$，第二次我们找到$a_{v_i}$前面第一个比他大的数字，然后我们从$a_1$扫描到$a_n$，输出$a_{v_i}$前面第一个比他大的数字即可。

**Code**

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//头文件
#include<bits/stdc++.h>

//数据类型
#define ll long long
#define ull unsigned long long
#define db double
#define endl '\n'
//命名空间
using namespace std;
//常量
const int N=1e6+5;
const int M=1e6+5;
const int MOD=903250223;
const int INF=1e9;
//变量
int n,b,c,a[N],y[N],tmp,k,cnt,mxr;
int stk[N],ans[N],top;

vector<int> v[N];
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; i++) {
		cin>>a[i];
		while(top&&a[i]>a[stk[top]])top--;
		v[stk[top]].push_back(i);//记录前面第一个比它大的
		stk[++top]=i;
	}
	top=0;//清空栈
	for(int i=1; i<=n; i++) {
		for(int j=0; j<v[i].size(); j++) {
			while(top&&a[v[i][j]]>a[stk[top]])top--;//单调栈
			ans[v[i][j]]=stk[top];//由之前记录的第一个比它大的往前找到第2个比它大的
		}
		stk[++top]=i;
	}
	for(int i=1; i<=n; i++)printf("%d\n",ans[i]+1);
		
#ifdef PAUSE_ON_EXIT
	system("pause");
#endif
	
	return 0;

}

```

