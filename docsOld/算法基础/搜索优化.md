

# 搜索优化

## 迭代加深

[226 迭代加深 Addition Chains_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1UW4y1S7Te/?spm_id_from=333.999.0.0&vd_source=f45ea4e1e4b3b73d5f07c57b46c43aba)

![image.png](搜索优化/image.png)

核心代码

```C++
    int dep=1;
	while(!dfs(1))d++;//一直d++找到找到答案 
	...
```

例题

Addition Chains

**题目描述**

一个与 $n$ 有关的整数加成序列 $<a_0,a_1,a_2,...,a_m>$ 满足以下四个条件：
$1.a_0=1
$$2.a_m=n
$$3.a_0<a_1<a_2<...<a_{m-1}<a_m
$$4.$ 对于每一个 $k(1≤k≤m)$ 都存在有两个整数 $i$ 和 $j(0≤i,j≤k-1,i$ 和 $j$ 可以相等 $)$ ，使得 $a_k=a_i+a_j
$你的任务是：给定一个整数 $n$ ,找出符合上述四个条件的长度最小的整数加成序列。如果有多个满足要求的答案，只需要输出任意一个解即可。
举个例子，序列 $<1,2,3,5>$ 和 $<1,2,4,5>$ 均为 $n=5$ 时的解。

**输入格式**

输入包含多组数据。每组数据仅一行包含一个整数 $n(1≤n≤10000)$ 。在最后一组数据之后是一个 $0$ 。

**输出格式**

对于每组数据，输出一行所求的整数加成序列，每个整数之间以空格隔开。

感谢@Iowa_BattleShip 提供的翻译

**样例 #1**

### 样例输入 #1

```C++
5
7
12
15
77
0
```

### 样例输出 #1

```C++
1 2 4 5
1 2 4 6 7
1 2 4 8 12
1 2 4 5 10 15
1 2 4 8 9 17 34 68 77
```

![image.png](搜索优化/image 1.png)

**代码**

```C++

```

## 剪枝

想必不需要多说了，懂的都懂

#include<bits/stdc++.h>
using namespace std;
const int N=105;

struct node{
int x,y;
};
queue<node>q;

int a[N][N], n, m, ans, d[N][N],vis[N][N];
int fromx, fromy, ansx, ansy;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void bfs() {
d[fromx][fromy] = 0;
vis[fromx][fromy] = 1;
q.push((node){fromx, fromy});
while (q.size()) {
node u = q.front();
q.pop();

```C++
	if(u.x==ansx&&u.y==ansy){
		cout << d[ansx][ansy] << endl;
		return ;
	}

	for (int i = 0; i < 4; i++) {
		int xx = u.x + dx[i], yy = u.y + dy[i];
		if (xx < 1 || xx > n || yy < 1 || yy > m || vis[xx][yy])continue;
		if(!a[xx][yy])continue;
		q.push((node){xx,yy});
		d[xx][yy] = d[u.x][u.y] + 1;
		vis[xx][yy]=1;
	}
}
```

}

int main() {

```C++
cin >> n >> m;

for (int i = 1; i <= n; i++)
	for (int j = 1; j <= m; j++) {
		char c;
		cin >> c;
		if (c == 'S')
			fromx = i, fromy = j;
		if (c == 'T')
			ansx = i, ansy = j;
		if (c == '.' || c == 'S' || c == 'T')
			a[i][j] = 1;
	}
bfs();
return 0;
```

}

## 折半搜索

折半搜索可以让我们用$O(2n^{\frac{k}{2}})$完成O(n^k)的搜索。

具体实现看图

![https://i.loli.net/2018/10/21/5bcc80e9bf36f.png](https://i.loli.net/2018/10/21/5bcc80e9bf36f.png)

[CEOI2015 Day2] 世界冰球锦标赛

题目描述

**译自 [CEOI2015](https://ceoi2015.fi.muni.cz/tasks.php) Day2 T1「[Ice Hockey World Championship](https://ceoi2015.fi.muni.cz/day2/eng/day2task1-eng.pdf)」**

> 今年的世界冰球锦标赛在捷克举行。Bobek 已经抵达布拉格，他不是任何团队的粉丝，也没有时间观念。他只是单纯的想去看几场比赛。如果他有足够的钱，他会去看所有的比赛。不幸的是，他的财产十分有限，他决定把所有财产都用来买门票。

给出 Bobek 的预算和每场比赛的票价，试求：如果总票价不超过预算，他有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。

输入格式

第一行，两个正整数 $N$ 和 $M(1 \leq N \leq 40,1 \leq M \leq 10^{18})$，表示比赛的个数和 Bobek 那家徒四壁的财产。

第二行，$N$ 个以空格分隔的正整数，均不超过 $10^{16}$，代表每场比赛门票的价格。

输出格式

输出一行，表示方案的个数。由于 $N$ 十分大，注意：答案 $\le 2^{40}$。

我们发现如果这里使用普通搜索的话时间复杂度是O(2^n)的，过不去。但是如果使用折半搜索，那么就可以变成$O(2\times 2^{n/2})$，可以过去了。



