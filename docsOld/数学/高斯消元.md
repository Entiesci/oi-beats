高斯消元

# 线性方程组 高斯消元法

[533 线性方程组 高斯消元法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Kd4y127vZ/?spm_id_from=333.999.0.0)

[www.luogu.com.cn](https://www.luogu.com.cn/problem/P3389)

## 题目

给定一个线性方程组，对其求解

### 输入格式

第一行，一个正整数 n

第二至 n+1 行，每行 n+1 个整数，为a1​,a2​⋯an​ 和 b，代表一组方程。

### 输出格式

共 n 行，每行一个数，第 i 行为 xi​ （保留 2 位小数）

如果不存在唯一解，在第一行输出 `No Solution`.

## 铺垫

![image.png](高斯消元/image.png)

我们对方程组进行以上操作。由方程组特性可以得到以下变换结论：

![image.png](高斯消元/image 1.png)

以上三个操作都不会对方程组的解产生影响

## 高斯消元法

![image.png](高斯消元/image 2.png)

消元，懂吧？

**e.g.**

$\begin{cases}a_1x+b_1y=c_1\\a_2x+b_2y=c_2\end{cases}$

针对以上，根据初等行变换，我们可以把下式中的$a_2x$消去（用$下式-n \times 上式$ 即可）

递推到$n$个方程的方程组，也是一样的。虽然我们可能不能将两个方程消到单项式个数相同，但每个之间相差一个是一定可以做到的。

进一步地，我们还可以将消去后的方程组的每一个方程的第一个单项式（我们把这个单项式里的未知数$x$作为这个方程的主元）的系数化为$1$.然后从下往上，依次求解带入上面一个方程，就完工啦！

![image.png](高斯消元/image 3.png)

概括一下，就是

1. 找

2. 换

3. 主元系数变为1

4. 其他方程的该系数变为0

下面就先举例解释：

![image.png](高斯消元/image 4.png)

图

1. 初始状态

2. 从第i=1行问下，寻找第一个“主元$x_1$（第i=1个单项式）系数不为0的方程”并且将它交换到第i=1行

3. 将主元系化为1

4. 将第i=1行下方的方程（或者是说未**处理过的方程**）如果有$x_1$的系数不为0的，就用**变换3**将其系数变为0

5. i=2，重复以上2~4步操作

6. ...

7. ...所有方程组都处理完毕后，从下往上，逐步计算出$x_3,x_2,x_1$的值（从下往上代入）

### 代码

代码如下

```C++
#define db double

db a[N][N];
bool gauss(){
	for(int i=1;i<=n;i++){
		int r=1;//找 
		for(int k=i;k<=n;k++){
			if(a[k][i]!=0){
				r=k;
				break;
			}
		}
		if(k!=i)swap(a[r],a[i])//换
		if(a[i][i]==0.00)return 0;
		
		for(int j=n+1;j>=i;j++){
			a[i][j]/=a[i][i];//变主元系数为1 
		} 
		for(int j=i/此处倒序因为要用到a[j][i],因此循环从n->i,ij为行,k为列,i同时也是第i行主元所在的列 
			if(a[j][i]==0.00)continue;//小小的优化一下 
			for(int k=n=1;j>=i;k--)a[j][k]-=a[j][i]*a[i][k];//变其它数字的系数为0 
		} 
	}
	
	//处理完之后,开始从下往上代回
	for(int i=n-1;i>0;i--){//求x_i 
		for(int j=i/将x_i+1~x_n代入
			a[i][n/减法是移项的结果,原式为xi+a[i][j]*a[j][n+1]=a[i][n+1],xi=a[i][n+1]-a[i][j]*a[j][n+1]
			//a[j][n+1]就存了x_j的值,并且会在之前处理出来 
	}
	return 1; 
}


```

难点解析

```C++
for(int k=n=1;j>=i;k--)a[j][k]-=a[j][i]*a[i][k];//变其它数字的系数为0 
```

`a[j][k]-=a[j][i]*a[i][k]`什么意思??

考察以下方程组

$\begin{cases}x+b_1y=c_1\\ax+b_2y=c_2\end{cases}$

我们怎么样将方程2的第一个单项式系数化为0呢?

当然是将它减去 $n$$ \times 方程1$ 了

那么这个比$n$是多少?

恰恰是`a[j][i]`,即方程组中的$a$（注意，这是因为此时第i=1个方程组的主元系数已经化为了1）

那么对于**方程2**，我们将$a$减去$1\times a$ ，将$b_2$减去$ b_1 \times a $，将$c_2$减去$c_1 \times a$，就相当于将**方程2**减去了$a \times 方程1$，满足变换3



![image.png](高斯消元/image 5.png)

## 高斯-约旦消元法

![image.png](高斯消元/image 6.png)

模拟一下过程

![image.png](高斯消元/image 7.png)

图

1. 和前面的一样

2. 和前面的一样，但此处我们**不需要**将主元系数化为1了

3. i=2，用**方程2**将其他方程的第i=2个单项式的系数化为0（此处凑巧将第3个单项式也化为了0，纯属巧合）.因为在第2步已经把**方程2**的第一项系数化为0，因此不会对已经处理好的**方程1**的**主元项**造成影响。同样，我们**不需要**将主元系数化为1

4. 同3

5. 将$c_i$除以主元的系数，得到的新$c_i$就是方程组的解$x_i$

### 代码

注释：`fabs()`是对于小数的`abs()`

```C++
//变量
long double a[M][M];
int n,b,c,x[N],y[N],ans,res,tmp,cnt,m;

int gauss_jordan(){
    for(int i=1;i<=n;i++){
		int idx=i;
		for(int j=i;j<=m;j++)if(fabs(a[j][i])>fabs(a[idx][i]))idx=j;
		if(fabs(a[idx][i])>1e-10)for(int k=i;k<=n/将当前系数最大的方程交换到第i行
		else continue;//当前主元系数为0
		for(int j=n/=a[i][i];
		for(int j=1;j<=m;j++)if(j!=i){//将其他方程的这一元消去,最后只留下对角线的元
			for(int k=n+1;k>0;k--)a[j][k]-=a[j][i]*a[i][k];
		}
		
		 
	}
	for(int i=1;i<=m;i++){
		int flg=0;
		for(int j=1;j<=n;j++)if(fabs(a[i][j])<1e-10&&fabs(a[i][n/先判无解
		if(flg==n)return -1;
	}
	for(int i=1;i<=n;i++)if(fabs(a[i][i])<1e-10)return 0;//再判多解
	return 1;
}

signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n+1;j++)cin>>a[i][j];
	}
	
	int flg=gauss_jordan();
	if(flg==-1)cout<<"No solutions";
	if(flg==0)cout<<"Many solutions";
	if(flg==1){
		for(int i=1;i<=n;i++)cout<<(int)(a[i][n/printf("%.2Lf\n",a[i][n+1]);
	}
	
	
	return 0;
}

```

**关于一组hack**

```C++
3 3
0 0 1 1 
0 1 0 1
0 1 0 1
```

因此，以下写法是错误的！

```C++
for(int i=1;i<=m;i++)if(fabs(a[i][i])<1e-10&&fabs(a[i][n/先判无解
```

![image.png](高斯消元/image 8.png)

