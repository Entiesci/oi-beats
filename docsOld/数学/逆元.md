# 乘法逆元

若**$ax≡1 \pmod f$**, 则称a（关于1）模f的乘法逆元为x。也可表示为**$ax≡1\pmod f$**。

当a与f互素时，a关于模f的乘法逆元有解。如果不互素，则无解。如果f为素数，则从1到f-1的任意数都与f互素，即在1到f-1之间都恰好有一个关于模f的乘法逆元。

其求法可用**欧几里德算法**：
Extended Euclid (d，f) //算法求d关于模f的乘法逆元d-1 ，即 d* d-1 mod f = 1
1 。(X1，X2，X3) := (1，0，f)； (Y1，Y2，Y3) := (0，1，d)
2。 if (Y3=0) then return d-1 = null //无逆元
3。 if (Y3=1) then return d-1 = Y2 //Y2为逆元
4。 Q := X3 div Y3 //整除
5。 (T1，T2，T3) := (X1 - Q*Y1，X2 - Q*Y2，X3 - Q*Y3)
6 。(X1，X2，X3) := (Y1，Y2，Y3)
7。 (Y1，Y2，Y3) := (T1，T2，T3)
8。 goto 2

```C++
int x,p,a,n,y;
void exgcd(int a,int b,int &x,int &y){
	if(!b)x=1,y=0;
	else exgcd(b,a%b,y,x),y-=a/b*x;
}
signed main() {
	scanf("%d%d",&n,&p);
	for(int i=1;i<=n;i++){
		exgcd(i,p,x,y);
		x=(x%p+p)%p;
		printf("%d\n",x);
	}
	return 0;
}
```

## 定理直接求

求此算法还可以使用**费马小定理**
只不过局限性比较大，要求模数是素数
$a^{p-1} =1\pmod p$
p要求是素数
那么$a^{p-2}$就是a的乘法逆元

## 线性递推

$inv[i]=(p−⌊\frac{i}{p}​⌋×inv[p\%i]\%p)\%p$

```C++
inv[1]=1;
for(int i=2;i<=n;i++){
    inv[i]=(p-p/i)*inv[p%i]%p;
```

