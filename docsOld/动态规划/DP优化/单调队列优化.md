# 决策单调性之 单调队列优化

## [USACO10NOV] Buying Feed G

题目描述

约翰开车来到镇上，他要带$K$吨饲料回家。运送饲料是需要花钱的，如果他的车上有$X$吨饲料，每公里就要花费$X^2$元，开车D公里就需要$D\times  X^2$元。约翰可以从$N$家商店购买饲料，所有商店都在一个坐标轴上，第$i$家店的位置是$X_i$，饲料的售价为每吨$C_i$元，库存为$F_i$。

约翰从坐标$X=0$开始沿坐标轴正方向前进，他家在坐标$X=E$上。为了带$K$吨饲料回家，约翰最少的花费是多少呢？假设所有商店的库存之和不会少于$K$。

举个例子，假设有三家商店，情况如下所示：

|坐标|$X=1$|$X=3$|$X=4$|$E=5$|
|-|-|-|-|-|
|库存|$1$|$1$|$1$||
|售价|$1$|$2$|$2$||

如果$K=2$，约翰的最优选择是在离家较近的两家商店购买饲料，则花在路上的钱是$1+4=5$，花在商店的钱是$2+2=4$，共需要$9$元。

输入格式

第$1$行:三个整数$K,E,N$ 第$2..N+1$行:第$i+1$行的三个整数代表,$X_i,F_i,C_i$.

输出格式

一个整数,代表最小花费

$1 \leq K \leq 10000 , 1 \leq E \leq 500 , 1 \leq N \leq 500$

$0 < Xi < E, 1 \leq Fi \leq 10000, 1 \leq C_i \leq 10^7$

---

### 思路

理解不难。

[Luogu P4544 [USACO10NOV]Buying Feed G - 燃烧的冰块_husky 的博客 - 洛谷博客](https://rsdbk-husky.blog.luogu.org/luogu-p4544-usaco10novbuying-feed-g)


std

```C++
/*
CB Ntsc
*/

#include <algorithm>
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define pf first
#define ps second

#define err cerr<<"Error"
#define rd read()
// #define nl putc('\n')
#define ot write
#define nl putchar('\n')
inline int rd
{
	int xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') xx=xx*10+(ch-'0'),ch=getchar();
	return xx*ff;
}
inline void write(int out)
{
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int INF = 1e13;

const int S=1e6+5;
const int maxlog = 10;

const int N = 510;
const int M = 10010;

template <class T>
inline T min(T a, T b) {
    return a < b ? a : b;
}

struct node {
    int x;
    int w;
    int v;

    node(): x(0), w(0), v(0){}
    node(int x_, int w_, int v_): x(x_), w(w_), v(v_) {}
    inline bool operator < (node &a) {
        return this->x < a.x;
    }
};

node s[N];
int W, n, d[N][M];
int  que[M];

inline int calc(int i, int k) {
    return d[i - 1][k] + (s[i].x - s[i - 1].x) * k * k - s[i].v * k;
}

signed main() {
    int E;
    W=rd,E=rd,n=rd;
    s[0] = node(0, 0, 0);   
    for (int i = 1, x, w, v; i <= n; ++i) {
        x=rd,w=rd,v=rd;
        s[i] = node(x, w, v);
    }
    s[n + 1] = node(E, 0, 0);  
    sort(s, s + n + 2);
    memset(d, 0x3f, sizeof(d));
    d[0][0] = 0;
    for (int i = 1; i <= n + 1; ++i) {   
        int l = 1, r = 0;
        for (int j = 0; j <= W; ++j) {   
            while (calc(i, que[r]) > calc(i, j) && l <= r)
                --r;
            if (j - que[l] > s[i].w && l <= r)
                ++l;
            que[++r] = j;
            d[i][j] = calc(i, que[l]) + s[i].v * j;           
        }
    }
    printf("%lld", d[n + 1][W]);
}

/*
2 5
0 1 1 1 1
0 1 1 2 4
0 2 1 2 1
0 2 1 1 4
*/
```

## [CSP-S2019] 划分

题目描述

2048 年，第三十届 CSP 认证的考场上，作为选手的小明打开了第一题。这个题的样例有 $n$ 组数据，数据从 $1 \sim n$ 编号，$i$ 号数据的规模为 $a_i$。

小明对该题设计出了一个暴力程序，对于一组规模为 $u$ 的数据，该程序的**运行时间**为 $u^2$。然而这个程序运行完一组规模为 $u$ 的数据之后，它将在任何一组规模**小于** $u$ 的数据上运行错误。样例中的 $a_i$ 不一定递增，但小明又想在不修改程序的情况下正确运行样例，于是小明决定使用一种非常原始的解决方案：将所有数据划分成若干个数据段，段内数据编号**连续**，接着将同一段内的数据合并成新数据，其规模等于段内原数据的**规模之和**，小明将让新数据的规模能够递增。

也就是说，小明需要找到一些分界点 $1 \leq k_1 \lt k_2 \lt \cdots \lt k_p \lt n$，使得

$\sum_{i=1}^{k_1} a_i \leq \sum_{i=k_1+1}^{k_2} a_i \leq \cdots \leq \sum_{i=k_p+1}^{n} a_i$

注意 $p$ 可以为 $0$ 且此时 $k_0 = 0$，也就是小明可以将所有数据合并在一起运行。

小明希望他的程序在正确运行样例情况下，运行时间也能尽量小，也就是**最小化**

$(\sum_{i=1}^{k_1} a_i)^2 + (\sum_{i=k_1+1}^{k_2} a_i)^2 + \cdots + (\sum_{i=k_p+1}^{n} a_i)^2$

小明觉得这个问题非常有趣，并向你请教：给定 $n$ 和 $a_i$，请你求出最优划分方案下，小明的程序的最小运行时间。

输入格式

**由于本题的数据范围较大，部分测试点的 $a_i$ 将在程序内生成。**

第一行两个整数 $n, type$。$n$ 的意义见题目描述，$type$ 表示输入方式。

1. 若 $type = 0$，则该测试点的 $a_i$ **直接给出**。输入文件接下来：第二行 $n$ 个以空格分隔的整数 $a_i$，表示每组数据的规模。

2. 若 $type = 1$，则该测试点的 $a_i$ 将**特殊生成**，生成方式见后文。输入文件接下来：第二行六个以空格分隔的整数 $x, y, z, b_1, b_2, m$。接下来 $m$ 行中，第 $i (1 \leq i \leq m)$ 行包含三个以空格分隔的正整数 $p_i, l_i, r_i$。

对于 $type = 1$ 的 23~25 号测试点，$a_i$ 的生成方式如下：

给定整数 $x, y, z, b_1, b_2, m$，以及 $m$ 个三元组 $(p_i, l_i, r_i)$。

保证 $n \geq 2$。若 $n \gt 2$，则 $\forall 3 \leq i \leq n, b_i = (x \times b_{i−1} + y \times b_{i−2} + z) \mod 2^{30}$。

保证 $1 \leq p_i \leq n, p_m = n$。令 $p_0 = 0$，则 $p_i$ 还满足 $\forall 0 \leq i \lt m$ 有 $p_i \lt p_{i+1}$。

对于所有 $1 \leq j \leq m$，若下标值 $i (1 \leq i \leq n)$满足 $p_{j−1} \lt i \leq p_j$，则有

$a_i = \left(b_i \mod \left( r_j − l_j + 1 \right) \right) + l_j$

**上述数据生成方式仅是为了减少输入量大小，标准算法不依赖于该生成方式。**

输出格式

输出一行一个整数，表示答案。

【数据范围】

|测试点编号|$n \leq$|$a_i \leq$|$type =$|
|-|-|-|-|
|$1 \sim 3$|$10$|$10$|0|
|$4 \sim 6$|$50$|$10^3$|0|
|$7 \sim 9$|$400$|$10^4$|0|
|$10 \sim 16$|$5000$|$10^5$|0|
|$17 \sim 22$|$5 \times 10^5$|$10^6$|0|
|$23 \sim 25$|$4 \times 10^7$|$10^9$|1|

对于$type=0$的所有测试点,保证最后输出的答案$\leq 4 \times 10^{18}$

所有测试点满足：$type \in \{0,1\}$，$2 \leq n \leq 4 \times 10^7$，$1 \leq a_i \leq 10^9$，$1 \leq m \leq 10^5$，$1 \leq l_i \leq r_i \leq 10^9$，$0 \leq x,y,z,b_1,b_2 \lt 2^{30}$。

### 思路

[csps19~22](https://flowus.cn/c0c07e2e-266f-47bc-814b-1417a1954cac)

