# 多重背包

### 思想

类似完全背包，只不过k循环，枚举第i件物品取k份的条件改变了

### 注意

观察`f[i][j]`中保存的信息和题目，我们**不可以**把k循环去掉，请思考！

## 例题 #1

第一行二个数n(n≤500)，m(m≤6000)，其中n代表希望购买的奖品的种数，m表示拨款金额。

接下来n行，每行3个数，v、w、s，分别表示第I种奖品的价格、价值（价格与价值是不同的概念）和能购买的最大数量（买0件到s件均可），其中v≤100，w≤1000，s≤10。
求此次购买能获得的最大的价值（注意！不是价格）。

解决

```C++
#include <bits/stdc++.h>
using namespace std;
int m, n, w[10005], c[10005], f[10005], s[10005];

int main() {
	cin >> n >> m ;
	for (int i = 1; i <= n; i++)
		cin >> c[i] >> w[i] >> s[i];
	for (int i = 1; i <= n; i++) {
		for (int j = m; j >= 0; j--)
			for (int k = 0; k <= s[i]; k++) {
				if (j - k * c[i] < 0)
					break;
				f[j] = max(f[j], f[j - k * c[i]] + k * w[i]);
			}
	}

	cout << f[m];
	return 0;
}
```

## 例题 #2 [BalticOI 2022 Day1] Uplifting Excursion

题目描述

有 $2m+1$ 种物品，重量分别为 $-m,-m+1,\ldots, m-1,m$。重量为 $i$ 的物品有 $a_i$ 个。

你需要拿走若干物品，使得这些物品重量之和恰好为 $l$。在此基础上，你需要拿尽可能多的物品。

问在物品重量之和恰好为 $l$ 的基础上，你最多能拿多少物品。

### 思路

我们考虑这道题，应该就是一道背包的题目.但是同时我们发现，有一些物品的重量是可以抵消的，所以我们应该先选中这些物品。

好了，现在我们还有一些物品，以及一个需要被填满的，容量为l的且当前为空的背包。这里我们关注到一点，就是我们刚才的贪心枚举其实不一定正确——为了这里我们恰好填满容量为l的背包，我们可能不得不从用来抵消背包容量的物品（即重量为负的物品）中剔除一部分，以便于我们可以达到l的总重量。

我们发现，l实在是太大了，所以我们还可以继续地多拿一些物品。事实上，因为我们的l太大了，我们应该考虑如何减小这个值域。

为了避免分类讨论，我们可以在一开始就把所有物品取下，设所有物品的重量和为s，若s>l，那么我们每次选中最大的数删除，直到s≤l。这里我们注意到每个物品的价值都是1，所以这样的贪心是正确的。

若s<l，那么我们就从最小的开始删除即可，直到再删可能导致s>l为止。

操作完后我们发现，现在背包还剩余的空间是<m的！现在我们看似就可以进行背包了。我们要考虑反悔操作。

我们给已经选择的物品赋负重量和负价值，没有选择的物品直接加入，然后跑多重背包即可。

### 代码

这里我们狠狠地指出，要弄明白偏移量和边界。（调了2小时）

```C++
/*                                                                                
                      Keyblinds Guide
     				###################
      @Ntsc 2024

      - Ctrl+Alt+G then P : Enter luogu problem details
      - Ctrl+Alt+B : Run all cases in CPH
      - ctrl+D : choose this and dump to the next
      - ctrl+Shift+L : choose all like this
	  
*/
#include <bits/stdc++.h>
#include <queue>
using namespace std;

#define rep(i, l, r) for (int i = l, END##i = r; i <= END##i; ++i)
#define per(i, r, l) for (int i = r, END##i = l; i >= END##i; --i)
#define pb push_back
#define mp make_pair
#define int long long
#define pii pair<int, int>
#define ps second
#define pf first

// #define innt int
// #define inr int
// #define mian main
// #define iont int

#define rd read()
int read(){
    int xx = 0, ff = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
		if (ch == '-')
			ff = -1;
		ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
      xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}
void write(int out) {
	if (out < 0)
		putchar('-'), out = -out;
	if (out > 9)
		write(out / 10);
	putchar(out % 10 + '0');
}

const char el='\n';
const bool enable_dbg = 0;
template <typename T,typename... Args>
void dbg(T s,Args... args) {
	if constexpr (enable_dbg){
    cerr << s << ' ';
		if constexpr (sizeof...(Args))
			dbg(args...);
	}
}

const int N = 3e5 + 5;
const int INF = 1e18;
const int M = 1e5;
const int MOD = 1e9 + 7;



int used[N];
struct node{
    int w,v;
}o[N];
int ans,f[2][N],cnt;
int n,m,l,a[N];
int sum;

void ins(int x){
    int b=1;
    int cur=a[x]-used[x],w=x-m;
    dbg(x,cur);
    while(cur){
        if(b>cur)b=cur;//注意，只需要一次2^k，剩下的直接原数加入，不需要再二进制分解
        o[++cnt]={w*b,b};
        cur-=b;
        b<<=1;
    }
    cur=used[x];
    b=1;
    while(cur){
        if(b>cur)b=cur;
        o[++cnt]={-w*b,-b};
        cur-=b;
        b<<=1;
    }
}

void solve(){
    m=rd,l=rd;
    for(int i=0;i<=m*2;i++){
        a[i]=rd;
        if(i>m)continue;
        sum+=a[i]*(i-m);
        used[i]=a[i];
        ans+=a[i];
    }
    for(int i=m+1;i<=2*m;i++){//优先加入小的
        int num=min((l-sum)/(i-m),a[i]);
        used[i]=num;
        ans+=num;
        sum+=num*(i-m);
    }
    for(int i=0;i<m;i++){//优先删小的,0不需要考虑
        int num=min((l-sum)/(m-i),a[i]);
        used[i]-=num;
        ans-=num;
        sum-=num*(i-m);
    }
    if(l-sum>m){
        puts("impossible");
        return ;
    }

    dbg("ok");

    for(int i=0;i<=2*m;i++){
        if(i==m)continue;
        ins(i);
    }
    // dbg("ok");

    //WA below

    // memset(f,-0x3f,sizeof f);
    // f[0][M]=0;
    // for(int i=1;i<=cnt;i++){
    //     for(int j=M+m;j>=M-m;j--){
    //         f[i&1][j]=f[i&1^1][j];
    //         if(j>=o[i].w && j - o[i].w < N)
    //             f[i&1][j]=max(f[i&1][j],f[i&1^1][j-o[i].w]+o[i].v);
    //     }
    // }

	memset(f, -0x3f, sizeof f);
	f[0][M] = 0;
	for (int i=1;i<=cnt;i++){
		for (int j=M+m*m;j>=0;j--)//注意边界（调了2hrs TT）
		{
			f[i&1][j]=f[(i-1)&1][j];
			if(j>=o[i].w&&j-o[i].w<=M+m*m)f[i&1][j]=max(f[i&1][j],f[(i-1)&1][j-o[i].w]+o[i].v);
		}
    }
		
    if(f[cnt&1][l-sum+M]+ans<0)puts("impossible");
    else cout<<f[cnt&1][l-sum+M]+ans<<endl;


}   

signed main() {
    int T=1;
    while(T--){
    	solve();
    }
    return 0;
}
```

对于所有数据，满足 $1\leq m \leq 300$，$-10^{18}\le l \le 10^{18}$，$0\le a_i\le 10^{12}$。

