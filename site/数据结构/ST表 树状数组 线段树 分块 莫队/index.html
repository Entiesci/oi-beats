
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../%E6%95%B0%E5%AD%A6/%E9%80%86%E5%85%83%20%E7%AD%9B%20%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B%20%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/">
      
      
        <link rel="next" href="../%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.28">
    
    
      
        <title>ST表 树状数组 线段树 分块 莫队 - OI Beats</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6543a935.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://unpkg.com/katex@0/dist/katex.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="deep-orange">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="OI Beats" class="md-header__button md-logo" aria-label="OI Beats" data-md-component="logo">
      
  <img src="../../images/logo.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            OI Beats
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              ST表 树状数组 线段树 分块 莫队
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OI Beats" class="md-nav__button md-logo" aria-label="OI Beats" data-md-component="logo">
      
  <img src="../../images/logo.svg" alt="logo">

    </a>
    OI Beats
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    动态规划
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            动态规划
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%20DP%E4%BC%98%E5%8C%96/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DP DP优化
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%20%E5%85%A5%E9%97%A8%E5%85%B8%E4%BE%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DP 入门典例
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%20%E6%A0%91%E5%9E%8B%20%E7%8A%B6%E5%8E%8B%20%E5%80%8D%E5%A2%9E/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DP 树型 状压 倍增
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DP 背包问题
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    图论
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            图论
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/tarjan%20%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tarjan 算法相关
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE%20%E4%BA%8C%E9%83%A8%E5%9B%BE%E9%97%AE%E9%A2%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二分图 二部图问题
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    图论基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E5%AD%98%E5%9B%BE%20%E6%9C%80%E7%9F%AD%E8%B7%AF%20%E8%B4%9F%E7%8E%AF/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    存图 最短路 负环
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E6%A0%91%E4%B8%8A%E7%A5%96%E5%85%88%20LCA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    树上祖先 LCA
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E7%94%9F%E6%88%90%E6%A0%91%20%E5%9F%BA%E7%8E%AF%E6%A0%91/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    生成树 基环树
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    网络流
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E9%AB%98%E7%BA%A7%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高级线性数据结构
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    字符串
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            字符串
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%93%88%E5%B8%8C%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%88%E4%BB%8E%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0KMP%E5%86%8D%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    哈希 字符串匹配（从字典树到KMP再到AC自动机）
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%AD%97%E7%AC%A6%E4%B8%B2/%E9%AB%98%E7%B2%BE%E5%BA%A6%20%E5%BF%AB%E8%AF%BB%E5%BF%AB%E8%BE%93/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高精度 快读快输
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%AD%97%E7%AC%A6%E4%B8%B2/%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高级字符串算法
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    数学
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            数学
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E4%BA%8C%E5%88%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二分
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E5%8D%9A%E5%BC%88%E8%AE%BA%20SG%E5%87%BD%E6%95%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    博弈论 SG函数
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E5%8E%9F%E6%A0%B9%20%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    原根 拉格朗日插值 莫比乌斯反演
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E5%BF%AB%E9%80%9F%E5%B9%82%20%E7%9F%A9%E9%98%B5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    快速幂 矩阵
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%AE%9A%E7%90%86%20%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数学定理 线性代数
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%20%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%20%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    组合计数 高斯消元 容斥原理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    计算几何
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E9%80%86%E5%85%83%20%E7%AD%9B%20%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B%20%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    逆元 筛 不定方程 扩展欧几里得
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" checked>
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    数据结构
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            数据结构
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    ST表 树状数组 线段树 分块 莫队
  </span>
  

      </a>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二叉查找树与平衡树
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%B9%B6%E6%9F%A5%E9%9B%86%20%E6%89%A9%E5%B1%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    并查集 扩展
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%BA%A7%E3%81%AE%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高级の树上问题
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_5" >
        
          
          <label class="md-nav__link" for="__nav_6_5" id="__nav_6_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    【】专题+++ST表+++树状数组+++线段树+++分块+++莫队+4419f177 d45a 4b1d 96ea 88ca36e3ecda
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_6_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6_5">
            <span class="md-nav__icon md-icon"></span>
            【】专题+++ST表+++树状数组+++线段树+++分块+++莫队+4419f177 d45a 4b1d 96ea 88ca36e3ecda
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%90%84%E7%A7%8D%E4%BF%A1%E6%81%AF/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    上帝造题的七分钟 2 / 花神游历各国
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    算法基础
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            算法基础
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E7%94%9F%E5%83%BBSTL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++关键字与生僻STL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/Head%2B%2B%2B%E6%A8%A1%E6%9D%BF%E5%A4%B4%2B%E7%BC%BA%E7%9C%81%E6%BA%90%2B2882b258-98b6-47da-be53-6525b90e8dae/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Head+++模板头+缺省源+2882b258 98b6 47da be53 6525b90e8dae
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%B7%AE%E5%88%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前缀和 差分
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%A6%82%E5%BF%B5%20%E6%A6%82%E5%BF%B5%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    概念 概念性
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%B4%AA%E5%BF%83/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    贪心
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%80%92%E5%BD%92%20%E9%80%92%E6%8E%A8%20%E6%B7%B1%E6%90%9C%20%E5%B9%BF%E6%90%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    递归 递推 深搜 广搜
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    算法策略
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            算法策略
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E7%AD%96%E7%95%A5/%E5%88%86%E6%B2%BB%20%E6%8E%92%E5%BA%8F%20%E5%81%8F%E5%BA%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    分治 排序 偏序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E7%AD%96%E7%95%A5/%E5%90%AF%E5%8F%91%E5%BC%8FA_%20IDA_/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    启发式A  IDA 
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E7%AD%96%E7%95%A5/%E6%80%9D%E6%83%B3%20%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95%20%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    思想 爬山算法 模拟退火
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p>【】专题 | ST表、树状数组、线段树、分块等</p>
<h1 id="_1">目录</h1>
<ul>
<li>
<p>ST表</p>
</li>
<li>
<p>树状数组</p>
</li>
<li>
<p>线段树</p>
</li>
<li>
<p>分块</p>
<ul>
<li>
<p>莫队</p>
</li>
<li>
<p>块状链表</p>
</li>
</ul>
</li>
<li>
<p>跳跃表</p>
</li>
</ul>
<p><a href="https://flowus.cn/9af226b7-ae12-4c19-9c89-e5bf91d5864b">线段树合并/分裂/分治及其他扩展</a></p>
<p><a href="https://flowus.cn/e6bba820-32e4-4b67-900b-728465fbe751">线段树扩展形式</a></p>
<p><a href="%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98+++ST%E8%A1%A8+++%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84+++%E7%BA%BF%E6%AE%B5%E6%A0%91+++%E5%88%86%E5%9D%97+++%E8%8E%AB%E9%98%9F+4419f177-d45a-4b1d-96ea-88ca36e3ecda/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%90%84%E7%A7%8D%E4%BF%A1%E6%81%AF%20e97ee10c-3cdf-4255-9947-21b38a8ca0cc.md">线段树维护的各种信息</a></p>
<h1 id="st">ST表</h1>
<p><a href="https://blog.csdn.net/weixin_43914593/article/details/109500135">https://blog.csdn.net/weixin_43914593/article/details/109500135</a></p>
<h2 id="1">例题 #1</h2>
<p>这是一道 ST 表经典题——静态区间最大值</p>
<p>题目描述</p>
<p>给定一个长度为 <span class="arithmatex">\(N\)</span> 的数列，和 <span class="arithmatex">\(M\)</span> 次询问，求出每一次询问的区间内数字的最大值。</p>
<p>对于 <span class="arithmatex">\(100\%\)</span> 的数据，满足 <span class="arithmatex">\(1\le N\le {10}^5\)</span>，<span class="arithmatex">\(1\le M\le 2\times{10}^6\)</span>，<span class="arithmatex">\(a_i\in[0,{10}^9]\)</span>，<span class="arithmatex">\(1\le l_i\le r_i\le N\)</span>。</p>
<h2 id="_2">讲解</h2>
<h3 id="_3">代码</h3>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 4e5+5;
int n, st[N][20], lg2[N], m, a, b;

void pre() {
    for (int j = 1; j &lt;= 18; j++)
        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++)
            st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]);

}

int main() {

    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    lg2[0] = -1;
    for (int i = 1; i &lt;= n; i++)
        lg2[i] = lg2[i / 2] + 1;

    for (int i = 1; i &lt;= n; i++) {
        scanf(&quot;%d&quot;,&amp;st[i][0]);
    }
    pre();
    while (m--) {
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        int k = lg2[b - a + 1];
        printf(&quot;%d\n&quot;,max(st[a][k], st[b - (1 &lt;&lt; k) + 1][k]));
    }

    return 0;
}
</code></pre>
<h2 id="_4">练习</h2>
<p><a href="https://flowus.cn/29ab2baa-d32f-40d9-8b33-975890c63e56">超级钢琴</a></p>
<h1 id="_5">树状数组</h1>
<p>再次强调，树状数组的change是<strong>单点加</strong>！！</p>
<p><a href="https://blog.csdn.net/weixin_43914593/article/details/107842628">https://blog.csdn.net/weixin_43914593/article/details/107842628</a></p>
<p><a href="https://ntsc-yrx.github.io/2022/07/09/CPP%E8%BF%9B%E9%98%B6-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">https://ntsc-yrx.github.io/2022/07/09/CPP%E8%BF%9B%E9%98%B6-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</a></p>
<h2 id="1_1">例题 #1</h2>
<p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ul>
<li>
<p>将某一个数加上 <span class="arithmatex">\(x\)</span></p>
</li>
<li>
<p>求出某区间每一个数的和</p>
</li>
</ul>
<p>对于 <span class="arithmatex">\(30\%\)</span> 的数据，<span class="arithmatex">\(1 \le n \le 8\)</span>，<span class="arithmatex">\(1\le m \le 10\)</span>；
对于 <span class="arithmatex">\(70\%\)</span> 的数据，<span class="arithmatex">\(1\le n,m \le 10^4\)</span>；
对于 <span class="arithmatex">\(100\%\)</span> 的数据，<span class="arithmatex">\(1\le n,m \le 5\times 10^5\)</span>。</p>
<p>样例说明：</p>
<p>故输出结果14、16</p>
<h2 id="_6">讲解</h2>
<h3 id="_7">实现方法</h3>
<p><img alt="image.png" src="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/image.png" /></p>
<h3 id="lowbitx">关键函数 <code>lowbit(x)</code></h3>
<pre><code class="language-C++">lowbit(x){return x&amp;-x}
</code></pre>
<p><strong>作用：</strong> 返回最后一位1的位置</p>
<p><strong>e.g.</strong> 对<code>(11010)2</code>执行<code>lowbit</code>返回值为<code>(10)2</code>.
<code>x-lowbit(x)</code>操作可快速消去最后一位1</p>
<h3 id="changexv"><code>change(x,v)</code></h3>
<p>在树状数组意义下对x位置进行单点加v。</p>
<h3 id="queryx"><code>query(x)</code></h3>
<p>返回[1,x]的权值和。</p>
<h3 id="_8">应用</h3>
<p>维护区间加，单点修改</p>
<p>这时我们应该使用change来维护差分数组并且使用query快速求出前缀和。</p>
<p>不可使用change来区间加而query(x)-query(x-1)，因为它根本没这功能！！</p>
<h3 id="_9">代码</h3>
<pre><code class="language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std;


const int N=5e5+5;
//typedef long long ll;
int n,m,x,y;
int c[N];
int a;


int lowbit(int x) {
    return x&amp;-x;
}


void add(int i,int x) {//在位置i加上x
    while(i&lt;=N) {
        c[i]+=x;
        i+=lowbit(i);
    }
}


int sum(int x) {
    int res=0;
    while(x) {
        res+=c[x];
        x-=lowbit(x);
    }
    return res;
}
int main() {
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1; i&lt;=n; i++){
        cin&gt;&gt;a;
        add(i,a);
    }
        //scanf(&quot;%d&quot;,&amp;a[i]);
    while(m--) {
        int op;
        scanf(&quot;%d%d%d&quot;,&amp;op,&amp;x,&amp;y);
        if(op==2)
            printf(&quot;%d\n&quot;,sum(y)-sum(x-1)); //sum(i)求的是a[i]~a[1]的和！！
        else {
            add(x,y);
        }
    }
    return 0;
}
</code></pre>
<h1 id="_10">线段树</h1>
<p><em>董晓导师的第一堂课！</em></p>
<p><a href="https://blog.csdn.net/weixin_43914593/article/details/108221534">https://blog.csdn.net/weixin_43914593/article/details/108221534</a></p>
<p><a href="https://ntsc-yrx.github.io/2022/07/09/CPP%E8%BF%9B%E9%98%B6-%E7%BA%BF%E6%AE%B5%E6%A0%91/">https://ntsc-yrx.github.io/2022/07/09/CPP%E8%BF%9B%E9%98%B6-%E7%BA%BF%E6%AE%B5%E6%A0%91/</a></p>
<p><strong>线段树</strong></p>
<p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。
使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为<span class="arithmatex">\(O(log N)\)</span>。而未优化的空间复杂度为<span class="arithmatex">\(2N\)</span>，实际应用时一般还要开<span class="arithmatex">\(4N\)</span>的数组以免越界，因此有时需要离散化让空间压缩。</p>
<p><strong>实现</strong></p>
<p>我们看到下图。这是一颗1~8的线段树。</p>
<p>对于最基本的线段树，我们需要支持以下几个操作。</p>
<ul>
<li>
<p>query 查询</p>
</li>
<li>
<p>change 修改</p>
</li>
</ul>
<p>我们先来看第一个问题：如何使用线段树单点修改，区间求和？</p>
<p>举个例子。我们需要将[3,3]增加a，我们要做哪些事情呢？</p>
<p>答案是：我们需要将从[3,3]到根节点的连上的每一个节点都增加a，对不对？</p>
<p>那么我们就可以开始实现了。已知线段树是一颗完全二叉树，i的左儿子就是2i,右儿子就是2i+1.</p>
<p>我们需要写出下面的代码
(我们将线段树存在数组tree[]中，大小应该开到节点数最大值的4倍)</p>
<pre><code class="language-C++">void change(int now,int l,int r,int goal,int v){

}
</code></pre>
<p>因为修改是递归实现的，我们需要传入下列参数：</p>
<ul>
<li>
<p>当前所处在的位置（数组下标）</p>
</li>
<li>
<p>当前节点的l，r（当然我们可以把这两个信息存在当前节点中，开一个结构体。我们也可以类似上面代码一样直接传下去）</p>
</li>
<li>
<p>目标节点</p>
</li>
<li>
<p>要更改的值</p>
</li>
</ul>
<p>好的，接下来我们要做什么呢？
我们的递归起点是</p>
<pre><code class="language-C++">change(1,1,n,goal,v)
</code></pre>
<p>往下
我们要不断二分向下查找我们要修改的那个点，当然如果已经找到了就可以return了</p>
<pre><code class="language-C++">void change(int now,int l,int r,int goal,int v){
    if(now=goal){
        tree[now]+=v;return;
    }
    int mid=(l+r)/2;
    if(goal&lt;=mid)change(now&lt;&lt;1,l,mid,goal,v);
    else change(now&lt;&lt;1|1,mid+1,r,goal,v);   //now&lt;&lt;1相当于now*2,因为now乘了2，所以二进制下他最后一位一定是0，此时再 |1就等效于+1

}
</code></pre>
<p>找到了目标点，修改了，可是链上的其它点也要修改啊，怎么办呢？
没事，我们从下往上修改，因为儿子都修改了，父亲村的是他儿子的和，只需要更新一边即可。</p>
<p>我们另外写一个<code>pushup()</code>函数来实现。因为这个函数要复用，因此写成函数更加简洁</p>
<pre><code class="language-C++">void pushup(int now){
    tree[now]=tree[now&lt;&lt;1]+tree[now&lt;&lt;1|1];
}
void change(int now,int l,int r,int goal,int v){
    if(now=goal){
        tree[now]+=v;return;
    }
    int mid=(l+r)/2;
    if(goal&lt;=mid)change(now&lt;&lt;1,l,mid,goal,v);
    else change(now&lt;&lt;1|1,mid+1,r,goal,v);   //now&lt;&lt;1相当于now*2,因为now乘了2，所以二进制下他最后一位一定是0，此时再 |1就等效于+1
    pushup(now);
}
</code></pre>
<p>这样子我们的单点修改操作就实现了。
查询呢？我们要区间查询和怎么办？</p>
<p>举个例子。我们要查询区间[2,8]的和，朴素算法我们需要把[2,2],[3,3]...[8,8]全部加起来
但我们有线段树呀！
可以发现，我们只需要把[2,2][3,4][5,8]加起来就可以了！！</p>
<p>代码框架</p>
<pre><code class="language-C++">int query(int now,int l,int r,int goall,int goalr){

}


</code></pre>
<p>我们求区间和时也需要用到递归。我们需要以下参数</p>
<ul>
<li>
<p>当前所处在的位置（数组下标）</p>
</li>
<li>
<p>当前节点的l，r（当然我们可以把这两个信息存在当前节点中，开一个结构体。我们也可以类似上面代码一样直接传下去）</p>
</li>
<li>
<p>目标区间goall,goalr</p>
</li>
</ul>
<p>当我们递归到一个节点时，他会出现下面的情况</p>
<ul>
<li>
<p>l，r在goall,goalr中</p>
</li>
<li>
<p>r在mid右侧或左侧</p>
</li>
<li>
<p>l在mid右侧或左侧</p>
</li>
</ul>
<p>针对第一种情况，我们直接返回当前节点的值即可，不需要继续向下
针对第二种情况，我们要向他的右儿子递归
针对第3种情况，我们要向他的左儿子递归</p>
<pre><code class="language-C++">int query(int now,int l,int r,int goall,int goalr){
    if(goall&lt;=l&amp;&amp;goalr&gt;=r)return tree[now];
    else {
    int res=0,mid=(l+r)/2;
        if(goall&lt;=mid)res+=query(now&lt;&lt;1,l,mid,goall,goalr);
       if(goalr&gt;mid)res+=query(now&lt;&lt;1|1,mid+1,r,goall,goalr);
    }
    return res;
}

</code></pre>
<p>yeah我们的单点修改，区间查询的线段树就结束了。</p>
<hr />
<p>但是我们需要区间修改，区间查询怎么办呢？
让我们来解决这个问题。 我们需要在修改函数进行处理</p>
<pre><code class="language-C++">void pushup(int now){
    tree[now]=tree[now&lt;&lt;1]+tree[now&lt;&lt;1|1];
}
void change(int now,int l,int r,int goall,goalr,int v){
    if(l==r){
        tree[now]+=v;return;
    }
    int mid=(l+r)/2;
    if(goall&lt;=mid)change(now&lt;&lt;1,l,mid,goall,goalr,v);
    if(goalr&gt;mid)change(now&lt;&lt;1|1,mid+1,r,goall,goalr,v);    //now&lt;&lt;1相当于now*2,因为now乘了2，所以二进制下他最后一位一定是0，此时再 |1就等效于+1
    pushup(now);
}
</code></pre>
<p>此刻我们发现，我们修改一个长度为n的区间，最少要修改2n+1个点。可是我们在查询的时候也许压根用不到这些点，我们没必要进行修改。
因此，我们就使用一个懒标记技术(lazy-tag)。</p>
<p><strong>懒标记</strong></p>
<p>在线段树中会遇到区间更新的情况，例如 在区间求和问题中，令[a,b]区间内的值全部加c，若此时再采用单点更新的方法，就会耗费大量时间，这个时候就要用到懒标记来进行区间更新了。</p>
<p>懒标记（lazy-tag），又叫做延迟标记，举例说明。</p>
<p>设 当前结点对应区间[l, r]，待更新区间[a, b]
　当 a ≤ l ≤ r ≤ b，即 [l, r]∈[a,b]时，不再向下更新，仅更新当前结点，并在该结点加上懒标记，当必须得更新/查询该结点的左右子结点时，再利用懒标记的记录向下更新（pushdown)——懒标记也要向下传递，然后移除该结点的懒标记。</p>
<p>这样就不用每次都更新到叶子结点，减少了大量非必要操作，从而优化时间复杂度。</p>
<p>因此，我们要多开一个数组tag[]，tag[i]用来存储i节点的标记。</p>
<p>注意，tag最好满足可合并性。例如我们在tag中存每个点要增加的值t，后来我们又打了第2个标记，每个点增加s。此时它满足可合并性，我们只要把原来的tag加上s就可以了。如果不可以合并，我们就需要先把这个点的tag下传，然后再清零，赋新值。</p>
<p><strong>实现细节</strong>
当我们要修改[goall,goalr]区间的值，如果在递归中找到一个节点代表的区间被[goall,goalr]包含在内，那么我们修改这个节点的值，打上tag，就不需要向下递归了。（大陆tag的点已经修改过了）</p>
<p>当我们查询一个区间[goall,goalr]时，走到一个点，发现，欸，有tag！我们就把标记下传，按标记修改两儿子的值，然后清零自己的标记。</p>
<p>代码：</p>
<pre><code class="language-C++">
void pushup(int p) {
    val[p] = val[p &lt;&lt; 1] + val[p &lt;&lt; 1 | 1];
}
void addtag(int p, int l, int r, int t) {
    val[p] += (r-l+1) * t;
    tag[p] += t;
}
void pushdown(int p, int l, int r) {
    if(!tag[p]) return ;
    int t = tag[p], mid = l+r&gt;&gt;1;
    addtag(p&lt;&lt;1, l, mid, t); addtag(p&lt;&lt;1|1, mid+1, r, t);
    tag[p] = 0;
}
void change(int p, int l, int r, int ql, int qr, int k) {
    if(ql &lt;= l &amp;&amp; r &lt;= qr) {
        addtag(p, l, r, k);
        return ;
    }
    int mid = l+r &gt;&gt; 1;
    pushdown(p, l, r);
    if(ql &lt;= mid) change(p&lt;&lt;1, l, mid, ql, qr, k);
    if(qr &gt; mid) change(p&lt;&lt;1|1, mid+1, r, ql, qr, k);
    pushup(p);
}
int query(int p, int l, int r, int ql, int qr) {
    if(ql &lt;= l &amp;&amp; r &lt;= qr) {
        return val[p];
    }
    pushdown(p, l, r);
    int mid = l+r &gt;&gt; 1, res = 0;
    if(ql &lt;= mid) res += query(p&lt;&lt;1, l, mid, ql, qr);
    if(qr &gt; mid) res += query(p&lt;&lt;1|1, mid+1, r, ql, qr);
    return res;
}

</code></pre>
<p>（上面代码函数名称和变量名称略有不同。var[]即之前代码的tree[]）</p>
<p>为了实现标记下传操作，我们写了一个函数<code>pushdown(int p, int l, int r)</code>
参数分别为</p>
<ul>
<li>
<p>当前节点</p>
</li>
<li>
<p>当前节点代表的区间</p>
</li>
</ul>
<p>因为我们要对这个节点的两个儿子打标记，我们就需要知道两个儿子的区间（下面会讲）所以我们要传入这个点代表的区间好推出两个儿子代表的区间。</p>
<hr />
<p>同时，对于在一个点添加标记的操作我们也写了一个函数<code>addtag(int p, int l, int r, int t)</code>
参数分别为</p>
<ul>
<li>
<p>当前节点</p>
</li>
<li>
<p>当前节点代表的区间</p>
</li>
<li>
<p>标记值。</p>
</li>
</ul>
<p>注意一下，实例代码的目的是求区间和，因此对于一个代表了n个点的区间的点，我们标记这个区间每个点都增加了t，那么这个点，因为他标记的区间是这n个点的总和，因此他要加上n*t才行。</p>
<h2 id="1_2">例题 #1 单点修改</h2>
<p><a href="https://flowus.cn/6f0fba60-f356-44a6-b89a-8012f66cb0a9">练习 | 南外20230712链表、哈希、并查集、分块</a></p>
<h2 id="2">例题 #2 区间修改例题</h2>
<blockquote>
<p>例题（线段树模板，区间求和区间修改）</p>
</blockquote>
<p>如题，已知一个数列，你需要进行下面两种操作：</p>
<ol>
<li>
<p>将某区间每一个数加上 <span class="arithmatex">\(k\)</span>。</p>
</li>
<li>
<p>求出某区间每一个数的和。</p>
</li>
</ol>
<p>输入格式</p>
<p>第一行包含两个整数 <span class="arithmatex">\(n, m\)</span>，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含 <span class="arithmatex">\(n\)</span> 个用空格分隔的整数，其中第 <span class="arithmatex">\(i\)</span> 个数字表示数列第 <span class="arithmatex">\(i\)</span> 项的初始值。</p>
<p>接下来 <span class="arithmatex">\(m\)</span> 行每行包含 <span class="arithmatex">\(3\)</span> 或 <span class="arithmatex">\(4\)</span> 个整数，表示一个操作，具体如下：</p>
<ol>
<li>
<p><code>1 x y k</code>：将区间 <span class="arithmatex">\([x, y]\)</span> 内每个数加上 <span class="arithmatex">\(k\)</span>。</p>
</li>
<li>
<p><code>2 x y</code>：输出区间 <span class="arithmatex">\([x, y]\)</span> 内每个数的和。</p>
</li>
</ol>
<p>对于 <span class="arithmatex">\(100\%\)</span> 的数据：<span class="arithmatex">\(1 \le n, m \le {10}^5\)</span>。</p>
<p>保证任意时刻数列中所有元素的绝对值之和 <span class="arithmatex">\(\le {10}^{18}\)</span>。</p>
<h2 id="_11">讲解</h2>
<h3 id="_12">实现方法</h3>
<h3 id="_13">代码</h3>
<p><strong>本地写法</strong></p>
<pre><code class="language-C++">/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
       ------------------
        . 模板: 线段树 .
/*////////ACACACACACACAC///////////

#include &lt;bits/stdc++.h&gt;
using namespace std;
#define int long long

const int N = 1e6 + 5;
int tr[N * 4], tag[N * 4];  //线段树相关的都开4倍空间
int a[N], n, ans, m;

//口诀:下去之前pushdown,上来之后pushup
void pushup(int x) { tr[x] = tr[x &lt;&lt; 1] + tr[x &lt;&lt; 1 | 1]; }
void addtag(int x, int l, int r, int t) {  //有tag表示自己已经被修改,但子节点没有被修改
    tr[x] += (r - l + 1) * t;
    tag[x] += t;
}
void pushdown(int x, int l, int r) {
    if (!tag[x])
        return;
    int t = tag[x], mid = l + r &gt;&gt; 1;
    addtag(x &lt;&lt; 1, l, mid, t);
    addtag(x &lt;&lt; 1 | 1, mid + 1, r, t);
    tag[x] = 0;
}
void build(int x, int l, int r) {
    if (l == r) {
        tr[x] = a[l];
        return;
    }
    int mid = (l + r) &gt;&gt; 1;
    build(x &lt;&lt; 1, l, mid);
    build(x &lt;&lt; 1 | 1, mid + 1, r);
    pushup(x);
}
void change(int p, int l, int r, int x, int y, int a) {
    if (l &gt;= x &amp;&amp; r &lt;= y) {
        addtag(p, l, r, a);
        return;  // addtag
    }
    pushdown(p, l, r);  // pushdown
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        change(p &lt;&lt; 1, l, mid, x, y, a);
    if (y &gt; mid)
        change(p &lt;&lt; 1 | 1, mid + 1, r, x, y, a);  // no else
    pushup(p);
}
int query(int p, int l, int r, int x, int y) {
    int res = 0;
    if (l &gt;= x &amp;&amp; r &lt;= y) {
        return tr[p];
    }
    pushdown(p, l, r);  // pushdown
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        res += query(p &lt;&lt; 1, l, mid, x, y);
    if (y &gt; mid)
        res += query(p &lt;&lt; 1 | 1, mid + 1, r, x, y);
    return res;
}
signed main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
    build(1, 1, n);
    while (m--) {
        char op[N];
        scanf(&quot;%s&quot;, op);
        int x, y, aa;
        cin &gt;&gt; x &gt;&gt; y;
        if (op[0] == 'A') {
            cin &gt;&gt; aa;
            change(1, 1, n, x, y, aa);
        } else {
            cout &lt;&lt; query(1, 1, n, x, y) &lt;&lt; endl;
        }
    }
}
</code></pre>
<p><strong>他人写法</strong></p>
<p>下面给出两种码风的代码</p>
<p>1.结构体存点+初始<code>build()</code>函数建树</p>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int N = 5e5 + 5;
ll a[N], n, m;

struct node {
    ll r, l;//范围左右
    ll m;//sum
    ll a;//add

} s[N];

void build(int k, int l, int r) {//s[k],建左，建右
    s[k].r = r;
    s[k].l = l;
    if (l == r) {
        s[k].m = a[l];
        return;
    }
    int mid = l + r &gt;&gt; 1;
    build(k * 2, l, mid);
    build(k * 2 + 1, mid + 1, r);
    s[k].m = s[k * 2].m + s[k * 2 + 1].m;

}

void spread(int k, int l, int r) {//标记
    s[l].m += (s[l].r + 1 - s[l].l) * s[k].a, s[l].a += s[k].a;
    s[r].m += (s[r].r + 1 - s[r].l) * s[k].a, s[r].a += s[k].a;
    s[k].a = 0;
}

void change(int k, int l, int r, int d) {//d增量
    if (s[k].r &lt;= r &amp;&amp; s[k].l &gt;= l) {//在目标范围内，增加，打标记
        s[k].m += (s[k].r + 1 - s[k].l) * d;
        s[k].a += d;
        return;
    }
    int mid = s[k].l + s[k].r &gt;&gt; 1; //二分
    spread(k, k * 2, k * 2 + 1);
    if (mid &gt;= l)
        change(k * 2, l, r, d);
    if (mid &lt; r)
        change(k * 2 + 1, l, r, d);
    s[k].m = s[k * 2].m + s[k * 2 + 1].m;
}

ll sum(int k, int l, int r) {//求
    if (s[k].r &lt;= r &amp;&amp; s[k].l &gt;= l) {//全包含
        return s[k].m;
    }
    int mid = s[k].l + s[k].r &gt;&gt; 1;
    spread(k, k * 2, k * 2 + 1);
    ll tmp = 0;
    if (mid &gt;= l)
        tmp += sum(k * 2, l, r);
    if (mid &lt; r)
        tmp += sum(k * 2 + 1, l, r);
    return tmp;
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; a[i];
    }
    build(1, 1, n); //初始建树
    for (int i = 1; i &lt;= m; i++) {
        int op;
        int l, r, d;
        cin &gt;&gt; op;
        if (op == 1) {
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;
            change(1, l, r, d);
        } else {
            cin &gt;&gt; l &gt;&gt; r;
            cout &lt;&lt; sum(1, l, r) &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
<p>2.直接在函数间传递点的信息（区间信息），不需要结构体，建树过程直接变成修改过程。</p>
<pre><code class="language-C++">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int _ = 1e6 + 5;
int val[_ &lt;&lt; 2], tag[_ &lt;&lt; 2];
void pushup(int p) {
    val[p] = val[p &lt;&lt; 1] + val[p &lt;&lt; 1 | 1];
}
void addtag(int p, int l, int r, int t) {
    val[p] += (r-l+1) * t;
    tag[p] += t;
}
void pushdown(int p, int l, int r) {
    if(!tag[p]) return ;
    int t = tag[p], mid = l+r&gt;&gt;1;
    addtag(p&lt;&lt;1, l, mid, t); addtag(p&lt;&lt;1|1, mid+1, r, t);
    tag[p] = 0;
}
void modify(int p, int l, int r, int ql, int qr, int k) {   //就是上文的change()
    if(ql &lt;= l &amp;&amp; r &lt;= qr) {
        addtag(p, l, r, k);
        return ;
    }
    int mid = l+r &gt;&gt; 1;
    pushdown(p, l, r);
    if(ql &lt;= mid) modify(p&lt;&lt;1, l, mid, ql, qr, k);
    if(qr &gt; mid) modify(p&lt;&lt;1|1, mid+1, r, ql, qr, k);
    pushup(p);
}
int query(int p, int l, int r, int ql, int qr) {
    if(ql &lt;= l &amp;&amp; r &lt;= qr) {
        return val[p];
    }
    pushdown(p, l, r);
    int mid = l+r &gt;&gt; 1, res = 0;
    if(ql &lt;= mid) res += query(p&lt;&lt;1, l, mid, ql, qr);
    if(qr &gt; mid) res += query(p&lt;&lt;1|1, mid+1, r, ql, qr);
    return res;
}
signed main() {
    ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int n, m; cin &gt;&gt; n &gt;&gt; m;
    for(int i=1; i&lt;=n; ++i) {
        int x; cin &gt;&gt; x;
        modify(1, 1, n, i, i, x);   //用直接修改代替建树
    }
    for(int i=1; i&lt;=m; ++i) {
        int o, l, r, k;
        cin &gt;&gt; o &gt;&gt; l &gt;&gt; r;
        if(o == 1) {
            cin &gt;&gt; k; modify(1, 1, n, l, r, k); //解说：目前位于点1，代表区间[1,n] ,目标是将区间[l,r]每个数加上k
        } else {
            cout &lt;&lt; query(1, 1, n, l, r) &lt;&lt; '\n';   //解说：目前位于点1，代表区间[1,n]，目标是求区间[l,r]之和
        }
    }
}

</code></pre>
<h2 id="_14">线段树上二分</h2>
<p><a href="https://flowus.cn/7bcdb6cd-4419-4d84-855b-952e479d6d2f">AtCoder Library Practice Contest 2/12</a>J</p>
<h2 id="_15">练习</h2>
<p>线段树维护等差数列 <a href="https://flowus.cn/bc34fb37-b791-4387-8ea2-06da9c6ea191">练习 | 南外230901</a> B题</p>
<p>线段树区间和</p>
<pre><code class="language-C++">/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . FancyKnowledge .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//
#include&lt;bits/stdc++.h&gt;

//
#define int long long
#define ull unsigned long long
#define db double
#define endl '\n'
#define err(fmt, ...) fprintf(stderr, &quot;[%d] : &quot; fmt &quot;\n&quot;, __LINE__, ##__VA_ARGS__)

using namespace std;
//
const int N=1e5+5;
const int M=1e3;
 int MOD=1e9+7;
const int MMOD=903250223;
const int INF=1e9;
const int IINF=1e18;
const db eps=1e-9;
//
int n,m,a[N],b,q,s[N],op,idx,len[N],ans,res,tmp,cnt[N],id[N];
int tr[N&lt;&lt;2],tagadd[N&lt;&lt;2],tagmul[N&lt;&lt;2],taglock[N&lt;&lt;2],mxlock[N&lt;&lt;2];
int L;

void pushup(int x){
    tr[x]=(tr[x&lt;&lt;1]+tr[x&lt;&lt;1|1])%MOD;
}
void addtag(int p, int l, int r, int a,int m) {
    tr[p] = ( tr[p] * m + (r-l+1) * a ) % MOD;
    tagmul[p] = tagmul[p] * m % MOD;
    tagadd[p] = (tagadd[p] * m % MOD + a) % MOD;
}
void pushdown(int p, int l, int r) {
    int mid = l+r&gt;&gt;1;
    addtag(p&lt;&lt;1, l, mid, tagadd[p],tagmul[p]);
    addtag(p&lt;&lt;1|1, mid+1, r, tagadd[p],tagmul[p]);
    tagadd[p] = 0;
    tagmul[p]=1;
}

void changeadd(int x,int l,int r,int pl,int pr,int v){
    if(l&gt;=pl&amp;&amp;r&lt;=pr){
        addtag(x, l, r, v,1);
        return ;
    }

    pushdown(x,l,r);
    int mid=l+r&gt;&gt;1;
    if(pl&lt;=mid)changeadd(x&lt;&lt;1,l,mid,pl,pr,v);
    if(pr&gt;mid)changeadd(x&lt;&lt;1|1,mid+1,r,pl,pr,v);
    pushup(x);
}

void changemul(int x,int l,int r,int pl,int pr,int v){
    if(l&gt;=pl&amp;&amp;r&lt;=pr){
        addtag(x, l, r, 0,v);
        return ;
    }

    pushdown(x,l,r);
    int mid=l+r&gt;&gt;1;
    if(pl&lt;=mid)changemul(x&lt;&lt;1,l,mid,pl,pr,v);
    if(pr&gt;mid)changemul(x&lt;&lt;1|1,mid+1,r,pl,pr,v);
    pushup(x);
}


int query(int x,int l,int r,int pl,int pr){
    if(l&gt;=pl&amp;&amp;r&lt;=pr)return tr[x];
    pushdown(x,l,r);
    int mid=l+r&gt;&gt;1;
    int res=0;
    if(pl&lt;=mid)res=(res+query(x&lt;&lt;1,l,mid,pl,pr))%MOD;
    if(pr&gt;mid)res=(res+query(x&lt;&lt;1|1,mid+1,r,pl,pr))%MOD;
    return res%MOD;
}

void dbg(){

//  cout&lt;&lt;&quot;debug=&quot;;
//  for(int i=1;i&lt;=n;i++){
//      int c=query(1,1,n,i,i);
////        cout&lt;&lt;c&lt;&lt;' ';
//      
//  }

//  cout&lt;&lt;endl;
}

signed main(){

//  freopen(&quot;.in&quot;,&quot;r&quot;,stdin);
//  freopen(&quot;.out&quot;,&quot;w&quot;,stdout);
//  freopen(&quot;.txt&quot;,&quot;w&quot;,stderr);

    cin&gt;&gt;n&gt;&gt;m&gt;&gt;MOD;

//  cerr&lt;&lt;&quot;OK&quot;;

    for(int i=1;i&lt;=N-2;i++)tagmul[i]=1;
    for(int i=1;i&lt;=n;i++){
        int x;
        cin&gt;&gt;x;
        changeadd(1,1,n,i,i,x);

        //这样初始化的复杂度比build略高
    }
    dbg();
    while(m--){
        int op,l,r,x;
        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;
        if(op==2){
            cin&gt;&gt;x;
            changeadd(1,1,n,l,r,x%MOD);
            dbg();
        }if(op==1){
            cin&gt;&gt;x;
            changemul(1,1,n,l,r,x%MOD);
            dbg();
        }

        if(op==3){
            int ans=query(1,1,n,l,r)%MOD;
            cout&lt;&lt;ans&lt;&lt;endl;
        }
    }


    return 0;
}

//check your long long and the size of memery!!!
</code></pre>
<p>线段树过多个标记应用</p>
<p><a href="https://www.luogu.com.cn/problem/P4560">www.luogu.com.cn</a></p>
<p>标记传-1表示没用是不可取的。</p>
<h1 id="_16">分块</h1>
<p>[TJOI2009] 开关</p>
<h2 id="1_3">例题 #1</h2>
<p>现有 <span class="arithmatex">\(n\)</span> 盏灯排成一排，从左到右依次编号为：<span class="arithmatex">\(1\)</span>，<span class="arithmatex">\(2\)</span>，……，<span class="arithmatex">\(n\)</span>。然后依次执行 <span class="arithmatex">\(m\)</span> 项操作。</p>
<p>操作分为两种：</p>
<ol>
<li>
<p>指定一个区间 <span class="arithmatex">\([a,b]\)</span>，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）；</p>
</li>
<li>
<p>指定一个区间 <span class="arithmatex">\([a,b]\)</span>，要求你输出这个区间内有多少盏灯是打开的。</p>
</li>
</ol>
<p><strong>灯在初始时都是关着的。</strong></p>
<p>输入格式</p>
<p>第一行有两个整数 <span class="arithmatex">\(n\)</span> 和 <span class="arithmatex">\(m\)</span>，分别表示灯的数目和操作的数目。</p>
<p>接下来有 <span class="arithmatex">\(m\)</span> 行，每行有三个整数，依次为：<span class="arithmatex">\(c\)</span>、<span class="arithmatex">\(a\)</span>、<span class="arithmatex">\(b\)</span>。其中 <span class="arithmatex">\(c\)</span> 表示操作的种类。</p>
<ul>
<li>
<p>当 <span class="arithmatex">\(c\)</span> 的值为 <span class="arithmatex">\(0\)</span> 时，表示是第一种操作。</p>
</li>
<li>
<p>当 <span class="arithmatex">\(c\)</span> 的值为 <span class="arithmatex">\(1\)</span> 时，表示是第二种操作。</p>
</li>
</ul>
<p><span class="arithmatex">\(a\)</span> 和 <span class="arithmatex">\(b\)</span> 则分别表示了操作区间的左右边界。</p>
<p>对于全部的测试点，保证 <span class="arithmatex">\(2\le n\le 10^5\)</span>，<span class="arithmatex">\(1\le m\le 10^5\)</span>，<span class="arithmatex">\(1\le a,b\le n\)</span>，<span class="arithmatex">\(c\in\{0,1\}\)</span>。</p>
<h2 id="_17">讲解</h2>
<p>我们发现，这道题可以使用线段树完成！但是我们也发现，我们不想写线段树！因为它太长了！于是我们选线段树的替代品——分块！</p>
<h3 id="_18">分块！</h3>
<p><a href="https://www.bilibili.com/video/BV1pP4y127tC/?spm_id_from=333.999.0.0">549 整除分块（数论分块）_哔哩哔哩_bilibili</a></p>
<p>注意，数论分块与此处的分块不一样！以上链接指向错误。</p>
<p>OI Wiki的分块是正确的</p>
<p><a href="https://oi-wiki.org/ds/decompose/">分块思想 - OI Wiki</a></p>
<p>我们把一段序列<span class="arithmatex">\(1\sim n\)</span> 分成$ \lfloor\sqrt{n}\rfloor$份，可以真快修改的就一起修改，负责直接朴素修改。这样子在时间复杂度上会有所让步，但是它的代码简洁易懂，扩展性强。</p>
<h3 id="_19">代码</h3>
<p>以下为错误代码</p>
<pre><code class="language-C++">//j0, j1 , jn , y1 , y0 , yn不能用：这是个函数（非常的高级）
#include &lt;bits/stdc++.h&gt;
const int N=1e5+5;
int op[N],kuai[N],n,m,sn;
using namespace std;
void change(int a,int b){
    int p=b-b%sn;
    while((a)%sn){
        op[a]=1-op[a];
        if(op[a])kuai[a/sn]++;
        else kuai[a/sn]--;
        a++;
    }
    while(a&lt;p){
        kuai[a/sn]=sn-kuai[a/sn];
        a+=sn;
    }
    while(a&lt;=b){
        op[a]=1-op[a];
        if(op[a])kuai[a/sn]++;
        else kuai[a/sn]--;
        a++;
    }

}
void query(int a,int b){
    int ans=0;

    int p=b-b%sn;
    while((a)%sn){
        if(op[a])ans++;a++;
    }
    while(a&lt;p){
        ans+=kuai[a/sn];
        a+=sn;
    }
    while(a&lt;=b){
        if(op[a])ans++;
        a++;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main(){
    //ios::sync_which_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    sn=sqrt(n);
    for(int i=1;i&lt;=m;i++){
        int a,b,c;
        cin&gt;&gt;c&gt;&gt;a&gt;&gt;b;
        if(c==0){
            change(a,b);
        }else{
            query(a,b);
        }
    } 
    return 0;
}

</code></pre>
<h1 id="_20">分块变形：莫队</h1>
<h2 id="1_4">例题 #1 引入</h2>
<p>给出一个序列和若干查询l, r，问[l, r]中有多少个不同的数。</p>
<p><a href="https://zhuanlan.zhihu.com/p/115243708">算法学习笔记(24): 莫队</a></p>
<p>这道题也可以用<a href="https://zhuanlan.zhihu.com/p/93795692">树状数组</a>或<a href="https://zhuanlan.zhihu.com/p/114268236">块状数组</a>来做，但用莫队的话思维难度会比较低。</p>
<h2 id="_21">讲解</h2>
<p>我们用一个数组<code>Cnt[]</code>来记录每个数出现的次数，<code>cur</code> 表示当前区间的答案，例如：</p>
<p><img alt="https://pic1.zhimg.com/80/v2-2cf0bf5282fcc2e8ed189af59b85fdf0_720w.webp" src="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/v2-2cf0bf5282fcc2e8ed189af59b85fdf0_720w.webp" /></p>
<p>现在转移到紧邻的区间就很简单了，例如转移到[l,r+1]：</p>
<p><img alt="https://pic3.zhimg.com/80/v2-22cc01af28888de32f3d89646b03cd62_720w.webp" src="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/v2-22cc01af28888de32f3d89646b03cd62_720w.webp" /></p>
<p>Cnt[2]=0，说明添加了一个没出现过的数，所以cur变成4，但如果在这里再次向右转移：</p>
<p><img alt="https://pic3.zhimg.com/80/v2-6d70005629e42e110f88f84fd7a7c6ce_720w.webp" src="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/v2-6d70005629e42e110f88f84fd7a7c6ce_720w.webp" /></p>
<p>这时Cnt[3]不为0，所以虽然Cnt[3]++，但是cur不再增长。</p>
<p>其他的转移都是类似的。容易发现，转移分为两种情况，往区间里<strong>添</strong>数，或者往区间里<strong>删</strong>数，所以可以写成两个函数：</p>
<pre><code class="language-C++">void add(int p){//p为要添加的下标保证p与当前分块相邻
    if(!cnt[a[p]])cur++;
    cnt[a[p]]++;
}
void del(int p){
    if(cnt[a[p]]==1)cur--;
    cnt[a[p]]--;
}
</code></pre>
<p>对于区间的移动，若目标区间为[al,ar]，当前区间为[l,r]</p>
<pre><code class="language-C++">while(l&gt;al)add(--l);//al在l左边,l在当前分块中,l-1不在,所以先移动后添加
while(l&lt;al)del(l++);//al在l右边,l在当前分块中但不在目标区间,所以先删除后移动
while(r&gt;ar)del(r--);
while(r&lt;ar)add(++r);
</code></pre>
<p>当然，如果知道al与l，ar与r的大小，可以删去一半。</p>
<p>初始化时，要先令l=1，r=0。</p>
<p>现在我们可以从一个区间的答案转移到另一个区间了，但是，如果直接在线查询，很有可能在序列两头“左右横跳”，到头来还不如朴素的$  O(n^2)$算法。但是，我们可以把查询离线下来（记录下来），然后，排个序……</p>
<p>问题来了，怎么排序？我们很容易想到以l为第一关键词，r为第二关键词排下序，但这样做效果并不是很好。莫涛大神给出的方法是，<strong>分块</strong>，然后按照<code>bel[l]</code> 为第一关键词，<code>bel[r]</code>为第二关键词排序。 这样，每两次询问间l和r指针移动的距离可以被有效地降低，整个算法的时间复杂度可以降到 <span class="arithmatex">\(O(n \sqrt n)\)</span> ！</p>
<p>（注释： <code>bel[i]</code>表示元素i归属哪个块）</p>
<p>莫队算法优化的核心是分块和排序。我们将大小为n的序列分为√n个块，从1到√n编号，然后根据这个对查询区间进行排序。一种方法是把查询区间按照<strong>左端点所在块的序号从小到大</strong>排个序，如果左端点所在块相同，再按<strong>右端点从小到大</strong>排序。排完序后我们再进行左右指针跳来跳去的操作</p>
<pre><code class="language-C++"> bool operator&lt;(const query &amp;o) const // 重载&lt;运算符，奇偶化排序
    {
        // 这里只需要知道每个元素归属哪个块，而块的大小都是sqrt(n)，所以可以直接用l/sq
        if (l / sq != o.l / sq) 
            return l &lt; o.l;
        if (l / sq &amp; 1)
            return r &lt; o.r;
        return r &gt; o.r;
    }
</code></pre>
<p>在<span class="arithmatex">\(l / sq \&amp; 1\)</span>中，<code>&amp;</code>优先级低于<code>/</code></p>
<p>如果<span class="arithmatex">\(1/sq\)</span>为奇数,则上式为true</p>
<p><strong>与（&amp;）</strong></p>
<p>规则：两个操作数对应二进制<strong>位</strong>同样为1 结果<strong>位</strong> 才为1，否则为0；</p>
<p><strong>分块前后时间复杂度解说</strong></p>
<p>分块前：</p>
<p>我们按照l进行排序，当l不变时，r可能会在l~n之间反复横跳，复杂度较高</p>
<p>分块后：</p>
<p>我们把所属的块相同的询问放在一起，按r从小到大排序</p>
<p>l可能会在块内反复横跳，但复杂度较小。而r是从小到大的，复杂度最高为<span class="arithmatex">\(O(n-l)\)</span>也较小</p>
<p>较高&gt;较小×较小，结果严谨证明得分块更优秀。</p>
<p><strong>奇偶性排序</strong></p>
<p>我们发现，当我们的l从一块跳到后面一块时，r要从偏右端跳回到最靠近l的那个r，然后又要再往右跳一边。这样就会重复走路。如果我们可以让r在“从偏右端跳回到最靠近l的那个r”过程中就把答案处理掉，就会优化一半的复杂度。</p>
<p>因此：如果<code>bel[l]</code> 是奇数，则将<code>r</code>顺序排序，否则将<code>r</code>逆序排序</p>
<h2 id="2-b">例题 #2 小B的询问</h2>
<p>小B 有一个长为 <span class="arithmatex">\(n\)</span> 的整数序列 <span class="arithmatex">\(a\)</span>，值域为 <span class="arithmatex">\([1,k]\)</span>。
他一共有 <span class="arithmatex">\(m\)</span> 个询问，每个询问给定一个区间 <span class="arithmatex">\([l,r]\)</span>，求：
<span class="arithmatex">\(\sum\limits_{i=1}^k c_i^2\)</span></p>
<p>其中 <span class="arithmatex">\(c_i\)</span> 表示数字 <span class="arithmatex">\(i\)</span> 在 <span class="arithmatex">\([l,r]\)</span> 中的出现次数。
小B请你帮助他回答询问。</p>
<p>【数据范围】
对于 <span class="arithmatex">\(100\%\)</span> 的数据，<span class="arithmatex">\(1\le n,m,k \le 5\times 10^4\)</span>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/115243708">zhuanlan.zhihu.com</a></p>
<pre><code class="language-C++">/*                                                                                
                      Keyblinds Guide
                    ###################
      @Ntsc 2024

      - Ctrl+Alt+G then P : Enter luogu problem details
      - Ctrl+Alt+B : Run all cases in CPH
      - ctrl+D : choose this and dump to the next
      - ctrl+Shift+L : choose all like this
      - ctrl+B then ctrl+W: close all
      - Alt+la/ra : move mouse to pre/nxt pos'

*/
#include &lt;bits/stdc++.h&gt;
#include &lt;queue&gt;
using namespace std;

#define rep(i, l, r) for (int i = l, END##i = r; i &lt;= END##i; ++i)
#define per(i, r, l) for (int i = r, END##i = l; i &gt;= END##i; --i)
#define pb push_back
#define mp make_pair
#define int long long
#define pii pair&lt;int, int&gt;
#define ps second
#define pf first

// #define innt int
// #define inr int
// #define mian main
// #define iont int

#define rd read()
int read(){
    int xx = 0, ff = 1;
    char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') {
        if (ch == '-')
            ff = -1;
        ch = getchar();
    }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
      xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}
void write(int out) {
    if (out &lt; 0)
        putchar('-'), out = -out;
    if (out &gt; 9)
        write(out / 10);
    putchar(out % 10 + '0');
}

#define ell dbg('\n')
const char el='\n';
const bool enable_dbg = 1;
template &lt;typename T,typename... Args&gt;
void dbg(T s,Args... args) {
    if constexpr (enable_dbg){
    cerr &lt;&lt; s &lt;&lt; ' ';
        if constexpr (sizeof...(Args))
            dbg(args...);
    }
}

const int N = 3e5 + 5;
const int INF = 1e18;
const int M = 1e7;
const int MOD = 1e9 + 7;

struct node{
    int l,r,id;
}t[N];

int B;
int a[N];

int cnt[N],cnt2[N];


inline int getK(int x){
    return (x-1)/B+1;
}

bool cmp(node a, node b)
{
    if(getK(a.l) ^ getK(b.l)) return a.l &lt; b.l;
    else if(getK(a.l) &amp; 1) return a.r &lt; b.r;
    else return a.r &gt; b.r;
}


int ans;
int K;

void add(int x){
    if(a[x]&gt;K)return ;
    ans-=cnt2[a[x]];
    cnt2[a[x]]+=2*cnt[a[x]]+1;
    cnt[a[x]]++;
    ans+=cnt2[a[x]];
}

void del(int x){
    if(a[x]&gt;K)return ;
    ans-=cnt2[a[x]];
    cnt2[a[x]]+=-2*cnt[a[x]]+1;
    cnt[a[x]]--;
    ans+=cnt2[a[x]];

}

int anss[N];

void solve(){
    int n=rd,m=rd;
    K=rd;
    B=sqrt(n)+1;
    for(int i=1;i&lt;=n;i++){
        a[i]=rd;
    }   
    for(int i=1;i&lt;=m;i++){
        t[i].l=rd,t[i].r=rd;
        t[i].id=i;
    }

    // dbg(&quot;OK&quot;);
    sort(t+1,t+m+1,cmp);
    int cl=1,cr=0;
    for(int i=1;i&lt;=m;i++){
        int l=t[i].l,r=t[i].r;

        // dbg(&quot;--&quot;,l,r,el);

        while(cl&gt;l)add(--cl);
        while(cl&lt;l)del(cl),cl++;
        while(cr&gt;r)del(cr),cr--;        
        while(cr&lt;r)cr++,add(cr);

        anss[t[i].id]=ans;
    }

    for(int i=1;i&lt;=m;i++){
        cout&lt;&lt;anss[i]&lt;&lt;endl;
    }
}

signed main() {
    int T=1;
    while(T--){
        solve();
    }
    return 0;
}
</code></pre>
<h2 id="_22">带修莫队</h2>
<p>例题 #1【模板】莫队二次离线（第十四分块(前体)）</p>
<p>珂朵莉给了你一个序列 <span class="arithmatex">\(a\)</span>，每次查询给一个区间 <span class="arithmatex">\([l,r]\)</span>，查询 <span class="arithmatex">\(l \leq i&lt; j \leq r\)</span>，且 <span class="arithmatex">\(a_i \oplus a_j\)</span> 的二进制表示下有 <span class="arithmatex">\(k\)</span> 个 <span class="arithmatex">\(1\)</span> 的二元组 <span class="arithmatex">\((i,j)\)</span> 的个数。<span class="arithmatex">\(\oplus\)</span> 是指按位异或。</p>
<p>输入格式</p>
<p>第一行三个数表示 <span class="arithmatex">\(n,m,k\)</span>。</p>
<p>第二行 <span class="arithmatex">\(n\)</span> 个数表示序列 <span class="arithmatex">\(a\)</span>。</p>
<p>之后 <span class="arithmatex">\(m\)</span> 行，每行两个数 <span class="arithmatex">\(l,r\)</span> 表示一次查询。</p>
<p>对于100%的数据，<span class="arithmatex">\(1 \leq n, m \leq 100000\)</span>，<span class="arithmatex">\(0 \leq a_i, k &lt; 16384\)</span>。</p>
<h2 id="_23">回滚莫队&amp;不删除莫队</h2>
<h3 id="_24">题目描述</h3>
<p>给定一个序列，多次询问一段区间 <span class="arithmatex">\([l,r]\)</span>，求区间中<strong>相同的数的最远间隔距离</strong>。</p>
<p>序列中两个元素的<strong>间隔距离</strong>指的是<strong>两个元素下标差的绝对值</strong>。</p>
<h3 id="_25">应用</h3>
<p>众所周知，我们在是实现莫队的时候要实现两个函数，一个是add，一个是del。但是如果我们遇到了难以实现快速del时，我们应该怎么办呢？我们可以试着使用回滚莫队。</p>
<p>回滚莫队就是通过双指针回到某一个历史版本，然后重新开始add操作来实现区间边界的del操作。</p>
<h3 id="_26">思路</h3>
<p>根据莫队的性质，在一个询问块中，我们的r是单调的，但是l可能不是，所以我们现在只需要考虑一个l的问题就行了。那么为了减少删除，我们就可以让l一直指向L中的最大值（L是块中所有询问的l），并且让指针p,r去分别走到左右端点。并且在每一次需要左端点del时，就人p直接回到l后重新向左边扩散即可。</p>
<p>这个做法仅仅是在移动双指针时需要更多的代码，并不需要在排序上动手脚。</p>
<p>注意，回滚莫队并不代表着我们可以完全做到不删除，只是在减少删除的次数。还是回到上面的思路，我们在来到一个新块时，先设定cl为其中最大的l，此时我们注意到可能会有询问的r&lt;cl，此时我们就需要删除[r+1,cl]之间的数据了。</p>
<p>这里我们发现，r无非只有两种情况——在当前块内和在当前块后面。那么对于第一种情况，我们直接暴力即可。第二种我们就可以使用上面的不删除策略了。</p>
<h3 id="_27">代码</h3>
<p>注意每次pl回退时res也要回退。</p>
<p>我们的贡献可以分成三个部分</p>
<ul>
<li>
<p>跨cl的</p>
</li>
<li>
<p>仅仅由cl左边产生的</p>
</li>
<li>
<p>仅仅由cl右边产生的</p>
</li>
</ul>
<p>回退pl时，我们只能保留仅仅由cl右边产生的贡献，所以我们除了要维护全局贡献最大值res，还要维护仅仅由cl右边产生的贡献的最大值resr</p>
<pre><code class="language-C++">/*                                                                                
                      Keyblinds Guide
                    ###################
      @Ntsc 2024

      - Ctrl+Alt+G then P : Enter luogu problem details
      - Ctrl+Alt+B : Run all cases in CPH
      - ctrl+D : choose this and dump to the next
      - ctrl+Shift+L : choose all like this
      - ctrl+K then ctrl+W: close all
      - Alt+la/ra : move mouse to pre/nxt pos'

*/
#include &lt;bits/stdc++.h&gt;
#include &lt;queue&gt;
using namespace std;

#define rep(i, l, r) for (int i = l, END##i = r; i &lt;= END##i; ++i)
#define per(i, r, l) for (int i = r, END##i = l; i &gt;= END##i; --i)
#define pb push_back
#define mp make_pair
#define int long long
#define pii pair&lt;int, int&gt;
#define ps second
#define pf first

// #define innt int
// #define inr int
// #define mian main
// #define iont int

#define rd read()
int read(){
    int xx = 0, ff = 1;
    char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') {
        if (ch == '-')
            ff = -1;
        ch = getchar();
    }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
      xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}
void write(int out) {
    if (out &lt; 0)
        putchar('-'), out = -out;
    if (out &gt; 9)
        write(out / 10);
    putchar(out % 10 + '0');
}

#define ell dbg('\n')
const char el='\n';
const bool enable_dbg = 1;
template &lt;typename T,typename... Args&gt;
void dbg(T s,Args... args) {
    if constexpr (enable_dbg){
    cerr &lt;&lt; s;
    if(1)cerr&lt;&lt;' ';
        if constexpr (sizeof...(Args))
            dbg(args...);
    }
}

const int N = 3e5 + 5;
const int INF = 1e18;
const int M = 1e7;
const int MOD = 1e9 + 7;
int B;

struct node{
    int l,r,id;
}t[N];
int a[N];
int ans[N];
int mxl[N];

inline int getK(int x){
    return (x-1)/B+1;
}

bool cmp(node a,node b){
    if(getK(a.l)==getK(b.l)){
        return a.r&lt;b.r;
    }
    return getK(a.l)&lt;getK(b.l);
}


int res=0;
int dislmn[N],disrmx[N];
int dislmx[N],disrmn[N];
int cl,cr;
int stk[N],top;
int stk2[N],top2;

int resr;

void update(int x){
    int v=a[x];
    res=max(res,dislmx[v]-dislmn[v]);
    res=max(res,disrmx[v]-disrmn[v]);
    res=max(res,disrmx[v]-dislmn[v]);
    resr=max(resr,disrmx[v]-disrmn[v]);

    // dbg(dislmx[v] - dislmn[v], disrmx[v] - disrmn[v], disrmx[v] - dislmn[v], el);

}

void addl(int x){
    dislmx[a[x]]=max(dislmx[a[x]],x);
    dislmn[a[x]]=min(dislmn[a[x]],x);
    stk[++top]=a[x];
    update(x);
}

void addr(int x){
    disrmx[a[x]]=max(disrmx[a[x]],x);
    disrmn[a[x]]=min(disrmn[a[x]],x);
    stk2[++top2]=a[x];
    update(x);
}

int b[N];
int f[N];


int loc[N],but[N],btop;

void solve(){
    for(int i=0;i&lt;N;i++)dislmx[i]=-INF;
    for(int i=0;i&lt;N;i++)disrmx[i]=-INF;
    for(int i=0;i&lt;N;i++)disrmn[i]=INF;
    for(int i=0;i&lt;N;i++)dislmn[i]=INF;
    for(int i=0;i&lt;N;i++)loc[i]=-1;


    int n=rd;
    B=sqrt(n)+1;
    for(int i=1;i&lt;=n;i++){
        b[i]=a[i]=rd;
    }   
    sort(b+1,b+n+1);
    int len=unique(b+1,b+n+1)-b;
    for(int i=1;i&lt;=n;i++){
        a[i]=lower_bound(b+1,b+len+1,a[i])-b;
    }


    int m=rd;
    for(int i=1;i&lt;=m;i++){
        t[i].l=rd,t[i].r=rd;
        mxl[getK(t[i].l)]=max(mxl[getK(t[i].l)],t[i].l);
        t[i].id=i;
    }

    sort(t+1,t+m+1,cmp);

    cl=0,cr=0;
    for(int i=1;i&lt;=m;i++){
        int l=t[i].l,r=t[i].r;


        while(top){dislmn[stk[top]]=INF;dislmx[stk[top--]]=-INF;}

        if(cl!=mxl[getK(l)]){
            cr=cl=mxl[getK(l)];
            while(top2){disrmx[stk2[top2]]=-INF;disrmn[stk2[top2--]]=INF;}
            res=0;resr=0;
            addr(cl);
        }

        if(getK(l)==getK(r)){
            res=0;
            while(btop)loc[but[btop--]]=-1;
            for(int j=l;j&lt;=r;j++){
                int v=a[j];
                if(loc[v]!=-1)res=max(res,j-loc[v]);
                else {loc[v]=j;but[++btop]=v;}
            }
            ans[t[i].id]=res;
            f[t[i].id]=1;

            continue;
        }

        int pl=cl;
        res=resr;

        while(pl&gt;l)addl(--pl);
        while(cr&lt;r)addr(++cr);
        ans[t[i].id]=res;
    }

    for(int i=1;i&lt;=m;i++){
        cout&lt;&lt;ans[i]&lt;&lt;endl;
    }
}

signed main() {
    int T=1;
    while(T--){
        solve();
    }
    return 0;
}
</code></pre>
<h3 id="_28">习题</h3>
<p><a href="https://www.luogu.com.cn/problem/AT_joisc2014_c">www.luogu.com.cn</a></p>
<h1 id="_29">分块思想应用：块状链表</h1>
<p><img alt="image.png" src="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/image%201.png" /></p>
<p>效率对比</p>
<p><img alt="image.png" src="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/image%202.png" /></p>
<h2 id="_30">基本操作</h2>
<h3 id="_31">第一种块状链表：</h3>
<p>强制维护每个块的大小一定为 <span class="arithmatex">\(\sqrt{n}\)</span></p>
<p><img alt="image.png" src="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/image%203.png" /></p>
<p><img alt="未命名文件.gif 的常量，不用更改它。" src="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.gif%2B%E7%9A%84%E5%B8%B8%E9%87%8F%EF%BC%8C%E4%B8%8D%E7%94%A8%E6%9B%B4%E6%94%B9%E5%AE%83%E3%80%82" /></p>
<h3 id="_32">第二种块状链表：</h3>
<p>仅维护每个块的大小<span class="arithmatex">\(&lt;\sqrt{2\times n}\)</span>，让每个块的大小保持在<span class="arithmatex">\(\sqrt{n}\)</span>附近</p>
<p><strong>操作类型</strong></p>
<p>分裂、插入、查找。 </p>
<p><strong>什么是分裂？</strong></p>
<p>分裂就是分裂一个 node，变成两个小的 node，以保证每个 node 的大小都接近 <span class="arithmatex">\(\sqrt{n}\)</span>（否则可能退化成普通数组）。当一个 node 的大小超过 <span class="arithmatex">\(2\times \sqrt{n}\)</span> 时执行分裂操作。</p>
<p>分裂操作怎么做呢？先新建一个节点，再把被分裂的节点的后 <span class="arithmatex">\(\sqrt{n}\)</span> 个值 copy 到新节点，然后把被分裂的节点的后 $\sqrt{n} $个值删掉（size--），最后把新节点插入到被分裂节点的后面即可。</p>
<p><strong>插入</strong></p>
<p>还有一个要说的。 随着元素的插入（或删除），<span class="arithmatex">\(n\)</span> 会变，<span class="arithmatex">\(\sqrt{n}\)</span> 也会变。这样块的大小就会变化，我们难道还要每次维护块的大小？</p>
<p>其实不然，把 $\sqrt{n} $ 设置为一个定值即可。比如题目给的范围是 <span class="arithmatex">\(10^6\)</span>，那么 <span class="arithmatex">\(\sqrt{n}\)</span> 就设置为大小为 $10^3 $ 的常量，不用更改它。</p>
<p><strong>查找</strong></p>
<p>从前往后找每个块即可，直接访问块中存储的当前块的大小。</p>
<h3 id="_33"><strong>具体实现</strong></h3>
<p><strong>存储</strong></p>
<p>我们考察结构体写法的普通链表</p>
<pre><code class="language-C++">struct node {
    int pre, nxt;
    int v;
}a[N];
</code></pre>
<p>块状链表实际上和在普通链表里每个节点存一个值差不多，只不过是每个节点里存一个大小约为<span class="arithmatex">\(\sqrt{n}\)</span>的数组</p>
<pre><code class="language-C++">struct node {
    int sz, nxt;        //节点对应的数组长度,链表中下一个节点
    char s[MAXB*4];     //节点对应的数组实际值(以例题2为例:本题要求为字符)
}a[N];
</code></pre>
<p><strong>查询</strong></p>
<pre><code class="language-C++">//返回原数组中下标为p的元素所在的块的编号，并将传入的引用(原数组下标)改为块内的下标。
int pos(int &amp;p) {
    int x = 0;
    while(x != -1 &amp;&amp; a[x].sz &lt; p) { //为方便下面的split操作，定义下标在[1,sz]内,但实际数组下标从0开始。
        p -= a[x].sz, x = a[x].nxt;     //一次跳整个节点
    }
    return x;
}

</code></pre>
<p><strong>插入（注意这里只是块之间的操作，是底层的，不是表层操作）</strong></p>
<pre><code class="language-C++">//在编号为x的节点后插入一个编号为y,长度为len,对应数组为s的节点
void add(int x, int y, int len, char *s) {
    if(y != -1) {       //特判x指向-1(即链表的末尾)
        a[y].sz = len;      //对编号为y的节点赋值
        a[y].nxt = a[x].nxt;
        memcpy(a[y].s, s, len);     //memcpy的第三个参数是复制的字节数,所以这里的len本来应该乘上相应元素类型的size,但本题由于sizeof(char)=1，所以可以不乘。
    }
    a[x].nxt = y;       //x指向y
}

</code></pre>
<p>（批注：代码中的y应该传入的是++idx）</p>
<p><strong>合并</strong></p>
<pre><code class="language-C++">//把编号为x和y的两个节点合并
//我们选择把y暴力接在x的后面,然后把y删除
void merge(int x, int y) {
    memcpy(a[x].s+a[x].sz, a[y].s, a[y].sz);    //把y对应的数组接到x后面
    a[x].sz += a[y].sz, a[x].nxt = a[y].nxt;    //用y的信息更新x
    del(y);     //删除y
}

</code></pre>
<p>（批注：这里使用了memcpy的用法：以下代码可以一步将b插入到a的后面，当然你手写也行，只不过效率低下，更多请参考<a href="https://flowus.cn/db56502e-9cbd-4978-a11c-91bfeee6b4b6">专题 | 网络流</a>内有关memcpy的解说）</p>
<pre><code class="language-C++">memcpy(a+len_a, b, len_b);//a,b为数组,len_a,len_b为变量，存的是a,b数组的大小
</code></pre>
<p>上述代码中的<code>del()</code>解说：</p>
<pre><code class="language-C++">void del(int x) {       //回收节点
    pool[++tot] = x;
}
</code></pre>
<p>其中pool[]中存到是没有使用的节点。因为在删除中我们会删除某些节点，这些节点就会空出来。如果每次我们在插入时都把新的分块往后分配一个新的节点，那么前面就会有一些空余的节点被浪费了，所以我们所以pool[]来记录空余的节点（或者说是已回收可再次利用的节点）</p>
<p><strong>分裂</strong></p>
<pre><code class="language-C++">//把第x个节点从pos位置分裂成两个节点(即前pos个和后sz-pos个分离)
void split(int x, int pos) {
    if(x == -1 || pos == a[x].sz) return;       //如果节点为空或者根本不需要分裂(分裂位置在块的末尾)
    int t = new_node();     //分裂后多出一个节点
    add(x, t, a[x].sz-pos, a[x].s+pos);     //把分离出来的后半部分接在原节点的后面
    a[x].sz = pos;      //把sz赋值为pos,相当于只保留了前半部分的元素,pos之后的元素还存在,只不过我们把它当成不存在(就像机械硬盘的删除数据的方式)
}

</code></pre>
<p>其中的<code>new_node()</code>操作</p>
<pre><code class="language-C++">int new_node() {        //从pool中分配一个空余的节点，返回的是节点的下标
    return pool[tot--];
}
</code></pre>
<h2 id="_34">相关操作（视频内摘录）</h2>
<p>插入</p>
<p><img alt="image.png" src="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/image%204.png" /></p>
<p>删除</p>
<p><img alt="image.png" src="../%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/image%205.png" /></p>
<h2 id="stl">扩展：STL中的块状链表</h2>
<p><a href="https://oi-wiki.org/ds/block-list/#stl-中的-rope">块状链表 - OI Wiki</a></p>
<p>可以使用如下方法来引入：</p>
<pre><code class="language-C++">#include &lt;ext/rope&gt;
using namespace __gnu_cxx;
</code></pre>
<p><code>rope</code> 目前可以在 OI 中正常使用。</p>
<h3 id="_35">基本操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rope &lt;int &gt; a</code></td>
<td>初始化 <code>rope</code>（与 <code>vector</code> 等容器很相似）</td>
</tr>
<tr>
<td><code>a.push_back(x)</code></td>
<td>在 <code>a</code> 的末尾添加元素 <code>x</code></td>
</tr>
<tr>
<td><code>a.insert(pos, x)</code></td>
<td>在 <code>a</code> 的 <code>pos</code> 个位置添加元素 <code>x</code></td>
</tr>
<tr>
<td><code>a.erase(pos, x)</code></td>
<td>在 <code>a</code> 的 <code>pos</code> 个位置删除 <code>x</code> 个元素</td>
</tr>
<tr>
<td><code>a.at(x)</code> 或 <code>a[x]</code></td>
<td>访问 <code>a</code> 的第 <code>x</code> 个元素</td>
</tr>
<tr>
<td><code>a.length()</code> 或 <code>a.size()</code></td>
<td>获取 <code>a</code> 的大小</td>
</tr>
</tbody>
</table>
<h2 id="1_5">例题 #1</h2>
<p><a href="https://flowus.cn/6c5fad6f-d48d-4678-aa57-593a12c9281c">练习 | 南外20230715树状数组&amp;线段树&amp;bitset</a></p>
<p>见第H题</p>
<p><a href="https://www.bilibili.com/video/BV1QM4y1C7H3/?spm_id_from=333.337.search-card.all.click">算法竞赛4.6-块状链表_哔哩哔哩_bilibili</a></p>
<h2 id="2-noi2003">例题 #2 [NOI2003] 文本编辑器</h2>
<p>题目描述</p>
<p>很久很久以前，<span class="arithmatex">\(DOS3.x\)</span> 的程序员们开始对 <span class="arithmatex">\(EDLIN\)</span> 感到厌倦。于是，人们开始纷纷改用自己写的文本编辑器⋯⋯</p>
<p>多年之后，出于偶然的机会，小明找到了当时的一个编辑软件。进行了一些简单的测试后，小明惊奇地发现：那个软件每秒能够进行上万次编辑操作（当然，你不能手工进行这样的测试） ！于是，小明废寝忘食地想做一个同样的东西出来。你能帮助他吗？</p>
<p>为了明确目标，小明对“文本编辑器”做了一个抽象的定义:</p>
<p>文本：由 <span class="arithmatex">\(0\)</span> 个或多个 ASCII 码在闭区间 [<span class="arithmatex">\(32\)</span>, <span class="arithmatex">\(126\)</span>] 内的字符构成的序列。</p>
<p>光标：在一段文本中用于指示位置的标记，可以位于文本首部，文本尾部或文本的某两个字符之间。</p>
<p>文本编辑器：由一段文本和该文本中的一个光标组成的，支持如下操作的数据结构。如果这段文本为空，我们就说这个文本编辑器是空的。</p>
<table>
<thead>
<tr>
<th>操作名称</th>
<th>输入文件中的格式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(\text{Move}(k)\)</span></td>
<td>Move k</td>
<td>将光标移动到第 <span class="arithmatex">\(k\)</span> 个字符之后，如果 <span class="arithmatex">\(k=0\)</span>，将光标移到文本开头</td>
</tr>
<tr>
<td><span class="arithmatex">\(\text{Insert}(n,s)\)</span></td>
<td>Insert n s</td>
<td>在光标处插入长度为 <span class="arithmatex">\(n\)</span> 的字符串 <span class="arithmatex">\(s\)</span>，光标位置不变<span class="arithmatex">\(n\geq1\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(\text{Delete}(n)\)</span></td>
<td>Delete n</td>
<td>删除光标后的 <span class="arithmatex">\(n\)</span> 个字符，光标位置不变，<span class="arithmatex">\(n \geq 1\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(\text{Get}(n)\)</span></td>
<td>Get n</td>
<td>输出光标后的 <span class="arithmatex">\(n\)</span> 个字符，光标位置不变，<span class="arithmatex">\(n \geq 1\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(\text{Prev}()\)</span></td>
<td>Prev</td>
<td>光标前移一个字符</td>
</tr>
<tr>
<td><span class="arithmatex">\(\text{Next}()\)</span></td>
<td>Next</td>
<td>光标后移一个字符</td>
</tr>
</tbody>
</table>
<p>你的任务是：</p>
<ul>
<li>
<p>建立一个空的文本编辑器。</p>
</li>
<li>
<p>从输入文件中读入一些操作并执行。</p>
</li>
<li>
<p>对所有执行过的 <code>GET</code> 操作，将指定的内容写入输出文件。</p>
</li>
</ul>
<p>输入格式</p>
<p>输入文件 <code>editor.in</code> 的第一行是指令条数 <span class="arithmatex">\(t\)</span>，以下是需要执行的 <span class="arithmatex">\(t\)</span> 个操作。其中：</p>
<p>为了使输入文件便于阅读， <code>Insert</code> 操作的字符串中可能会插入一些回车符， 请忽略掉它们（如果难以理解这句话，可以参照样例） 。</p>
<p>除了回车符之外，输入文件的所有字符的 ASCII 码都在闭区间 [<span class="arithmatex">\(32\)</span>, <span class="arithmatex">\(126\)</span>] 内。且</p>
<p>行尾没有空格。</p>
<p>这里我们有如下假定：</p>
<ul>
<li>
<p><code>MOVE</code> 操作不超过 <span class="arithmatex">\(50000\)</span> 个， <code>INSERT</code> 和 <code>DELETE</code> 操作的总个数不超过 <span class="arithmatex">\(4000\)</span>，<code>PREV</code> 和 <code>NEXT</code> 操作的总个数不超过 <span class="arithmatex">\(200000\)</span>。</p>
</li>
<li>
<p>所有 <code>INSERT</code> 插入的字符数之和不超过 <span class="arithmatex">\(2M\)</span>（<span class="arithmatex">\(1M=1024\times 1024\)</span> 字节） ，正确的输出文件长度不超过 <span class="arithmatex">\(3M\)</span> 字节。</p>
</li>
<li>
<p><code>DELETE</code> 操作和 <code>GET</code> 操作执行时光标后必然有足够的字符。 <code>MOVE</code> 、 <code>PREV</code> 、 <code>NEXT</code> 操作必然不会试图把光标移动到非法位置。</p>
</li>
<li>
<p>输入文件没有错误。</p>
</li>
</ul>
<p>对 C++ 选手的提示：经测试，最大的测试数据使用 <code>fstream</code> 进行输入有可能会比使用 <code>stdio</code> 慢约 <span class="arithmatex">\(1\)</span> 秒。</p>
<p>输出格式</p>
<p>输出文件 editor.out 的每行依次对应输入文件中每条 <code>Get</code> 指令的输出。</p>
<h1 id="_36">跳跃表（跳表）</h1>
<p>一个<span class="arithmatex">\(O(\log n)\)</span>查询与修改，空间复杂度<span class="arithmatex">\(O(2n)\)</span>的维护序列的数据结构。</p>
<p>据说可以代替平衡树。且过板子 ~~继vector平衡树后又一神操作~~</p>
<h1 id="_37">树分块</h1>
<p>原 bzoj2589。洛谷<a href="https://www.luogu.com.cn/problem/P4887">https://www.luogu.com.cn/problem/P4887</a></p>
<h2 id="1_6">例题 #1</h2>
<p>给定一个 <span class="arithmatex">\(n\)</span> 个节点的树，每个节点上有一个整数，<span class="arithmatex">\(i\)</span> 号点的整数为 <span class="arithmatex">\(val_i\)</span>。</p>
<p>有 <span class="arithmatex">\(m\)</span> 次询问，每次给出 <span class="arithmatex">\(u',v\)</span>，您需要将其解密得到 <span class="arithmatex">\(u,v\)</span>，并查询 <span class="arithmatex">\(u\)</span> 到 <span class="arithmatex">\(v\)</span> 的路径上有多少个不同的整数。</p>
<p>解密方式：<span class="arithmatex">\(u=u' \operatorname{xor} lastans\)</span>。</p>
<p><span class="arithmatex">\(lastans\)</span> 为上一次询问的答案，若无询问则为 <span class="arithmatex">\(0\)</span>。</p>
<p>对于 <span class="arithmatex">\(100\%\)</span> 的数据，<span class="arithmatex">\(1\le u,v\le n\le 4\times 10^4\)</span>，<span class="arithmatex">\(1\le m\le 10^5\)</span>，<span class="arithmatex">\(0\le u',val_i&lt;2^{31}\)</span>。</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.fe8b6f2b.min.js"></script>
      
        <script src="../../javascripts/katex.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/katex.min.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>