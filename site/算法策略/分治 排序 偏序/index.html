
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%80%92%E5%BD%92%20%E9%80%92%E6%8E%A8%20%E6%B7%B1%E6%90%9C%20%E5%B9%BF%E6%90%9C/">
      
      
        <link rel="next" href="../%E5%90%AF%E5%8F%91%E5%BC%8FA_%20IDA_/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.28">
    
    
      
        <title>分治 排序 偏序 - OI Beats</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6543a935.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://unpkg.com/katex@0/dist/katex.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="deep-orange">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="OI Beats" class="md-header__button md-logo" aria-label="OI Beats" data-md-component="logo">
      
  <img src="../../images/logo.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            OI Beats
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              分治 排序 偏序
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OI Beats" class="md-nav__button md-logo" aria-label="OI Beats" data-md-component="logo">
      
  <img src="../../images/logo.svg" alt="logo">

    </a>
    OI Beats
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    动态规划
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            动态规划
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%20DP%E4%BC%98%E5%8C%96/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DP DP优化
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%20%E5%85%A5%E9%97%A8%E5%85%B8%E4%BE%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DP 入门典例
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%20%E6%A0%91%E5%9E%8B%20%E7%8A%B6%E5%8E%8B%20%E5%80%8D%E5%A2%9E/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DP 树型 状压 倍增
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DP 背包问题
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    图论
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            图论
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/tarjan%20%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tarjan 算法相关
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE%20%E4%BA%8C%E9%83%A8%E5%9B%BE%E9%97%AE%E9%A2%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二分图 二部图问题
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    图论基础
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E5%AD%98%E5%9B%BE%20%E6%9C%80%E7%9F%AD%E8%B7%AF%20%E8%B4%9F%E7%8E%AF/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    存图 最短路 负环
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E6%A0%91%E4%B8%8A%E7%A5%96%E5%85%88%20LCA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    树上祖先 LCA
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E7%94%9F%E6%88%90%E6%A0%91%20%E5%9F%BA%E7%8E%AF%E6%A0%91/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    生成树 基环树
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    网络流
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E8%AE%BA/%E9%AB%98%E7%BA%A7%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高级线性数据结构
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    字符串
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            字符串
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%93%88%E5%B8%8C%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%88%E4%BB%8E%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0KMP%E5%86%8D%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    哈希 字符串匹配（从字典树到KMP再到AC自动机）
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%AD%97%E7%AC%A6%E4%B8%B2/%E9%AB%98%E7%B2%BE%E5%BA%A6%20%E5%BF%AB%E8%AF%BB%E5%BF%AB%E8%BE%93/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高精度 快读快输
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%AD%97%E7%AC%A6%E4%B8%B2/%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高级字符串算法
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    数学
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            数学
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E4%BA%8C%E5%88%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二分
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E5%8D%9A%E5%BC%88%E8%AE%BA%20SG%E5%87%BD%E6%95%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    博弈论 SG函数
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E5%8E%9F%E6%A0%B9%20%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    原根 拉格朗日插值 莫比乌斯反演
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E5%BF%AB%E9%80%9F%E5%B9%82%20%E7%9F%A9%E9%98%B5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    快速幂 矩阵
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%AE%9A%E7%90%86%20%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数学定理 线性代数
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%20%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%20%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    组合计数 高斯消元 容斥原理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    计算几何
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6/%E9%80%86%E5%85%83%20%E7%AD%9B%20%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B%20%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    逆元 筛 不定方程 扩展欧几里得
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    数据结构
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            数据结构
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ST%E8%A1%A8%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20%E7%BA%BF%E6%AE%B5%E6%A0%91%20%E5%88%86%E5%9D%97%20%E8%8E%AB%E9%98%9F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ST表 树状数组 线段树 分块 莫队
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二叉查找树与平衡树
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86%20%E6%89%A9%E5%B1%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    并查集 扩展
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E3%81%AE%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    高级の树上问题
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_5" >
        
          
          <label class="md-nav__link" for="__nav_6_5" id="__nav_6_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    【】专题+++ST表+++树状数组+++线段树+++分块+++莫队+4419f177 d45a 4b1d 96ea 88ca36e3ecda
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_6_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6_5">
            <span class="md-nav__icon md-icon"></span>
            【】专题+++ST表+++树状数组+++线段树+++分块+++莫队+4419f177 d45a 4b1d 96ea 88ca36e3ecda
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E3%80%91%E4%B8%93%E9%A2%98%2B%2B%2BST%E8%A1%A8%2B%2B%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2B%2B%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%2B%2B%E5%88%86%E5%9D%97%2B%2B%2B%E8%8E%AB%E9%98%9F%2B4419f177-d45a-4b1d-96ea-88ca36e3ecda/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%90%84%E7%A7%8D%E4%BF%A1%E6%81%AF/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    上帝造题的七分钟 2 / 花神游历各国
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    算法基础
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            算法基础
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E7%94%9F%E5%83%BBSTL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++关键字与生僻STL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/Head%2B%2B%2B%E6%A8%A1%E6%9D%BF%E5%A4%B4%2B%E7%BC%BA%E7%9C%81%E6%BA%90%2B2882b258-98b6-47da-be53-6525b90e8dae/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Head+++模板头+缺省源+2882b258 98b6 47da be53 6525b90e8dae
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%89%8D%E7%BC%80%E5%92%8C%20%E5%B7%AE%E5%88%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    前缀和 差分
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%A6%82%E5%BF%B5%20%E6%A6%82%E5%BF%B5%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    概念 概念性
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%B4%AA%E5%BF%83/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    贪心
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%80%92%E5%BD%92%20%E9%80%92%E6%8E%A8%20%E6%B7%B1%E6%90%9C%20%E5%B9%BF%E6%90%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    递归 递推 深搜 广搜
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" checked>
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    算法策略
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            算法策略
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    分治 排序 偏序
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    分治 排序 偏序
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      分治
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%90%AF%E5%8F%91%E5%BC%8FA_%20IDA_/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    启发式A  IDA 
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%80%9D%E6%83%B3%20%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95%20%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    思想 爬山算法 模拟退火
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      分治
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p>专题 | 分治&amp;排序&amp;偏序</p>
<h1 id="_1">目录</h1>
<ul>
<li>
<p>排序（快速/归并）</p>
</li>
<li>
<p>二分</p>
<ul>
<li>wqs 二分</li>
</ul>
</li>
<li>
<p>点分治</p>
</li>
<li>
<p>动态点分治</p>
</li>
<li>
<p>FFT高精度算法</p>
</li>
<li>
<p>cdq分治</p>
</li>
</ul>
<h2 id="_2">分治</h2>
<p>例题</p>
<p><a href="https://flowus.cn/cba00ceb-b309-4e66-9416-2405d85ac6e2">题解 | 平面最近点对</a></p>
<h1 id="_3">排序</h1>
<h2 id="_4">简单排序</h2>
<p><strong>堆排序</strong></p>
<p>全部入优先队列，然后全部出。</p>
<p><strong>sort</strong></p>
<p>不用多说了。 </p>
<h2 id="_5">计数排序</h2>
<p>先统计一遍~~塔姬娅~~桶，然后将桶前缀和，最后从桶中得到排序。</p>
<pre><code class="language-C++">for(int i=1;i&lt;=n;i++)cnt[a[i]]++;
for(int i=1;i&lt;M;i++)cnt[i]+=cnt{i-1};
for(int i=1;i&lt;=n;i++)rk[i]=cnt[a[i]],b[cnt[a[i]]--]=a[i];
</code></pre>
<h2 id="_6">基数排序</h2>
<p>基数排序通过若干个关键字排序。假设对int数字进行排序，那么我们可以把每个数字n的二进制小16位作为第二关键字，大16位作为第一关键字。然后先对第二关键字进行计数排序，然后对第一关键字进行计数排序。这样的排序是稳定的，因为计数排序的从前往后，对于值相同的数相对顺序不会改变的。</p>
<p>代码可以参考<a href="https://flowus.cn/cdc2f36a-560c-4abe-aed9-a36439b488d5">学习笔记 | SA</a>后缀数组计算函数</p>
<h2 id="_7">归并排序</h2>
<pre><code class="language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define N 100010
#define int long long
int a[N], tmp[N];
int cnt;

void merge(int left, int mid, int right) {
    int i, j, k;
    i = left;
    j = mid + 1;
    k = left;
    while (i &lt;= mid &amp;&amp; j &lt;= right) {
        if (a[i] &gt; a[j]) {
            cnt += j - k;//或者cnt += mid-i+1;
            tmp[k++] = a[j++];
        } else {
            tmp[k++] = a[i++];
        }
    }
    while (i &lt;= mid)
        tmp[k++] = a[i++];
    while (j &lt;= right)
        tmp[k++] = a[j++];

    for (i = left; i &lt;= right; i++)
        a[i] = tmp[i];
}

void merge_sort(int left, int right) {
    int mid;
    if (left == right)
        return;
    mid = (left + right) / 2;
    merge_sort(left, mid);
    merge_sort(mid + 1, right);
    merge(left, mid, right);
}

signed main() {
    int i, n;

    scanf(&quot;%lld&quot;, &amp;n);
    for (i = 1; i &lt;= n; i++)
        scanf(&quot;%lld&quot;, &amp;a[i]);

    merge_sort(1, n);

    printf(&quot;%lld\n&quot;, cnt);

    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;a[i]&lt;&lt;' ';
    }
    return 0;
}
</code></pre>
<h1 id="noip1998">自定义规则排序 | [NOIP1998 提高组] 拼数</h1>
<h2 id="_8">题目描述</h2>
<p>设有 <span class="arithmatex">\(n\)</span> 个正整数 <span class="arithmatex">\(a_1 \dots a_n\)</span>，将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。</p>
<hr />
<p>按a+b&gt;b+a排序！不要按a&gt;b排序（hack：）</p>
<pre><code class="language-C++">6
321 32 407 135 13 217

</code></pre>
<pre><code class="language-C++">4073232121713513

</code></pre>
<p>WA ans：</p>
<p>4073213221713513</p>
<pre><code class="language-C++">string s[N];

bool cmp(string a,string b){
    return a+b&gt;b+a;
}
signed main() {
//    freopen(&quot;tree.in&quot;, &quot;r&quot;, stdin);
//    freopen(&quot;tree.out&quot;, &quot;w&quot;, stdout);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i];
    sort(s+1,s+n+1,cmp);
    for(int i=1;i&lt;=n;i++)cout&lt;&lt;s[i];
    return 0;
}
</code></pre>
<h1 id="_9">拓扑排序</h1>
<h2 id="_10">排序</h2>
<p>一个不同的值的升序排序数列指的是一个从左到右元素依次增大的序列，例如，一个有序的数列 <span class="arithmatex">\(A,B,C,D\)</span> 表示 <span class="arithmatex">\(A&lt;B,B&lt;C,C&lt;D\)</span>。在这道题中，我们将给你一系列形如 <span class="arithmatex">\(A&lt;B\)</span> 的关系，并要求你判断是否能够根据这些关系确定这个数列的顺序。</p>
<p>输入格式</p>
<p>第一行有两个正整数 <span class="arithmatex">\(n,m\)</span>，<span class="arithmatex">\(n\)</span> 表示需要排序的元素数量，<span class="arithmatex">\(2\leq n\leq 26\)</span>，第 <span class="arithmatex">\(1\)</span> 到 <span class="arithmatex">\(n\)</span> 个元素将用大写的 <span class="arithmatex">\(A,B,C,D,\dots\)</span> 表示。<span class="arithmatex">\(m\)</span> 表示将给出的形如 <span class="arithmatex">\(A&lt;B\)</span> 的关系的数量。</p>
<p>接下来有 <span class="arithmatex">\(m\)</span> 行，每行有 <span class="arithmatex">\(3\)</span> 个字符，分别为一个大写字母，一个 <code>&lt;</code> 符号，一个大写字母，表示两个元素之间的关系。</p>
<p>输出格式</p>
<p>若根据前 <span class="arithmatex">\(x\)</span> 个关系即可确定这 <span class="arithmatex">\(n\)</span> 个元素的顺序 <code>yyy..y</code>（如 <code>ABC</code>），输出</p>
<p><code>Sorted sequence determined after xxx relations: yyy...y.</code></p>
<p>若根据前 <span class="arithmatex">\(x\)</span> 个关系即发现存在矛盾（如 <span class="arithmatex">\(A&lt;B,B&lt;C,C&lt;A\)</span>），输出</p>
<p><code>Inconsistency found after x relations.</code></p>
<p>若根据这 <span class="arithmatex">\(m\)</span> 个关系无法确定这 <span class="arithmatex">\(n\)</span> 个元素的顺序，输出</p>
<p><code>Sorted sequence cannot be determined.</code></p>
<p>（提示：确定 <span class="arithmatex">\(n\)</span> 个元素的顺序后即可结束程序，可以不用考虑确定顺序之后出现矛盾的情况）</p>
<p><span class="arithmatex">\(2 \leq n \leq 26,1 \leq m \leq 600\)</span>。</p>
<hr />
<p>这题你可能会想到链表+搜索，但这样复杂度不太稳定，要剪枝。</p>
<p>其实这道题是拓扑排序。我们每次给出一个关系A&gt;B就按连边A→B，然后跑一次拓扑排序。</p>
<p>对应每次拓扑排序，可能有以下的情况</p>
<ul>
<li>
<p>拓扑不成立：提出</p>
</li>
<li>
<p>单链：可以继续</p>
</li>
<li>
<p>多条链：可能会有多种情况，可以继续。</p>
</li>
</ul>
<p>到最后，可能会有以下情况</p>
<ul>
<li>
<p>单链：根据前 <span class="arithmatex">\(x\)</span> 个关系即可确定这 <span class="arithmatex">\(n\)</span> 个元素的顺序</p>
</li>
<li>
<p>多条链：可能会有多种情况，若根据这 <span class="arithmatex">\(m\)</span> 个关系无法确定这 <span class="arithmatex">\(n\)</span> 个元素的顺序，输出<code>Sorted sequence cannot be determined.</code></p>
</li>
</ul>
<p>无非是可以出现这种情况，拓扑排序可以处理。</p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image.png" /></p>
<pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;
#define rep(l, r, i) for (int i = l, END##i = r; i &lt;= END##i; ++i)
#define per(r, l, i) for (int i = r, END##i = l; i &gt;= END##i; --i)
using namespace std;
#define pb push_back
#define mp make_pair
#define int long long
#define pii pair&lt;int, int&gt;
#define ps second
#define pf first

#define lc(x) (x &lt;&lt; 1)
#define rc(x) (x &lt;&lt; 1 | 1)

#define X(j) S[j]
#define Y(j) (dp[j] + (S[j] + L) * (S[j] + L))

#define rd read()
int read() {
  int xx = 0, ff = 1;
  char ch = getchar();
  while (ch &lt; '0' || ch &gt; '9') {
    if (ch == '-')
      ff = -1;
    ch = getchar();
  }
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
    xx = xx * 10 + (ch - '0'), ch = getchar();
  return xx * ff;
}
void write(int out) {
  if (out &lt; 0)
    putchar('-'), out = -out;
  if (out &gt; 9)
    write(out / 10);
  putchar(out % 10 + '0');
}

const int N = 6e2 + 15;
const int INF = 1e9 + 5;
const int MOD = 1 &lt;&lt; 30;

int n, m;
vector&lt;int&gt; e[N];
int ind[N];
int a[N];
stack&lt;int&gt; s;
bool vis[N];
int f;

bool topo(int r) {
  int sz = 0;
  bool finished = 1;
  int t[N];
  for (int i = 0; i &lt; n; i++) {
    t[i] = ind[i];
    if (!ind[i])
      s.push(i), vis[i] = 1;
  }
  while (!s.empty()) {
    if (s.size() &gt; 1)
      finished = 0;
    int k = s.top();
    a[sz++] = k;
    s.pop();
    for (int i = 0; i &lt; e[k].size(); i++)
      t[e[k][i]]--;
    for (int i = 0; i &lt; n; i++)
      if (!t[i] &amp;&amp; !vis[i])
        s.push(i), vis[i] = 1;
    ;
  }
  if (sz &lt; n)
    return 0;
  if (finished &amp;&amp; !f)
    f = r;
  return 1;
}

signed main() {
  n = rd, m = rd;
  for (int i = 1; i &lt;= m; i++) {
    char c[3];
    scanf(&quot;%s&quot;, c);
    int x = c[0] - 'A', y = c[2] - 'A';
    e[x].push_back(y);
    ind[y]++;
    if (!topo(i)) {
      cout &lt;&lt; &quot;Inconsistency found after &quot; &lt;&lt; i &lt;&lt; &quot; relations.&quot;;
      return 0;
    }else if(f)break;
    memset(vis, 0, sizeof(vis));
  }
  if (f) {
    cout &lt;&lt; &quot;Sorted sequence determined after &quot; &lt;&lt; f &lt;&lt; &quot; relations: &quot;;
    for (int i = 0; i &lt; n; i++)
      cout &lt;&lt; char(a[i] + 'A');
    cout &lt;&lt; &quot;.&quot;;
  } else
    cout &lt;&lt; &quot;Sorted sequence cannot be determined.&quot;;
  return 0;
}

</code></pre>
<h2 id="_11">练习</h2>
<p>使用拓扑排序来解决统计从DAG中所有最长路径的数量。这适用于当我们在dp时需要知道来点的信息来更新到点的信息时。</p>
<p><a href="https://www.luogu.com.cn/problem/P4017">www.luogu.com.cn</a></p>
<p>拓扑排序的基本流程：</p>
<ul>
<li>
<p>使用队列q动态维护图中所有入度为0的点的编号</p>
</li>
<li>
<p>先找到所有入度=0的点，加入q</p>
</li>
<li>
<p>知道q为空：从q中拿出一个点，删除该点的所有出边，并时刻维护q。</p>
</li>
</ul>
<h1 id="timsort">Timsort排序</h1>
<p><span class="arithmatex">\(O(n)\)</span>的极其优秀排序！</p>
<p><a href="https://blog.csdn.net/az1112/article/details/127787971">timsort的c++实现_timsort c语言_熊掌鱼儿的博客-CSDN博客</a></p>
<h1 id="_12">二分</h1>
<p>二分模板，可用。</p>
<pre><code class="language-C++">int l=0,r=mxd;
    while(l&lt;=r){
        int mid=l+r&gt;&gt;1;
        if(judge(mid))l=mid+1;
        else r=mid-1;
    }
    cout&lt;&lt;r&lt;&lt;endl;
</code></pre>
<p>略</p>
<h1 id="wqs">wqs 二分</h1>
<h1 id="_13">整体二分 | [国家集训队] 矩阵乘法</h1>
<h2 id="_14">题目描述</h2>
<p>给你一个 <span class="arithmatex">\(n \times n\)</span> 的矩阵，不用算矩阵乘法，但是每次询问一个子矩形的第 <span class="arithmatex">\(k\)</span> 小数。</p>
<p>输入格式</p>
<p>第一行有两个整数，分别表示矩阵大小 <span class="arithmatex">\(n\)</span> 和询问组数 <span class="arithmatex">\(q\)</span>。</p>
<p>第 <span class="arithmatex">\(2\)</span> 到第 <span class="arithmatex">\((n + 1)\)</span> 行，每行 <span class="arithmatex">\(n\)</span> 个整数，表示这个矩阵。第 <span class="arithmatex">\((i + 1)\)</span> 行的第 <span class="arithmatex">\(j\)</span> 个数表示矩阵第 <span class="arithmatex">\(i\)</span> 行第 <span class="arithmatex">\(j\)</span> 列的数 <span class="arithmatex">\(a_{i, j}\)</span>。</p>
<p>接下来 <span class="arithmatex">\(q\)</span> 行，每行五个整数 <span class="arithmatex">\(x_1, y_1, x_2, y_2, k\)</span>，表示一组询问，要求找到以 <span class="arithmatex">\((x_1, y_1)\)</span> 为左上角，<span class="arithmatex">\((x_2, y_2)\)</span> 为右下角的子矩形中的第 <span class="arithmatex">\(k\)</span> 小数。</p>
<h4 id="_15">数据规模与约定</h4>
<ul>
<li>
<p>对于 <span class="arithmatex">\(20\%\)</span> 的数据，保证 <span class="arithmatex">\(n \leq 100\)</span>，<span class="arithmatex">\(q \leq 10^3\)</span>。</p>
</li>
<li>
<p>对于 <span class="arithmatex">\(40\%\)</span> 的数据，保证 <span class="arithmatex">\(n \leq 300\)</span>，<span class="arithmatex">\(q \leq 10^4\)</span>。</p>
</li>
<li>
<p>对于 <span class="arithmatex">\(60\%\)</span> 的数据，保证 <span class="arithmatex">\(n \leq 400\)</span>，<span class="arithmatex">\(q \leq 3 \times 10^4\)</span>。</p>
</li>
<li>
<p>对于 <span class="arithmatex">\(100\%\)</span> 的数据，保证 <span class="arithmatex">\(1 \leq n \leq 500\)</span>，<span class="arithmatex">\(1 \leq q \leq 6 \times 10^4\)</span>，<span class="arithmatex">\(0 \leq a_{i, j} \leq 10^9\)</span>。</p>
</li>
</ul>
<h2 id="_16">思路</h2>
<p>看起来好像是使用主席树实现的，但是二维的我们有怎么实现呢？这里可以使用可持久化二维值域线段树吗？</p>
<p>这里我们引入一个新离线算法，叫做<strong>整体二分</strong>。</p>
<h2 id="_17">整体二分</h2>
<h2 id="code">Code</h2>
<pre><code class="language-C++">/*                                                                                
                      Keyblinds Guide
                    ###################
      @Ntsc 2024

      - Ctrl+Alt+G then P : Enter luogu problem details
      - Ctrl+Alt+B : Run all cases in CPH
      - ctrl+D : choose this and dump to the next
      - ctrl+Shift+L : choose all like this
      - ctrl+K then ctrl+W: close all

*/
#include &lt;bits/stdc++.h&gt;
#include &lt;queue&gt;
using namespace std;

#define rep(i, l, r) for (int i = l, END##i = r; i &lt;= END##i; ++i)
#define per(i, r, l) for (int i = r, END##i = l; i &gt;= END##i; --i)
#define pb push_back
#define mp make_pair
#define int long long
#define pii pair&lt;int, int&gt;
#define ps second
#define pf first

// #define innt int
// #define inr int
// #define mian main
// #define iont int

#define rd read()
int read(){
    int xx = 0, ff = 1;
    char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') {
        if (ch == '-')
            ff = -1;
        ch = getchar();
    }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
      xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}
void write(int out) {
    if (out &lt; 0)
        putchar('-'), out = -out;
    if (out &gt; 9)
        write(out / 10);
    putchar(out % 10 + '0');
}

const char el='\n';
const bool enable_dbg = 0;
template &lt;typename T,typename... Args&gt;
void dbg(T s,Args... args) {
    if constexpr (enable_dbg){
    cerr &lt;&lt; s &lt;&lt; ' ';
        if constexpr (sizeof...(Args))
            dbg(args...);
    }
}

const int N = 3e3 + 5;
const int INF = 1e18;
const int M = 1e6;
const int MOD = 1e9 + 7;

struct node{
    int x,y,u,v;
    int k,id;
}q[M],q1[M],q2[M];

int tot,ans[M];
int n,m,t[N][N];


namespace ctree{

    inline int lowbit(int x){
        return x&amp;-x;
    }

    void add(int x,int y,int v){
        for(int i=x;i&lt;=n;i+=lowbit(i)){
            for(int j=y;j&lt;=n;j+=lowbit(j)){
                t[i][j]+=v;
            }
        }
    }

    int query(int x,int y){
        int res=0;
        for(int i=x;i;i-=lowbit(i)){
            for(int j=y;j;j-=lowbit(j)){
                res+=t[i][j];
            }
        }
        return res;
    }
}using namespace ctree;

void solve(int l,int r,int x,int y){
    dbg(l,r,x,y,el);
    if(l&gt;r)return ;
    if(x==y){//已经走到了一个数字上，且该数对当前区间内的操作都有贡献，那么贡献答案
        for(int i=l;i&lt;=r;i++){
            if(q[i].id)ans[q[i].id]=x;
        }
        return ;
    }

    int len1=0,len2=0,mid=x+y&gt;&gt;1;
    for(int i=l;i&lt;=r;i++){
        if(!q[i].id){
            if(q[i].k&lt;=mid)add(q[i].x,q[i].y,1),q1[++len1]=q[i];
            else q2[++len2]=q[i];
        }else{
            int t=query(q[i].u,q[i].v)-query(q[i].x-1,q[i].v)-query(q[i].u,q[i].y-1)+query(q[i].x-1,q[i].y-1);//二维树状数组，雷雨二维前缀和，提取子矩阵
            if(t&gt;=q[i].k)q1[++len1]=q[i];
            else q[i].k-=t,q2[++len2]=q[i];//更新后丢到右边
        }
    }

    for(int i=1;i&lt;=len1;i++)q[l+i-1]=q1[i];
    for(int i=1;i&lt;=len2;i++)q[l+len1+i-1]=q2[i];//重新分配所有操作
    for(int i=l;i&lt;=l+len1-1;i++){
        if(!q[i].id&amp;&amp;q[i].k&lt;=mid)add(q[i].x,q[i].y,-1);
    }

    solve(l,l+len1-1,x,mid);//注意区间下标
    solve(l+len1,r,mid+1,y);
}

void solve(){
    n=rd,m=rd;
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=n;j++){
            int a=rd;
            q[++tot]=(node){i,j,0,0,a,0};
        }
    }
    dbg(&quot;ok&quot;);
    for(int i=1;i&lt;=m;i++){
        int x=rd,y=rd,a=rd,b=rd,k=rd;
        q[++tot]=(node){x,y,a,b,k,i};
    }

    dbg(&quot;ok&quot;);
    solve(1,tot,-INF,INF);
    dbg(&quot;ok&quot;);
    for(int i=1;i&lt;=m;i++){
        cout&lt;&lt;ans[i]&lt;&lt;endl;
    }
}

signed main() {
    int T=1;
    while(T--){
        solve();
    }
    return 0;
}
</code></pre>
<h1 id="_18">点分治</h1>
<p>树分治有点分治和边分治两种，适合处理大规模树上路径信息问题。</p>
<p>树上的路径可以分为两种．</p>
<p>1 ，经过根节点的路径</p>
<p>2 ．不经过根节点的路径</p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%201.png" /></p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%202.png" /></p>
<p>对于不经过根节点的路径，可以对子树不断分治，转化为经过根节点的路径。</p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%203.png" /></p>
<h2 id="_19">重心</h2>
<p>在一棵树中存在若干个点 <span class="arithmatex">\(G\)</span>，在删去这个点 <span class="arithmatex">\(G\)</span> 后这棵树被分成了若干个连通块，并且这些连通块里所包含的点数的最大值最小。</p>
<p><strong>求法</strong>，求得的重心存在<code>rt</code>里</p>
<pre><code class="language-C++">void gtrt(int u,int fa){
    siz[u]=1;//siz记录以点i为根的子树大小,首先要把自己加上去 
    int s=0;
    for(int i=0;i&lt;e[u].size();i++){
        int v=e[i];
        if(v==fa||del[u])continue;
        gtrt(v,u);//向下递归扫描子树，获取子树的大小 
        siz[u]+=siz[v];//将自己的大小与子树累加(因为之前可能计算了左子树的,现在要将右子树的加上去) 
        s=max(s,siz[v]);//记录自己最大(包含节点最多)的儿子 
    }
    s=max(s,sum-siz[u]);//sum是整棵树的大小,这里就对应了定义里的&quot;这些连通块里所包含的点数的最大值&quot; 
    if(s&lt;mxs)mxs=s,rt=u;//如果找到更小的,则更新最小值和重心(待定的) 这里就对应了定义里的&quot;...最大值最小&quot; 
}
</code></pre>
<p><strong>举例</strong></p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%204.png" /></p>
<p>当走到u=2时，当走到最后的if时，sizu存的是以2为根的树（2,5,6,9,10）的大小，sum-siz[u]就是另一个部分（右部分 1,3,4,7,8）的大小。</p>
<p><strong>为什么要从重心处分治？</strong></p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%205.png" /></p>
<p>而把重心作为根，得到的树最均衡，复杂度最低，如图</p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%206.png" /></p>
<h2 id="_20">点分治</h2>
<p>点分治的四步操作：</p>
<p>1 ．找出树的重心做根， getroot()（优化时间复杂度）</p>
<p>2 ．求出子树中的各点到根的距离，getdis()</p>
<p>3 ．对当前树统计答案， calc()</p>
<p>4 ，分治各个子树，重复以上操作，divide()</p>
<h2 id="_21">题目描述</h2>
<p>给定一棵有 <span class="arithmatex">\(n\)</span> 个点的树，询问树上距离为 <span class="arithmatex">\(k\)</span> 的点对是否存在。</p>
<h2 id="_22">输入格式</h2>
<p>第一行两个数 <span class="arithmatex">\(n,m\)</span>。</p>
<p>第 <span class="arithmatex">\(2\)</span> 到第 <span class="arithmatex">\(n\)</span> 行，每行三个整数 <span class="arithmatex">\(u, v, w\)</span>，代表树上存在一条连接 <span class="arithmatex">\(u\)</span> 和 <span class="arithmatex">\(v\)</span> 边权为 <span class="arithmatex">\(w\)</span> 的路径。</p>
<p>接下来 <span class="arithmatex">\(m\)</span> 行，每行一个整数 <span class="arithmatex">\(k\)</span>，代表一次询问。</p>
<h2 id="_23">输出格式</h2>
<p>对于每次询问输出一行一个字符串代表答案，存在输出 <code>AYE</code>，否则输出 <code>NAY</code>。</p>
<h2 id="1">样例 #1</h2>
<h3 id="1_1">样例输入 #1</h3>
<pre><code class="language-C++">2 1
1 2 2
2
</code></pre>
<h3 id="1_2">样例输出 #1</h3>
<pre><code class="language-C++">AYE
</code></pre>
<h2 id="_24">提示</h2>
<h4 id="_25">数据规模与约定</h4>
<ul>
<li>
<p>对于 <span class="arithmatex">\(30\%\)</span> 的数据，保证 <span class="arithmatex">\(n\leq 100\)</span>。</p>
</li>
<li>
<p>对于 <span class="arithmatex">\(60\%\)</span> 的数据，保证 <span class="arithmatex">\(n\leq 1000\)</span>，<span class="arithmatex">\(m\leq 50\)</span> 。</p>
</li>
<li>
<p>对于 <span class="arithmatex">\(100\%\)</span> 的数据，保证 <span class="arithmatex">\(1 \leq n\leq 10^4\)</span>，<span class="arithmatex">\(1 \leq m\leq 100\)</span>，<span class="arithmatex">\(1 \leq k \leq 10^7\)</span>，<span class="arithmatex">\(1 \leq u, v \leq n\)</span>，<span class="arithmatex">\(1 \leq w \leq 10^4\)</span>。</p>
</li>
</ul>
<h2 id="code_1">有误的code</h2>
<pre><code class="language-C++">/*////////ACACACACACACAC///////////
Code By Ntsc
/*////////ACACACACACACAC///////////
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int N=1e4+5;
const int INF=1e7+5;


vector &lt;int&gt; e[N*2],w[N*2];
int del[N],siz[N],mxs,sum,rt;//del标记，记录在扫描子树时把根删掉，阻止往根上走 siz记录以点i为根的子树大小 
int dis[N],d[N],cnt;//dis记录点i到根的距离 cnt记录已经处理了多少 
int ans[N],q[INF],judge[INF];//judge记录长度为i的路径是否存在
int ask[N],m,n; 

void calc(int u);
void add(int x,int y,int z){
    e[x].push_back(y);
    w[x].push_back(z);
}
void gtrt(int u,int fa){
    siz[u]=1;//siz记录以点i为根的子树大小,首先要把自己加上去 
    int s=0;
    for(int i=0;i&lt;e[u].size();i++){
        int v=e[u][i];
        if(v==fa||del[v])continue;
        gtrt(v,u);//向下递归扫描子树，获取子树的大小 
        siz[u]+=siz[v];//将自己的大小与子树累加(因为之前可能计算了左子树的,现在要将右子树的加上去) 
        s=max(s,siz[v]);//记录自己最大(包含节点最多)的儿子 
    }
    s=max(s,sum-siz[u]);//sum是整棵树的大小,这里就对应了定义里的&quot;这些连通块里所包含的点数的最大值&quot; 
    if(s&lt;mxs)mxs=s,rt=u;//如果找到更小的,则更新最小值和重心(待定的) 这里就对应了定义里的&quot;...最大值最小&quot; 
}
void gtdis(int u,int fa){
    dis[++cnt]=d[u];
    for(int i=0;i&lt;e[u].size();i++){
        int v=e[u][i];
        if(v==fa||del[v])continue;
        d[v]=d[u]+w[u][i];//用fa到根的距离加上fa到u的距离 
        gtdis(v,u);
    }
}
void divide(int u){//分治 

    calc(u);
    del[u]=1;
    for(int i=0;i&lt;e[u].size();i++){
        int v=e[u][i];
        if(del[v])continue;
        mxs=sum=siz[v];
        gtrt(v,0);
        divide(rt);//从树的重心开始分治 
    }
}
void calc(int u){
    judge[0]=1;
    int p=0;//记录多少个judge被更新了,后面要清空,这样就不用memset了 

    for(int i=0;i&lt;e[u].size();i++){
        int v=e[u][i];
        if(del[v])continue;
        cnt=0;
        d[v]=w[u][i];
        gtdis(v,u);

        for(int j=1;j&lt;=cnt;j++){
            for(int k=1;k&lt;=m;k++){//扫描所有询问,判定答案. 当然,如果要把所有长度是否存在处理出来也可以 
                if(ask[k]&gt;=dis[j])ans[k]|=judge[ask[k]-dis[j]];//目前已经有一条长度为dis[j]的路线了,当扫描到询问是否有长度为ask[k]的路线时,只要判定是否存在长度为ask[k]-dis[j]的路线(在之前扫描过的)就可以
                //当然,只有ask[k]&gt;=dis[j]才有可能 
            }
        }

        for(int j=1;j&lt;=cnt;j++){
            if(dis[j]&lt;INF){//询问的长度最长为INF,超过它就没有必要计算了 
                q[++p]=dis[j];judge[dis[j]]=1;//走完这个子树,将要到下一个子树时,才更新judge数组,因为在上方的判定时&quot;是否存在长度为ask[k]-dis[j]的路线&quot;的路线必须与当前正在扫描的路线没有重叠部分 
//              q[++p]=dis[j], judge[q[p]]=1;
            }
        }
        //清空数据 ,复杂度小 
        for(int i=1;i&lt;=p;i++)judge[q[i]]=0;
    }
}
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;n;i++){
        int u,v,ww;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;ww;
        add(u,v,ww);add(v,u,ww);
    }
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;ask[i];
    }

    mxs=sum=n;
    gtrt(1,0);
    gtrt(rt,0);
    divide(rt);//离线算法 

    for(int i=1;i&lt;=m;i++){
        if(ans[i])cout&lt;&lt;&quot;AYE&quot;&lt;&lt;endl;
        else cout&lt;&lt;&quot;NAY&quot;&lt;&lt;endl;
    }
    return 0;
}

</code></pre>
<h2 id="std">Std</h2>
<pre><code class="language-C++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

const int N=10005;
const int INF=10000005;
struct node{int v,w,ne;}e[N&lt;&lt;1];
int h[N],idx; //加边
int del[N],siz[N],mxs,sum,root;//求根
int dis[N],d[N],cnt; //求距离
int ans[N],q[INF],judge[INF];//求路径
int n,m,ask[N];

void add(int u,int v,int w){
  e[++idx].v=v; e[idx].w=w;  
  e[idx].ne=h[u]; h[u]=idx;
}
void getroot(int u,int fa){
  siz[u]=1; 
  int s=0;
  for(int i=h[u];i;i=e[i].ne){
    int v=e[i].v;
    if(v==fa||del[v])continue;
    getroot(v,u);
    siz[u]+=siz[v];
    s=max(s,siz[v]);
  }
  s=max(s,sum-siz[u]);
  if(s&lt;mxs) mxs=s, root=u;
}
void getdis(int u,int fa){
  dis[++cnt]=d[u];
  for(int i=h[u];i;i=e[i].ne){
    int v=e[i].v;
    if(v==fa||del[v])continue;
    d[v]=d[u]+e[i].w;
    getdis(v,u);
  }
}
void calc(int u){
  judge[0]=1;
  int p=0;
  // 计算经过根u的路径
  for(int i=h[u];i;i=e[i].ne){
    int v=e[i].v;
    if(del[v])continue;
    // 求出子树v的各点到u的距离
    cnt=0; 
    d[v]=e[i].w;
    getdis(v,u); 
    // 枚举距离和询问，判定答案
    for(int j=1;j&lt;=cnt;++j)
      for(int k=1;k&lt;=m;++k)
        if(ask[k]&gt;=dis[j])
          ans[k]|=judge[ask[k]-dis[j]];
    // 记录合法距离      
    for(int j=1;j&lt;=cnt;++j)
      if(dis[j]&lt;INF)
        q[++p]=dis[j], judge[q[p]]=1;
  }
  // 清空距离数组
  for(int i=1;i&lt;=p;++i) judge[q[i]]=0;  
}
void divide(int u){
  // 计算经过根u的路径
  calc(u); 
  // 对u的子树进行分治
  del[u]=1;
  for(int i=h[u];i;i=e[i].ne){
    int v=e[i].v;
    if(del[v])continue;
    mxs=sum=siz[v];
    getroot(v,0); //求根
    divide(root); //分治
  }
}
int main(){
  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
  for(int i=1;i&lt;n;++i){
    int u,v,w;
    scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
    add(u,v,w);add(v,u,w);
  }
  for(int i=1;i&lt;=m;++i)
    scanf(&quot;%d&quot;,&amp;ask[i]);
  mxs=sum=n;
  getroot(1,0); 
  getroot(root,0); //重构siz[] 
  divide(root);
  for(int i=1;i&lt;=m;++i)
    ans[i]?puts(&quot;AYE&quot;):puts(&quot;NAY&quot;);
  return 0;
}
</code></pre>
<h1 id="empty">动态点分治（empty）</h1>
<h1 id="fftempty">FFT高精度（empty）</h1>
<p>代码</p>
<pre><code class="language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
#define cp complex &lt;double&gt;
const int N=10000005;
const double PI=acos(-1);
int n=1,la,lb,res[N*2];
cp a[N],b[N],omg[N],inv[N];
char sa[N],sb[N];

void init(){
    for(int i=0;i&lt;n;i++){
        omg[i]=cp(cos(2*PI*i/n),sin(2*PI*i/n));
        inv[i]=conj(omg[i]);
    }
}

void fft(cp *a,cp *omg){
    int lim =0;
    while((1&lt;&lt;lim)&lt;n)lim++;
    for(int i=0;i&lt;n;i++){
        int t=0;
        for(int j=0;j&lt;lim;j++)if((i&gt;&gt;j)&amp;1)t|=(1&lt;&lt;(lim-j-1));
        if(i&lt;t)swap(a[i],a[t]);
    }
    for(int l=2;l&lt;=n;l*=2){
        int m=l/2;
        for(cp *p=a;p!=a+n;p+=l)for(int i=0;i&lt;m;i++){
            cp t=omg[n/l*i]*p[i+m];
            p[i+m]=p[i]-t;
            p[i]+=t;
        }
    }
}
signed main(){
    //freopen(&quot;P1919_1.in&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%s%s&quot;,&amp;sa,&amp;sb);
    la=strlen(sa),lb=strlen(sb);

    while(n&lt;la+lb)n*=2;
    for(int i=0;i&lt;la;i++)a[i].real(sa[la-1-i]-'0');
    for(int i=0;i&lt;lb;i++)b[i].real(sb[lb-1-i]-'0');

    init();

    fft(a,omg);
    fft(b,omg);

    for(int i=0;i&lt;n;i++){
        a[i]*=b[i];
    }

    fft(a,inv);

    for(int i=0;i&lt;n;i++){
        res[i]+=floor(a[i].real()/n+0.5);
        res[i+1]+=res[i]/10;
        res[i]%=10;
    }
    int l=la+lb-1;
    if(!res[la+lb-1])l--;
    for(int i=l;i&gt;=0;i--)putchar('0'+res[i]);

    return 0;
}
</code></pre>
<h1 id="cdq">CDQ分治（偏序问题）</h1>
<p>【模板】三维偏序（陌上花开）</p>
<p>这是一道模板题，可以使用 bitset，CDQ 分治，KD-Tree 等方式解决。本题我们使用CDQ分治。</p>
<p>有 <span class="arithmatex">\(n\)</span> 个元素，第 <span class="arithmatex">\(i\)</span> 个元素有 <span class="arithmatex">\(a_i,b_i,c_i\)</span> 三个属性，设 <span class="arithmatex">\(f(i)\)</span> 表示满足 <span class="arithmatex">\(a_j \leq a_i\)</span> 且 <span class="arithmatex">\(b_j \leq b_i\)</span> 且 <span class="arithmatex">\(c_j \leq c_i\)</span> 且 <span class="arithmatex">\(j \ne i\)</span> 的 <span class="arithmatex">\(j\)</span> 的数量。</p>
<p>对于 <span class="arithmatex">\(d \in [0, n)\)</span>，求 <span class="arithmatex">\(f(i) = d\)</span> 的数量。</p>
<p>输出 <span class="arithmatex">\(n\)</span> 行，第 <span class="arithmatex">\(d + 1\)</span> 行表示 <span class="arithmatex">\(f(i) = d\)</span> 的 <span class="arithmatex">\(i\)</span> 的数量。</p>
<p>$ 1 \leq n \leq 10^5<span class="arithmatex">\(，\)</span>1 \leq a_i, b_i, c_i \le k \leq 2 \times 10^5 $。</p>
<h2 id="cdq_1">CDQ分治</h2>
<p><a href="https://oi-wiki.org/misc/cdq-divide/">https://oi-wiki.org/misc/cdq-divide/</a></p>
<p>我们先从二维偏序来引入。</p>
<h2 id="_26"><strong>二维偏序</strong></h2>
<p>****给你一个长度为<span class="arithmatex">\(n\)</span>的序列，每个序列都有<span class="arithmatex">\(a,b\)</span>两种属性，让你求具有某些关系的点对<span class="arithmatex">\((i,j)\)</span>个数。一般思路是先确定一维的顺序，在此基础上用树状数组维护第二维。</p>
<p>逆序对的树状数组做法其实就是应用了二维偏序的思想。</p>
<p><strong>逆序对</strong></p>
<p>对于给定的一段正整数序列，逆序对就是序列中 <span class="arithmatex">\(a_i&gt;a_j\)</span> 且 <span class="arithmatex">\(i&lt;j\)</span> 的有序对。请算出给定的一段正整数序列中逆序对的数目。注意序列中可能有重复数字。</p>
<pre><code class="language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define N 100010
#define int long long
int a[N], tmp[N];
int cnt;

void merge(int left, int mid, int right) {
    int i, j, k;
    i = left;
    j = mid + 1;
    k = left;
    while (i &lt;= mid &amp;&amp; j &lt;= right) {
        if (a[i] &gt; a[j]) {
            cnt += j - k;//或者cnt += mid-i+1;
            tmp[k++] = a[j++];
        } else {
            tmp[k++] = a[i++];
        }
    }
    while (i &lt;= mid)
        tmp[k++] = a[i++];
    while (j &lt;= right)
        tmp[k++] = a[j++];

    for (i = left; i &lt;= right; i++)
        a[i] = tmp[i];
}

void merge_sort(int left, int right) {
    int mid;
    if (left == right)
        return;
    mid = (left + right) / 2;
    merge_sort(left, mid);
    merge_sort(mid + 1, right);
    merge(left, mid, right);
}

signed main() {
    int i, n;

    scanf(&quot;%lld&quot;, &amp;n);
    for (i = 1; i &lt;= n; i++)
        scanf(&quot;%lld&quot;, &amp;a[i]);

    merge_sort(1, n);

    printf(&quot;%lld\n&quot;, cnt);

    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;a[i]&lt;&lt;' ';
    }
    return 0;
}
</code></pre>
<p>对于所有数据，<span class="arithmatex">\(n \leq 5 \times 10^5\)</span></p>
<p><strong>思路</strong></p>
<p>我们维护值域树状数组，从左往右逐渐加入<span class="arithmatex">\(a_i\)</span>，并且求出树状数组中值域在<span class="arithmatex">\(1\sim a_i\)</span>的前缀和<span class="arithmatex">\(q_i\)</span>即可（树状数组维护前缀和），然后用<span class="arithmatex">\(i-q_i\)</span>就求出了下标在i之前且值比a_i大的数的个数。</p>
<p>为了优化空间，我们离散化一下即可。</p>
<p>先将数据排序，再用 <span class="arithmatex">\(1 \sim n\)</span> 分别对应 <span class="arithmatex">\(n\)</span> 个数表示它们的相对大小，对新的序列建树状数组空间就够了。对于相等的值，我们让越靠近左边的相对大小越小即可。</p>
<p><strong>练习</strong></p>
<p><a href="https://www.luogu.com.cn/problem/CF1311F">www.luogu.com.cn</a></p>
<p>在数轴 <span class="arithmatex">\(OX\)</span> 上有 <span class="arithmatex">\(n\)</span> 个点。第 <span class="arithmatex">\(i\)</span> 个点最初在坐标 <span class="arithmatex">\(x_i\)</span>， 并且有一个速度 <span class="arithmatex">\(v_i\)</span>，<span class="arithmatex">\(x_i\)</span> 互不相同。第 <span class="arithmatex">\(i\)</span> 个点在 <span class="arithmatex">\(t\)</span> 时刻的坐标为 <span class="arithmatex">\(x_i + t \cdot v_i\)</span> （<span class="arithmatex">\(t\)</span> 可能不是整数）。</p>
<p>对于两个点 <span class="arithmatex">\(i\)</span> 和 <span class="arithmatex">\(j\)</span>，设 <span class="arithmatex">\(d(i,j)\)</span> 为 <span class="arithmatex">\(i\)</span> 和 <span class="arithmatex">\(j\)</span> 在任意时刻下的可能的最小距离（时刻可能不是整数）。如果 <span class="arithmatex">\(i\)</span> 和 <span class="arithmatex">\(j\)</span> 在某一时刻重合，那么 <span class="arithmatex">\(d(i,j)=0\)</span>。</p>
<p>你的任务是计算出下面这个式子的值（对于任意两个点的最小距离之和）：</p>
<p><span class="arithmatex">\(\sum_{1\leq i &lt; j \leq n}d(i,j)\)</span></p>
<p>本题要求任意两点中间的最小距离之和，并且没有说要在同一时间取到。所以我们可以想到，这两个点的最小距离要么是 <span class="arithmatex">\(0\)</span>，要么是初始距离。</p>
<p>那么什么时候是 <span class="arithmatex">\(0\)</span> 呢？很容易可以知道，设这两个点为 <span class="arithmatex">\(i,j\)</span>，如果 <span class="arithmatex">\(x_i&lt;x_j\)</span> 且 <span class="arithmatex">\(v_i&gt;v_j\)</span>，那么 <span class="arithmatex">\(d(i,j)=0\)</span>。就是常说的追及问题。</p>
<p>那么什么时候是初始距离呢？当然就是追不上的情况，即 <span class="arithmatex">\(x_i&lt;x_j\)</span> 且 <span class="arithmatex">\(v_i&lt;v_j\)</span>。</p>
<p>所以本题就变成了：求所有 <span class="arithmatex">\(i,j\)</span> 使得 <span class="arithmatex">\(x_i&lt;x_j\)</span> 且 <span class="arithmatex">\(v_i≤v_j\)</span>，求 <span class="arithmatex">\(x_j-x_i\)</span>。</p>
<p>乍一看前面的条件，那不就是二维偏序嘛（类似逆序对，只不过是顺序对）。那么我们就往二维偏序上去想。</p>
<p>二维偏序最常用的是什么？树状数组。回顾一下逆序对的树状数组做法是怎么样的。我们维护值域树状数组，从左往右逐渐加入 <span class="arithmatex">\(a_i\)</span>（即在 <span class="arithmatex">\(a_i\)</span> 处 <span class="arithmatex">\(+1\)</span>），并且求出树状数组中值域在 <span class="arithmatex">\(1\sim a_i\)</span> 的前缀和 <span class="arithmatex">\(q_i\)</span> 即可（树状数组维护前缀和），然后用 <span class="arithmatex">\(i-q_i\)</span> 就求出了下标在 <span class="arithmatex">\(i\)</span> 之前且值比 <span class="arithmatex">\(a_i\)</span> 大的数的个数。</p>
<p>那么本题要求的是值，而不是个数，我们就可以考虑维护两个树状数组，一个记录 <span class="arithmatex">\(x_i\)</span> 的大小关系，为权值树状数组，我们称之为 <span class="arithmatex">\(A\)</span>；一个记录 <span class="arithmatex">\(x_i\)</span> 的值，我们称之为 <span class="arithmatex">\(B\)</span>。</p>
<p>按照 <span class="arithmatex">\(v_i\)</span> 从小到大排序，我们遍历 <span class="arithmatex">\(i\)</span>。当我们遍历到一个 <span class="arithmatex">\(x_i\)</span>，我们就在 <span class="arithmatex">\(A\)</span> 中查询满足 <span class="arithmatex">\(x_j&lt;x_i\)</span> 的 <span class="arithmatex">\(x_j\)</span> 的个数，记为 <span class="arithmatex">\(cnt_i\)</span>，然后在 <span class="arithmatex">\(B\)</span> 中求出这些 <span class="arithmatex">\(x_j\)</span> 的和，我们记为 <span class="arithmatex">\(sum_i\)</span>。那么很显然，答案应该加上 <span class="arithmatex">\(x_i\times cnt_i-sum_i\)</span>。</p>
<p>最后我们将 <span class="arithmatex">\(x_i\)</span> 分别插入 <span class="arithmatex">\(A,B\)</span> 中。注意，<span class="arithmatex">\(x_i\)</span> 在 <span class="arithmatex">\(B\)</span> 中插入的相对位置应该和 <span class="arithmatex">\(A\)</span> 中的一样。</p>
<pre><code class="language-C++">/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . FancyKnowledge .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//
#include&lt;bits/stdc++.h&gt;

//
#define int long long
#define ull unsigned long long
#define db double
#define endl '\n'
#define err(fmt, ...) fprintf(stderr, &quot;[%d] : &quot; fmt &quot;\n&quot;, __LINE__, ##__VA_ARGS__)
///*
#define pr pair&lt;double,int&gt;
#define pf first
#define ps second
#define pb push_back
//*/

//
using namespace std;
//
const int N=2e5+5;
const int M=1e3;
const int MOD=1e9+7;
const int MMOD=903250223;
const int INF=1e9;
const int IINF=1e18;
const db eps=1e-9;
//
int n,m,x,y;

int to[N],ans;
int c[2][N&lt;&lt;2];//两棵树状数组

struct node{
    int x,v;
}a[N];


int lowbit(int x) {
    return x&amp;-x;
}


void add(int f,int i,int x) {//在位置i加上x
    while(i&lt;=n) {
        c[f][i]+=x;
        i+=lowbit(i);
    }
}


int query(int f,int x) {
    int res=0;
    while(x) {
        res+=c[f][x];
        x-=lowbit(x);
    }
    return res;
}

bool cmp(node a,node b){
    if(a.v==b.v)return a.x&lt;b.x;//v相同时也追不上
    return a.v&lt;b.v;
}

signed main() {
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i].x;
        to[i]=a[i].x;
    }
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i].v;
    }
    sort(to+1,to+n+1);
    for(int i=1;i&lt;=n;i++){
        a[i].x=lower_bound(to+1,to+n+1,a[i].x)-to;//离散化，将值a_i离散为第x大
    }

    sort(a+1,a+n+1,cmp);

    for(int i=1;i&lt;=n;i++){
        int sum=query(1,a[i].x-1);
        add(1,a[i].x,to[a[i].x]);
        int cnt=query(0,a[i].x-1);
        add(0,a[i].x,1);
        ans+=cnt*to[a[i].x]-sum;


    }

    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>注意本题需要离散化。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a.x</td>
<td>2</td>
<td>5</td>
<td>13</td>
<td>9</td>
</tr>
<tr>
<td>to排序后</td>
<td>2</td>
<td>5</td>
<td>9</td>
<td>13</td>
</tr>
<tr>
<td>a.x离散化后</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><span class="arithmatex">\(a_i.x\)</span> 离散化后的值即 <span class="arithmatex">\(a_i.x\)</span> 在所有 <span class="arithmatex">\(x\)</span> 中按从小到大排序后的排名。这样即可把值域映射到 <span class="arithmatex">\(n\)</span>。</p>
<p>注意树状数组空间大小不能只开 <span class="arithmatex">\(n\)</span>。</p>
<h2 id="_27"><strong>三维偏序</strong></h2>
<p>CDQ 分治是一种特殊的分治方法，通常用来解决一类“存在修改，但修改独立、允许离线”的数据结构题。实际上它的本质是按时间分治，若要处理时间<span class="arithmatex">\([l,r]\)</span>上的修改与询问操作，就先处理<span class="arithmatex">\([l,mid]\)</span>上的修改对<span class="arithmatex">\([mid+1,r]\)</span>上的询问的影响，之后再递归处理<span class="arithmatex">\([l,mid][mid+1,r]\)</span>，根据问题的不同，这几个步骤的顺序有时也会不一样。</p>
<p>CDQ 分治适用于满足以下两个条件的数据结构题：</p>
<p>（ 1 ）修改操作对询问的贡献独立，修改操作之问互不影响效果。</p>
<p>（ 2 ）题目允许使用离线算法。</p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%207.png" /></p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%208.png" /></p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%209.png" /></p>
<p><strong>总结</strong></p>
<p>三维偏序就是在二维偏序的基础上加上一维。
给你一个长度为n的序列，每个序列都有a，b，c三种属性，让你求具有某些关系的点对（i，j）个数。一般思路是先确定一维的顺序，分治维护第二维，再结合上边的二维偏序中的树状数组维护第三维。</p>
<ul>
<li>
<p>找到这个序列的中点 mid</p>
</li>
<li>
<p>将所有点对（i,j）划分为 3 类
第一类是<span class="arithmatex">\([l,i,j,mid,r]\)</span>
第二类是<span class="arithmatex">\([l,i,mid,j,r]\)</span>
第三类是<span class="arithmatex">\([l,mid,i,j,r]\)</span></p>
</li>
<li>
<p>将 这个序列拆成两个序列（1，mid）和 (mid+1,n) 会发现第一类点对和第三类点对都在这两个序列之中，递归的去解决这两类点对</p>
</li>
</ul>
<p>通过分治来解决第二类点对</p>
<p><strong>本题思路</strong></p>
<p>先按<span class="arithmatex">\(x\)</span>排序。</p>
<p>分治时每次将前半边、后半边分别按<span class="arithmatex">\(y\)</span>排序。虽然现在<span class="arithmatex">\(x\)</span>的顺序被打乱了，但是前半边还是都小于后半边的，所以要是只计算前半边对后半边的偏序关系，是不会受到<span class="arithmatex">\(x\)</span>的影响的。</p>
<p>维护后一半的指针<span class="arithmatex">\(i\)</span>，前一半的指针<span class="arithmatex">\(j\)</span>，每次将i后移一位时，若<span class="arithmatex">\(y_j≤y_i\)</span>则不断后移<span class="arithmatex">\(j\)</span>，并不断将<span class="arithmatex">\(z_j\)</span>加入树状数组。然后再查询树状数组中有多少数小于等于<span class="arithmatex">\(z_i\)</span>（树状数组求前缀和）。 </p>
<p>最后要清空树状数组。</p>
<p><strong>代码</strong></p>
<p>暴力</p>
<pre><code class="language-C++">/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . FancyKnowledge .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//
#include&lt;bits/stdc++.h&gt;

//
#define int long long
#define ull unsigned long long
#define db double
#define endl '\n'
#define err(fmt, ...) fprintf(stderr, &quot;[%d] : &quot; fmt &quot;\n&quot;, __LINE__, ##__VA_ARGS__)
///*
#define pr pair&lt;double,int&gt;
#define pf first
#define ps second
#define pb push_back
//*/

//
using namespace std;
//
const int N=2e5+5;
const int M=1e3;
const int MOD=1e9+7;
const int MMOD=903250223;
const int INF=1e9;
const int IINF=1e18;
const db eps=1e-9;
//
int n,m,a[N],b[N],c[N],q,s[N],k,idx,len[N],ans,res,tmp,cnt[N],id[N];

int d(int x){
    int res=0;
    for(int i=1;i&lt;=n;i++){
        if(i==x)continue;
        if(a[i]&lt;=a[x]&amp;&amp;b[i]&lt;=b[x]&amp;&amp;c[i]&lt;=c[x])res++;
    }
    return res;
}

signed main(){

//  freopen(&quot;.in&quot;,&quot;r&quot;,stdin);
//  freopen(&quot;.out&quot;,&quot;w&quot;,stdout);
//  freopen(&quot;.txt&quot;,&quot;w&quot;,stderr);

    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];

    }

    for(int i=1;i&lt;=n;i++){
        cnt[d(i)]++;
    }

    for(int i=0;i&lt;n;i++){
        cout&lt;&lt;cnt[i]&lt;&lt;endl;
    }
    return 0;
}

//check your long long and the size of memery!!!

</code></pre>
<p>CDQ 分治嵌套</p>
<pre><code class="language-C++">/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . FancyKnowledge .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

//
#include&lt;bits/stdc++.h&gt;

//
#define int long long
#define ull unsigned long long
#define db double
#define endl '\n'
#define err(fmt, ...) fprintf(stderr, &quot;[%d] : &quot; fmt &quot;\n&quot;, __LINE__, ##__VA_ARGS__)
///*
#define pr pair&lt;double,int&gt;
#define pf first
#define ps second
#define pb push_back
//*/

//
using namespace std;



#define rd read()
inline int read() {
    int xx = 0, ff = 1;
    char ch = getchar();
    while (ch &lt; '0' || ch &gt; '9') {
        if (ch == '-')
            ff = -1;
        ch = getchar();
    }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}
inline void write(int out) {
    if (out &lt; 0)
        putchar('-'), out = -out;
    if (out &gt; 9)
        write(out / 10);
    putchar(out % 10 + '0');
}
//
const int N=2e5+5;
const int M=1e3;
const int MOD=1e9+7;
const int MMOD=903250223;
const int INF=1e9;
const int IINF=1e18;
const db eps=1e-9;
//
int n,m,ans[N],q,d[N],k,idx,len[N],res,tmp,cnt[N],id[N];

struct node{
    int a,b,c,f;
    int *ans;
}a[N],b[N],c[N];

bool cmp(node x,node y){
    if(x.a == y.a&amp;&amp;x.b==y.b)return x.c&lt;y.c;
    if(x.a==y.a)return x.b&lt;y.b;
    return x.a&lt;y.a;
}

void cdq2(int l,int r){
    if(l==r)return;
    int mid = (l+r)/2;
    cdq2(l,mid);
    cdq2(mid+1,r);
    int i=l,k=mid+1,j=l,cnt=0;
    for(;i&lt;=r;i++){
        if((k&gt;r||b[j].c&lt;=b[k].c)&amp;&amp;j&lt;=mid)c[i]=b[j++],cnt+=c[i].f;
        else{
            c[i]=b[k++];
            if(!c[i].f)*c[i].ans+=cnt;
        }
    }
    for(i=l;i&lt;=r;i++)b[i]=c[i];

}

void cdq1(int l,int r){
    if(l==r)return;
    int mid = (l+r)/2;
    cdq1(l,mid);
    cdq1(mid+1,r);

    int i=l,k=mid+1,j=l;
    for(;i&lt;=r;i++){
        if((k&gt;r||a[j].b&lt;=a[k].b)&amp;&amp;j&lt;=mid)b[i]=a[j++],b[i].f=1;
        else b[i]=a[k++],b[i].f=0;
    }
    for(int i=l;i&lt;=r;i++)a[i]=b[i];

    cdq2(l,r);
}
signed main(){

//  freopen(&quot;.in&quot;,&quot;r&quot;,stdin);
//  freopen(&quot;.out&quot;,&quot;w&quot;,stdout);
//  freopen(&quot;.txt&quot;,&quot;w&quot;,stderr);

    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1;i&lt;=n;i++){
        a[i].a=rd;a[i].b=rd;a[i].c=rd;
        a[i].ans=&amp;ans[i];

    }sort(a+1,a+n+1,cmp);

    for(int i=n-1;i;i--){
        if(a[i].a==a[i+1].a&amp;&amp;a[i].b==a[i+1].b&amp;&amp;a[i].c==a[i+1].c)*a[i].ans=*a[i+1].ans+1;
    }

    cdq1(1,n);

    for(int i=1;i&lt;=n;i++)d[ans[i]]++;
    for(int i=0;i&lt;n;i++)cout&lt;&lt;d[i]&lt;&lt;endl;
    return 0;
}

//check your long long and the size of memery!!!

</code></pre>
<p>树状数组cdq分治</p>
<p><a href="https://www.luogu.com.cn/blog/hbxblog/solution-p3810">www.luogu.com.cn</a></p>
<pre><code class="language-C++">/*
CB Ntsc111
*/

#include &lt;bits/stdc++.h&gt; m
using namespace std;

#define ull unsigned int
#define pii pair&lt;int, int&gt;
#define pf to
#define ps second
#define pb push_back
#define int long long

#define err cerr &lt;&lt; &quot;Error&quot;
#define rd read()

#define ot write
#define nl putchar('\n')
int read() {
  int xx = 0, ff = 1;
  char ch = getchar();
  while (ch &lt; '0' || ch &gt; '9') {
    if (ch == '-')
      ff = -1;
    ch = getchar();
  }
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
    xx = xx * 10 + (ch - '0'), ch = getchar();
  return xx * ff;
}
void write(int out) {
  if (out &lt; 0)
    putchar('-'), out = -out;
  if (out &gt; 9)
    write(out / 10);
  putchar(out % 10 + '0');
}

const int mxxlog = 10;
int INF = 1e18 + 7;
const int N = 5e5 + 5;

int n, k;
int ans[N], d[N];
int tr[N];
struct node {
  int a, b, c, *id;
} a[N], b[N], c[N], tmp[N];

int stk[N], top;

inline int lowbit(int x) { return x &amp; -x; }

void add(int x, int v = 1) {
  while (x &lt;= N) {
    // cerr &lt;&lt; x &lt;&lt; endl;
    tr[x] += v;
    x += lowbit(x);
  }
}

int query(int x) {
  int res = 0;
  while (x) {
    res += tr[x];
    x -= lowbit(x);
  }
  return res;
}

void cdq(int l, int r) {
  // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl;
  if (l == r)
    return;
  int mid = l + r &gt;&gt; 1;
  cdq(l, mid);
  cdq(mid + 1, r);

  int i = l, j = mid + 1, k = l - 1;

  while (i &lt;= mid &amp;&amp; j &lt;= r) {
    if (a[i].b &lt;= a[j].b) {
      // *a[i].id += query(a[i].c);
      add(a[i].c);
      stk[++top] = a[i].c;
      tmp[++k] = a[i];
      i++;
    } else {
      *a[j].id += query(a[j].c);
      // cerr&lt;&lt;a[j].id-ans&lt;&lt;':'&lt;&lt; query(a[j].c)&lt;&lt;endl;
      // add(a[j].c);
      // stk[++top] = a[j].c;
      tmp[++k] = a[j];
      j++;
    }
  }

  while (i &lt;= mid)
    tmp[++k] = a[i++];
  while (j &lt;= r) {
    tmp[++k] = a[j];
      // cerr&lt;&lt;j&lt;&lt;'-'&lt;&lt; query(a[j].c)&lt;&lt;endl;
    *a[j].id += query(a[j].c);
    j++;
  }
  while (top) {
    add(stk[top--], -1);
  }
  memset(tr,0,sizeof tr);
  // cerr &lt;&lt; &quot;dbg:&quot; &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl;
  for (int i = l; i &lt;= r; i++) {
    // cerr &lt;&lt; tmp[i].a &lt;&lt; ' ' &lt;&lt; tmp[i].b &lt;&lt; ' ' &lt;&lt; tmp[i].c &lt;&lt; endl;
    a[i] = tmp[i];
  }
}
bool cmp(node x, node y) {
  if (x.a == y.a &amp;&amp; x.b == y.b)
    return x.c &lt; y.c;
  if (x.a == y.a)
    return x.b &lt; y.b;
  return x.a &lt; y.a;
}
signed main() {
  n = rd, k = rd;
  for (int i = 1; i &lt;= n; i++) {
    a[i].a = rd, a[i].b = rd, a[i].c = rd, a[i].id = &amp;ans[i];
  }

  sort(a + 1, a + n + 1, cmp);

  for (int i = n - 1; i; i--) {
    if (a[i].a == a[i + 1].a &amp;&amp; a[i].b == a[i + 1].b &amp;&amp; a[i].c == a[i + 1].c)
      *a[i].id = *a[i + 1].id + 1;
  }

  // cerr &lt;&lt; &quot;OK&quot;;
  cdq(1, n);
  for (int i = 1; i &lt;= n; i++)
    d[ans[i]]++;
  for (int i = 0; i &lt; n; i++)
    printf(&quot;%lld\n&quot;,d[i]);
}
</code></pre>
<h2 id="_28"><strong>扩展：四维偏序</strong></h2>
<p>维护四维偏序，我们恐怕不能按排序+分治+树状数组这三种不同的方法组合来解决了。</p>
<p>其实我们的CDQ分治是可以嵌套的，如下：</p>
<p><a href="https://www.luogu.com.cn/blog/user39216/solution-p3810">www.luogu.com.cn</a></p>
<p>我们假设四维偏序的4个关键字为<span class="arithmatex">\(x,y,z,k\)</span>。</p>
<p>我们按<span class="arithmatex">\(x\)</span>从小到大（也有可能是别的顺序）排序，然后从中间分治。那么对于区间<span class="arithmatex">\([l,mid][mid+1,r]\)</span>中分别按照<span class="arithmatex">\(y\)</span>从小到大排序。</p>
<p>这样我们能保证左边的<span class="arithmatex">\(x\)</span>一定小于右边的x。那么对于左右区间，我们有可以继续分治，然后按<span class="arithmatex">\(z\)</span>的从小到大排序。继续分治下去，按照<span class="arithmatex">\(k\)</span>从小到大排序。这样我们就可以把区间分成8块，满足左边的块中的<span class="arithmatex">\(x,y,z\)</span>都小于右边的块。</p>
<p>这就是CDQ的嵌套。对于处理4个关键字的偏序（四维偏序），我们就需要三层嵌套。对于高维偏序，我们也可以这样嵌套下去。</p>
<h2 id="_29">练习</h2>
<p><a href="https://www.luogu.com.cn/problem/P2365">www.luogu.com.cn</a></p>
<p>高维偏序特殊性质的求解</p>
<p><a href="https://yundouxueyuan.com/p/YDRG001F">题目详情 - 有根树上求八维偏序 - 云斗学院</a></p>
<p>利用偏序值域非常小而实现偏序条件多的情况，此时应该直接使用桶来记录答案，并且考虑如何快速地统计答案。</p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%2010.png" /></p>
<p><img alt="image.png" src="../%E4%B8%93%E9%A2%98%2B%2B%2B%E5%88%86%E6%B2%BB%2B%2B%2B%E6%8E%92%E5%BA%8F%2B%2B%2B%E5%81%8F%E5%BA%8F%2B6259f0a0-531d-4942-a5bf-fd11f42869c8/image%2011.png" /></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.fe8b6f2b.min.js"></script>
      
        <script src="../../javascripts/katex.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/katex.min.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>